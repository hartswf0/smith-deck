<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Smith Chart — Musical Interface</title>
<style>
  :root{
    --bg:#0b0c0f; --panel:#0f1115; --ink:#e6e6e6; --muted:#9aa4ad; --accent:#6ee7ff; --accent2:#a7f3d0; --grid:#263241; --grid2:#334155; --good:#34d399; --bad:#f87171; --warn:#fbbf24;
    --shadow:0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";}
  #app{position:fixed; inset:0; display:grid; grid-template-rows: 1fr auto;}
  canvas{display:block; width:100%; height:100%; touch-action:none;}

  .hud{position:absolute; top:12px; left:12px; right:12px; display:flex; gap:8px; flex-wrap:wrap; pointer-events:none}
  .pill{pointer-events:auto; background:rgba(15,17,21,.75); backdrop-filter: blur(8px); border:1px solid rgba(255,255,255,.06); border-radius:999px; padding:8px 12px; display:flex; align-items:center; gap:10px; box-shadow:var(--shadow)}
  .badge{font-variant-numeric: tabular-nums; font-size:12px; color:var(--muted)}
  .dot{width:10px; height:10px; border-radius:50%}

  .panel{background:linear-gradient(180deg, rgba(16,18,23,.9), rgba(16,18,23,.9)); border-top:1px solid rgba(255,255,255,.06); box-shadow: var(--shadow);}
  .controls{display:grid; grid-template-columns:repeat(12,1fr); gap:10px; padding:12px; max-width:1200px; margin-inline:auto;}
  .controls label{font-size:12px; color:var(--muted)}
  .controls input[type="number"], .controls input[type="text"], .controls select{width:100%; background:#0c0e13; color:var(--ink); border:1px solid #1f2937; border-radius:10px; padding:8px 10px; font-variant-numeric: tabular-nums;}
  .controls input[type="range"]{width:100%}
  .row{display:flex; flex-direction:column; gap:6px}
  .sp12{grid-column: span 12}
  .sp6{grid-column: span 6}
  .sp4{grid-column: span 4}
  .sp3{grid-column: span 3}
  .sp2{grid-column: span 2}
  .btn{cursor:pointer; user-select:none; background:#0c0e13; color:var(--ink); border:1px solid #1f2937; border-radius:12px; padding:10px 12px; display:flex; align-items:center; justify-content:center}
  .btn:active{transform:translateY(1px)}
  .btn.primary{background:#0f172a; border-color:#233042}
  .toggle{display:flex; align-items:center; gap:8px}
  .toggle input{accent-color:#67e8f9}
  .muted{color:var(--muted)}
  .link{color:var(--accent); text-decoration:underline; cursor:pointer}
  .help{position:absolute; right:12px; bottom:90px; background:rgba(15,17,21,.9); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:12px; width:min(420px, calc(100vw - 24px)); box-shadow: var(--shadow); font-size:13px; line-height:1.35; display:none}
  .help.show{display:block}

  @media (max-width: 860px){
    .sp6{grid-column: span 12}
    .sp4{grid-column: span 6}
    .sp3{grid-column: span 6}
    .sp2{grid-column: span 6}
  }
</style>
</head>
<body>
  <div id="app">
    <canvas id="chart" aria-label="Interactive Smith Chart Musical Interface" role="img"></canvas>

    <!-- Heads-up stats -->
    <div class="hud" id="hud">
      <div class="pill" title="Resonance Amplitude (0-1)"><div class="dot" style="background:var(--accent)"></div><span class="badge">Volume</span><b id="mag">0.000</b></div>
      <div class="pill" title="Phase Angle in degrees (can be mapped to stereo/detune)"><div class="dot" style="background:var(--accent2)"></div><span class="badge">Phase</span><b id="ang">0.0°</b></div>
      <div class="pill" title="Harmonic Richness (1=pure tone, higher=more harmonics)"><div class="dot" style="background:var(--warn)"></div><span class="badge">Harmonics</span><b id="vswr">1.00</b></div>
      <div class="pill" title="Sound Clarity / Damping (dB)"><div class="dot" style="background:var(--bad)"></div><span class="badge">Clarity</span><b id="rl">∞ dB</b></div>
      <div class="pill" title="Timbre / Filter Settings"><span class="badge">Timbre</span><b id="zread">—</b></div>
      <div class="pill" title="LFO Control"><span class="badge">LFO</span><b id="yread">—</b></div>
    </div>

    <div class="help" id="helpBox">
      <b>Smith Chart Musical Interface Quick Guide</b><br/>
      • Tap or click inside the circle to set the main sound's timbre. Drag to refine.<br/>
      • The 'L' dot indicates the primary sound (derived from Freq, Filter Q/Cutoff).<br/>
      • The 'S' dot shows the sound after Delay effect.<br/>
      • Toggle <i>Complementary Timbre</i> to add a second voice.<br/>
      • <b>Share</b> copies a URL with your current sound settings.<br/>
      <div style="height:6px"></div>
      <span class="muted">Acoustic impedance matching is essential in musical instruments. The Smith Chart visualizes resonance (volume), harmonics (VSWR), and timbre (filter settings) based on your interactions.</span>
    </div>

    <div class="panel">
      <div class="controls">
        <div class="row sp3"><label>Z₀ (Acoustic Ref.)</label><input id="z0" type="number" step="1" min="0.1" value="50"></div>
        <div class="row sp3"><label>Freq (Hz)</label><input id="freqHz" type="number" step="1" min="20" max="20000" value="440"></div>
        <div class="row sp3"><label>Filter Q (0-100)</label><input id="filterQ" type="number" step="0.1" min="0" max="100" value="1"></div>
        <div class="row sp3"><label>Cutoff Offset (Hz)</label><input id="filterCutoffOffset" type="number" step="0.1" value="0"></div>

        <div class="row sp3"><label>LFO Rate (Hz)</label><input id="lfoRate" type="number" step="0.1" min="0" max="20" value="0"></div>
        <div class="row sp3"><label>LFO Depth (0-1)</label><input id="lfoDepth" type="number" step="0.01" min="0" max="1" value="0"></div>
        <div class="row sp3"><label>Delay Time (ms)</label><input id="delayTimeMs" type="range" min="0" max="1000" step="1" value="0"><span class="muted" id="delayTimeRead">0 ms</span></div>
        <div class="row sp3"><label>Delay Feedback (0-1)</label><input id="delayFeedback" type="number" step="0.01" min="0" max="0.99" value="0.4"></div>

        <div class="row sp3 toggle"><label><input id="waveform" type="radio" name="waveform" value="sine" checked> Sine</label><label><input type="radio" name="waveform" value="square"> Square</label><label><input type="radio" name="waveform" value="sawtooth"> Sawtooth</label><label><input type="radio" name="waveform" value="triangle"> Triangle</label></div>
        <div class="row sp3 toggle"><label><input id="showAdmit" type="checkbox"> Complementary Timbre</label></div>
        <div class="row sp2 toggle"><label><input id="hiGrid" type="checkbox" checked> Hi‑detail grid</label></div>
        <div class="row sp2"><button class="btn" id="reset">Reset</button></div>
        <div class="row sp2"><button class="btn primary" id="share">Share</button></div>

        <div class="row sp12"><button class="btn" id="help">Help / Tips</button></div>
      </div>
    </div>
  </div>

<script>
(function(){
  const $ = sel=>document.querySelector(sel);
  const canvas = $('#chart');
  const ctx = canvas.getContext('2d');
  let DPR = Math.min(2, window.devicePixelRatio || 1);
  let W=0,H=0,CX=0,CY=0,R=0; // canvas sizing

  // Audio Context and Nodes
  let audioCtx;
  let osc, filter, masterGain, lfo, lfoGain;
  let oscY, filterY; // for complementary timbre
  let delay, delayFeedbackGain;
  let isAudioReady = false;

  // State
  const state = {
    z0: 50, // Acoustic reference (analogous to characteristic impedance)
    freqHz: 440, // Base frequency in Hz
    filterQ: 1, // Filter Q factor
    filterCutoffOffset: 0, // Filter cutoff offset from base freq
    lfoRate: 0, // LFO frequency in Hz
    lfoDepth: 0, // LFO gain modulation depth (0-1)
    delayTimeMs: 0, // Delay time in milliseconds
    delayFeedback: 0.4, // Delay feedback (0-1)
    waveform: 'sine', // Oscillator waveform
    showAdmit: false, // Show complementary timbre
    hiGrid: true,
    // user marker in Gamma plane (complex) — set by inputs or tapping
    gamma: {re: 0, im: 0},
    fromTap: false // if the current state.gamma comes from user tapping (disables R/X input parsing)
  };

  // UI Elements
  const inputs = {
    z0: $('#z0'), freqHz: $('#freqHz'), filterQ: $('#filterQ'), filterCutoffOffset: $('#filterCutoffOffset'),
    lfoRate: $('#lfoRate'), lfoDepth: $('#lfoDepth'), delayTimeMs: $('#delayTimeMs'), delayFeedback: $('#delayFeedback'),
    delayTimeRead: $('#delayTimeRead'),
    mag: $('#mag'), ang: $('#ang'), vswr: $('#vswr'), rl: $('#rl'), zread: $('#zread'), yread: $('#yread'),
    waveformRadios: document.querySelectorAll('input[name="waveform"]'),
    showAdmit: $('#showAdmit'), hiGrid: $('#hiGrid'),
    reset: $('#reset'), share: $('#share'), help: $('#help'), helpBox: $('#helpBox')
  };

  // Complex helpers
  const C = {
    add: (a,b)=>({re:a.re+b.re, im:a.im+b.im}),
    sub: (a,b)=>({re:a.re-b.re, im:a.im-b.im}),
    mul: (a,b)=>({re:a.re*b.re - a.im*b.im, im:a.re*b.im + a.im*b.re}),
    div: (a,b)=>{ const d=b.re*b.re + b.im*b.im || 1e-18; return {re:(a.re*b.re + a.im*b.im)/d, im:(a.im*b.re - a.re*b.im)/d}; },
    conj:(a)=>({re:a.re, im:-a.im}),
    mag:(a)=>Math.hypot(a.re, a.im),
    ang:(a)=>Math.atan2(a.im, a.re),
    expj:(phi)=>({re:Math.cos(phi), im:Math.sin(phi)}),
  };

  // Mapping between normalized z and reflection coefficient gamma
  function z2g(z){ // z is {re, im}
    const num = C.sub(z, {re:1, im:0});
    const den = C.add(z, {re:1, im:0});
    return C.div(num, den);
  }
  function g2z(g){
    const num = C.add({re:1, im:0}, g);
    const den = C.sub({re:1, im:0}, g);
    return C.div(num, den);
  }

  function yFromZ(z){ // y = 1/z
    const den = z.re*z.re + z.im*z.im || 1e-18; return {re: z.re/den, im: -z.im/den};
  }

  // Coordinates
  function toPX(pt){ return {x: CX + R*pt.re, y: CY - R*pt.im}; }
  function fromPX(x,y){ return {re:(x-CX)/R, im:-(y-CY)/R}; }

  function resize(){
    const rect = canvas.getBoundingClientRect();
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.round(rect.width * DPR); H = Math.round(rect.height * DPR);
    canvas.width = W; canvas.height = H;
    canvas.style.width = rect.width + 'px'; canvas.style.height = rect.height + 'px';
    ctx.setTransform(1,0,0,1,0,0); ctx.scale(DPR,DPR);
    // layout
    const w = rect.width, h = rect.height;
    const pad = 16; const s = Math.min(w, h) - pad*2; R = (s/2);
    CX = w/2; CY = h/2 - 10; // slight lift for bottom panel spacing
    draw();
  }

  // Grid drawing
  function drawGrid(){
    ctx.save();
    // Background gradient subtle
    const grad = ctx.createRadialGradient(CX, CY, R*0.1, CX, CY, R*1.2);
    grad.addColorStop(0, '#0b0c0f');
    grad.addColorStop(1, '#0a0c10');
    ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);

    // Clip to unit circle
    ctx.beginPath();
    ctx.arc(CX, CY, R, 0, Math.PI*2);
    ctx.clip();

    // minor grid
    const rMaj = [0,0.2,0.5,1,2,5];
    const xMaj = [0.2,0.5,1,2,5];
    const rMin = state.hiGrid ? [0.1,0.3,0.7,1.5,3,7] : [];
    const xMin = state.hiGrid ? [0.1,0.3,0.7,1.5,3,7] : [];

    // helper to draw circle in Gamma plane (center, radius) masked
    function circle(cx, cy, rr, lw, col){
      ctx.beginPath(); ctx.lineWidth = lw; ctx.strokeStyle = col; ctx.arc(CX + R*cx, CY - R*cy, R*rr, 0, Math.PI*2); ctx.stroke();
    }

    // constant resistance circles: center (r/(r+1),0), radius 1/(r+1)
    const colMin = getCSS('--grid');
    const colMaj = getCSS('--grid2');

    // draw minor first
    ctx.globalAlpha=.7;
    rMin.forEach(r=>{ circle(r/(r+1), 0, 1/(r+1), 1, colMin); });
    xMin.forEach(x=>{
      const rad = 1/Math.abs(x); const cy = 1/x; // centers at (1, 1/x)
      circle(1, cy, rad, 1, colMin);
      circle(1, -cy, rad, 1, colMin);
    });

    // major
    ctx.globalAlpha=1;
    rMaj.forEach((r,i)=>{ circle(r/(r+1), 0, 1/(r+1), 1.5, colMaj); });
    xMaj.forEach(x=>{
      const rad = 1/Math.abs(x); const cy = 1/x;
      circle(1, cy, rad, 1.5, colMaj);
      circle(1, -cy, rad, 1.5, colMaj);
    });

    // boundary
    ctx.globalAlpha=1; ctx.lineWidth=2; ctx.strokeStyle = 'rgba(255,255,255,.15)';
    ctx.beginPath(); ctx.arc(CX, CY, R, 0, Math.PI*2); ctx.stroke();

    // real axis
    ctx.lineWidth=1.5; ctx.strokeStyle='rgba(255,255,255,.18)';
    ctx.beginPath(); ctx.moveTo(CX - R, CY); ctx.lineTo(CX + R, CY); ctx.stroke();

    // labels (r, x)
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto'; ctx.fillStyle='rgba(255,255,255,.6)'; ctx.textAlign='center'; ctx.textBaseline='top';
    rMaj.forEach(r=>{
      const p = toPX({re: (r-1)/(r+1), im: 0}); // leftmost point on each r circle crosses real axis at ( (r-1)/(r+1), 0 )
      ctx.fillText('r='+r, p.x, CY+4);
    });
    ctx.textBaseline='bottom';
    xMaj.forEach(x=>{
      // Adjust label placement for better visibility
      const labelX = CX + R * 0.78; // Offset slightly from edge
      const labelYPos = CY - R * (1 / Math.abs(x)); // Position relative to current x arc
      const labelYNeg = CY + R * (1 / Math.abs(x));

      // Small adjustment for text baseline
      if (x > 0) { // Top arcs
        ctx.fillText('+j'+x, labelX, labelYPos - 4);
      } else { // Bottom arcs
        ctx.fillText('−j'+x, labelX, labelYNeg + 16);
      }
    });

    ctx.restore();
  }

  function getCSS(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }

  // Calculate load gamma from inputs or tap
  function computeGammaFromInputs(){
    const z0 = state.z0;
    const filterQ = state.filterQ; // R equivalent
    const filterCutoffOffset = state.filterCutoffOffset; // X equivalent
    const z = {re: Math.max(0, filterQ/z0), im: filterCutoffOffset/z0}; // Normalize
    const g = z2g(z);
    return g;
  }

  function vswrFromMag(m){ return m>=0.999999 ? Infinity : (1+m)/(1-m); }
  function rlFromMag(m){ return m<=0 ? Infinity : -20*Math.log10(m); }

  function rotateGamma(g, delayTimeMs){ // Simulating delay by rotation. Angle is not direct λ here.
    // For a physical line, rotation is -4pi * (l/lambda). We can map delayTimeMs to a fraction of a "max" wavelength
    const maxDelay = 1000; // ms
    const rotationFactor = delayTimeMs / maxDelay; // Normalize 0-1
    const phi = -2 * Math.PI * rotationFactor; // Rotate from 0 to -360 degrees
    const ej = C.expj(phi);
    return C.mul(g, ej);
  }

  // Draw points and guides
  function drawData(){
    // Determine gamma from either tap state or inputs
    const baseGamma = state.fromTap ? state.gamma : computeGammaFromInputs();
    // Save computed gamma back so stats reflect it if not from tap
    if (!state.fromTap) state.gamma = baseGamma;

    // Rotated gamma after delay effect
    const gSrc = rotateGamma(baseGamma, state.delayTimeMs);

    // Draw SWR circle
    const mag = C.mag(baseGamma);
    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = 1.5; ctx.setLineDash([6,6]); ctx.strokeStyle = `rgba(255,255,255,${0.25 * Math.max(0.2, mag)})`; // Opacity depends on mag
    const rSWR = R*mag; ctx.arc(CX, CY, rSWR, 0, Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);

    // Load point (Primary Sound)
    plotMarker(baseGamma, getCSS('--accent'), 4 + mag*4, 'L'); // Marker size scales with amplitude
    // Source point after delay
    if (state.delayTimeMs > 0) {
      plotMarker(gSrc, getCSS('--accent2'), 3 + mag*3, 'S');
    }

    // Admittance point (Complementary Timbre)
    if (state.showAdmit){
      const gY = {re: -baseGamma.re, im: -baseGamma.im};
      plotMarker(gY, '#fde68a', 3 + mag*3, 'Y');
    }

    ctx.restore();

    // Stats
    const z = g2z(baseGamma); // normalized
    const Z_eff = {re: z.re*state.z0, im: z.im*state.z0}; // "Effective impedance" values for display
    const y = yFromZ(z);
    const Y_eff = {re: y.re/state.z0, im: y.im/state.z0}; // "Effective admittance" values for display

    const m = mag;
    const vs = vswrFromMag(m);
    const rl = rlFromMag(m);
    inputs.mag.textContent = m.toFixed(3);
    inputs.ang.textContent = (C.ang(baseGamma)*180/Math.PI).toFixed(1)+'°';
    inputs.vswr.textContent = (vs===Infinity? '∞' : vs.toFixed(2));
    inputs.rl.textContent = (rl===Infinity? '∞ dB' : rl.toFixed(2)+' dB');
    inputs.zread.textContent = `Q: ${state.filterQ.toFixed(1)} / Cutoff: ${state.filterCutoffOffset.toFixed(1)}Hz`;
    inputs.yread.textContent = `Rate: ${state.lfoRate.toFixed(1)}Hz / Depth: ${state.lfoDepth.toFixed(2)}`;
  }

  function plotMarker(g, color, r=3, label){
    const p = toPX(g);
    // guard: only plot inside unit circle
    if (C.mag(g) > 1.0001) return;
    ctx.beginPath(); ctx.fillStyle=color; ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
    // label
    ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto'; ctx.textAlign='left'; ctx.textBaseline='middle';
    ctx.fillStyle='rgba(255,255,255,.8)';
    ctx.fillText(label, p.x+r+2, p.y);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();
    drawData();
  }

  // --- Web Audio API Integration ---
  function initAudio() {
    if (isAudioReady) return;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      // Master gain
      masterGain = audioCtx.createGain();
      masterGain.connect(audioCtx.destination);
      masterGain.gain.value = 0; // Start silent

      // LFO for modulation effects (tremolo)
      lfo = audioCtx.createOscillator();
      lfo.frequency.value = 0; // Start at 0Hz (no modulation)
      lfo.start();

      lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 1; // Base gain, will be modulated by LFO
      lfo.connect(lfoGain.gain); // LFO modulates lfoGain's gain
      lfoGain.connect(masterGain);

      // Main Oscillator path
      osc = audioCtx.createOscillator();
      osc.type = state.waveform;
      osc.frequency.value = state.freqHz;
      osc.start(); // Start once

      filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass'; // Default filter type
      filter.frequency.value = state.freqHz;
      filter.Q.value = state.filterQ;
      osc.connect(filter);
      filter.connect(lfoGain); // Connect filter output to LFO modulated gain

      // Delay effect
      delay = audioCtx.createDelay(1.0); // Max delay 1 second
      delayFeedbackGain = audioCtx.createGain();
      delayFeedbackGain.gain.value = state.delayFeedback;

      lfoGain.connect(delay); // Send main output to delay
      delay.connect(delayFeedbackGain); // Delay output feeds back
      delayFeedbackGain.connect(delay); // Feedback loop
      delay.connect(masterGain); // Delay output also goes to master gain

      // Complementary Timbre (oscY, filterY)
      oscY = audioCtx.createOscillator();
      oscY.type = state.waveform;
      oscY.frequency.value = state.freqHz * 1.005; // Slightly detuned
      oscY.start();

      filterY = audioCtx.createBiquadFilter();
      filterY.type = 'highpass'; // Different filter type for contrast
      filterY.frequency.value = state.freqHz * 0.9;
      filterY.Q.value = state.filterQ;
      oscY.connect(filterY);
      filterY.connect(masterGain); // Connect directly to master gain

      isAudioReady = true;
      console.log("AudioContext initialized!");
    } catch (e) {
      console.error("Web Audio API not supported or failed to initialize:", e);
      // Fallback or user notification here
    }
  }

  function updateSynth() {
    if (!isAudioReady) return;

    // Use current state to derive gamma, then update audio params
    const baseGamma = state.fromTap ? state.gamma : computeGammaFromInputs();
    const mag = C.mag(baseGamma);

    // Apply mappings to audio nodes
    osc.type = state.waveform;
    osc.frequency.value = Math.max(20, Math.min(20000, state.freqHz)); // Clamp frequency

    masterGain.gain.value = Math.min(1, Math.max(0, mag)); // Volume from |Gamma|

    filter.Q.value = Math.min(100, Math.max(0, state.filterQ));
    filter.frequency.value = Math.min(20000, Math.max(20, state.freqHz + state.filterCutoffOffset));

    lfo.frequency.value = Math.min(20, Math.max(0, state.lfoRate));
    lfoGain.gain.value = Math.min(1, Math.max(0, (1 - state.lfoDepth))); // LFO modulates FROM base value 1, so depth is inverse
    // A more common approach is to use an additional gain node for LFO depth
    // e.g. lfo.connect(lfoDepthGain); lfoDepthGain.connect(osc.detune) / lfoDepthGain.connect(masterGain.gain)
    // For tremolo, lfo connects to gain.gain, so 1 - depth makes sense.

    delay.delayTime.value = Math.min(1, Math.max(0, state.delayTimeMs / 1000));
    delayFeedbackGain.gain.value = Math.min(0.99, Math.max(0, state.delayFeedback));

    // Complementary timbre logic
    if (state.showAdmit) {
      oscY.type = state.waveform;
      oscY.frequency.value = Math.max(20, Math.min(20000, state.freqHz * 1.005));
      filterY.Q.value = Math.min(100, Math.max(0, state.filterQ));
      filterY.frequency.value = Math.min(20000, Math.max(20, state.freqHz * 0.9));
      // Ensure it's connected and playing
      oscY.connect(filterY); // Reconnect in case it was disconnected
      filterY.connect(masterGain);
    } else {
      // Disconnect if not shown
      oscY.disconnect && oscY.disconnect(filterY);
      filterY.disconnect && filterY.disconnect(masterGain);
    }
  }

  // Event wiring
  ['z0','freqHz','filterQ','filterCutoffOffset','lfoRate','lfoDepth','delayFeedback'].forEach(k=>{
    inputs[k].addEventListener('input', ()=>{ state[k] = parseFloat(inputs[k].value)||0; state.fromTap=false; draw(); updateSynth(); updateHash(false); });
  });
  inputs.delayTimeMs.addEventListener('input', ()=>{ state.delayTimeMs = parseFloat(inputs.delayTimeMs.value)||0; inputs.delayTimeRead.textContent = state.delayTimeMs.toFixed(0)+' ms'; state.fromTap=false; draw(); updateSynth(); updateHash(false); });
  inputs.waveformRadios.forEach(radio => {
    radio.addEventListener('change', () => { state.waveform = radio.value; state.fromTap=false; draw(); updateSynth(); updateHash(false); });
  });
  inputs.showAdmit.addEventListener('change', ()=>{ state.showAdmit = inputs.showAdmit.checked; draw(); updateSynth(); updateHash(false); });
  inputs.hiGrid.addEventListener('change', ()=>{ state.hiGrid = inputs.hiGrid.checked; draw(); });
  inputs.reset.addEventListener('click', ()=>{ 
    Object.assign(state,{
      z0:50, freqHz:440, filterQ:1, filterCutoffOffset:0, lfoRate:0, lfoDepth:0, delayTimeMs:0, delayFeedback:0.4, 
      waveform:'sine', showAdmit:false, hiGrid:true, fromTap:false, gamma:{re:0,im:0}
    }); 
    syncToUI(); draw(); updateSynth(); updateHash(false); 
  });
  inputs.share.addEventListener('click', ()=>{ const url = updateHash(true); navigator.clipboard?.writeText(url); flash('Copied shareable URL to clipboard'); });
  inputs.help.addEventListener('click', ()=>{ inputs.helpBox.classList.toggle('show'); });

  function syncToUI(){
    inputs.z0.value=state.z0; inputs.freqHz.value=state.freqHz; inputs.filterQ.value=state.filterQ; inputs.filterCutoffOffset.value=state.filterCutoffOffset; 
    inputs.lfoRate.value=state.lfoRate; inputs.lfoDepth.value=state.lfoDepth; inputs.delayTimeMs.value=state.delayTimeMs; inputs.delayFeedback.value=state.delayFeedback;
    inputs.delayTimeRead.textContent = state.delayTimeMs.toFixed(0)+' ms'; 
    inputs.showAdmit.checked=state.showAdmit; inputs.hiGrid.checked=state.hiGrid;
    document.querySelector(`input[name="waveform"][value="${state.waveform}"]`).checked = true;
  }

  // Tap/drag to set gamma
  let dragging=false;
  canvas.addEventListener('pointerdown', (e)=>{ 
    initAudio(); // Ensure audio context starts on first interaction
    dragging=true; setFromEvent(e); 
  });
  canvas.addEventListener('pointermove', (e)=>{ if(dragging){ setFromEvent(e); }});
  window.addEventListener('pointerup', ()=> dragging=false);

  function setFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left); const y = (e.clientY - rect.top);
    const g = fromPX(x,y);
    const m = C.mag(g);
    if (m<=1){
      state.gamma = g; state.fromTap = true; // derive R/X and set fields
      const z = g2z(g); // normalized impedance
      
      // Map normalized z.re and z.im back to filter Q and cutoff offset
      // We need to scale them appropriately for the input ranges.
      state.filterQ = Math.max(0, z.re * state.z0); // Assuming filterQ maps directly to R
      // For X, use a range that's appropriate for cutoff offset
      const maxCutoffOffset = 1000; // Example max offset
      state.filterCutoffOffset = z.im * state.z0 * (maxCutoffOffset / state.z0); // Scale by Z0 and max offset
      
      // Clamp values to UI limits
      state.filterQ = Math.min(100, Math.max(0, state.filterQ));
      state.filterCutoffOffset = Math.min(2000, Math.max(-2000, state.filterCutoffOffset)); // Example range for offset

      // When tapping, other controls (LFO, Delay, Freq) remain as set unless specified
      // For simplicity, we only update R, X here.
      syncToUI(); draw(); updateSynth(); updateHash(false);
    }
  }

  // Share via URL hash
  function updateHash(write){
    const obj = { 
      z0:state.z0, freqHz:state.freqHz, filterQ:state.filterQ, filterCutoffOffset:state.filterCutoffOffset, 
      lfoRate:state.lfoRate, lfoDepth:state.lfoDepth, delayTimeMs:state.delayTimeMs, delayFeedback:state.delayFeedback,
      waveform:state.waveform, showAdmit:state.showAdmit?1:0, hiGrid:state.hiGrid?1:0, 
      g:[+state.gamma.re.toFixed(6), +state.gamma.im.toFixed(6)], t: state.fromTap?1:0 
    };
    const hash = btoa(encodeURIComponent(JSON.stringify(obj)));
    if (write){ location.hash = hash; return location.href; }
    else { history.replaceState(null,'', location.pathname + '#' + hash); return location.href; }
  }
  function restoreFromHash(){
    const h = location.hash.slice(1); if(!h) return;
    try{
      const obj = JSON.parse(decodeURIComponent(atob(h)));
      Object.assign(state, {
        z0:obj.z0, freqHz:obj.freqHz, filterQ:obj.filterQ, filterCutoffOffset:obj.filterCutoffOffset, 
        lfoRate:obj.lfoRate, lfoDepth:obj.lfoDepth, delayTimeMs:obj.delayTimeMs, delayFeedback:obj.delayFeedback,
        waveform:obj.waveform || 'sine', showAdmit:!!obj.showAdmit, hiGrid:!!obj.hiGrid, 
        gamma:{re:obj.g?.[0]||0, im:obj.g?.[1]||0}, fromTap: !!obj.t
      });
    }catch(e){ console.warn('Bad hash', e); }
  }

  function flash(msg){
    const pill = document.createElement('div'); pill.className='pill'; pill.textContent = msg; pill.style.position='absolute'; pill.style.left='12px'; pill.style.bottom='110px'; pill.style.zIndex='10';
    document.body.appendChild(pill); setTimeout(()=>pill.remove(), 1600);
  }

  // Init
  restoreFromHash();
  syncToUI();
  window.addEventListener('resize', resize, {passive:true});
  resize(); // Initial draw
  // Audio will be initialized on first user interaction
})();
</script>
</body>
</html>