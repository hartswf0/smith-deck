<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>RF Dual-Deck Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        :root {
            --neon-green: #00ff88;
            --neon-blue: #00ccff;
            --neon-purple: #cc00ff;
            --dark-bg: #0a0a0a;
            --grid-color: rgba(0, 255, 136, 0.3);
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--dark-bg);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }

        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .header {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 12px 16px;
            border-bottom: 2px solid var(--neon-green);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }

        .app-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--neon-green);
            letter-spacing: 1px;
        }

        .deck-controls {
            display: flex;
            gap: 8px;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: #333;
            border-radius: 15px;
            cursor: pointer;
            transition: background 0.3s ease;
            border: 2px solid var(--neon-green);
        }

        .toggle-switch.active {
            background: var(--neon-green);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        .toggle-switch.active::after {
            transform: translateX(30px);
        }

        .deck-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px;
            overflow: hidden;
        }

        .deck {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--neon-blue);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
            position: relative;
        }

        .deck.b {
            border-color: var(--neon-purple);
        }

        .deck.collapsed {
            height: 60px !important;
        }

        .deck-header {
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .deck-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--neon-blue);
        }

        .deck.b .deck-title {
            color: var(--neon-purple);
        }

        .deck-status {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .deck-content {
            height: calc(100% - 60px);
            position: relative;
            overflow: hidden;
        }

        .smith-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        .spectrum-display {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 1px solid var(--neon-green);
        }

        .control-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-row {
            display: flex;
            gap: 12px;
            margin-bottom: 8px;
            align-items: center;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-label {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 60px;
        }

        .mode-selector {
            display: flex;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 2px;
        }

        .mode-btn {
            flex: 1;
            padding: 6px 8px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 11px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mode-btn.active {
            background: var(--neon-green);
            color: black;
        }

        .slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--neon-green);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--neon-green);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--neon-green);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px var(--neon-green);
        }

        .preset-container {
            position: absolute;
            top: 60px;
            right: 12px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--neon-green);
            border-radius: 8px;
            padding: 8px;
            display: none;
            z-index: 50;
        }

        .preset-container.show {
            display: block;
        }

        .preset-btn {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 4px;
            background: transparent;
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preset-btn:hover {
            background: var(--neon-green);
            color: black;
        }

        .preset-btn:last-child {
            margin-bottom: 0;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: var(--neon-green);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            z-index: 200;
            display: none;
            border: 1px solid var(--neon-green);
        }

        .tooltip.show {
            display: block;
        }

        .info-display {
            position: absolute;
            top: 90px;
            left: 12px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            color: var(--text-secondary);
            border: 1px solid var(--neon-green);
        }

        .info-item {
            margin-bottom: 2px;
        }

        .info-item:last-child {
            margin-bottom: 0;
        }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            .deck-container {
                flex-direction: column;
            }
            
            .deck {
                flex: 1;
                min-height: 300px;
            }
            
            .deck.collapsed {
                flex: 0 0 60px;
            }
            
            .control-label {
                min-width: 50px;
                font-size: 11px;
            }
            
            .mode-btn {
                font-size: 10px;
                padding: 4px 6px;
            }
        }

        /* Tablet Layout */
        @media (min-width: 769px) and (max-width: 1024px) {
            .deck-container {
                flex-direction: row;
            }
            
            .deck {
                flex: 1;
            }
        }

        /* Desktop Layout */
        @media (min-width: 1025px) {
            .deck-container {
                flex-direction: row;
            }
            
            .deck {
                flex: 1;
            }
        }

        /* Animations */
        @keyframes pulse {
            0% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.5; transform: scale(1); }
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .animated-marker {
            animation: pulse 2s infinite;
        }

        .rotating {
            animation: rotate 3s linear infinite;
        }

        /* Gesture indicators */
        .gesture-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: var(--neon-green);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 14px;
            border: 2px solid var(--neon-green);
            display: none;
        }

        .gesture-indicator.show {
            display: block;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="app-title">RF DUAL-DECK</div>
            <div class="deck-controls">
                <div class="toggle-switch" id="detailToggle" title="High Detail Grid"></div>
                <div class="toggle-switch active" id="monitorToggle" title="Input Monitoring"></div>
                <div class="toggle-switch" id="gridToggle" title="Show Grid"></div>
            </div>
        </header>

        <div class="deck-container">
            <!-- Deck A: RF Sampler -->
            <div class="deck" id="deckA">
                <div class="deck-header" onclick="toggleDeck('A')">
                    <div class="deck-title">DECK A - RF SAMPLER</div>
                    <div class="deck-status" id="deckAStatus">FM 98.5MHz</div>
                </div>
                <div class="deck-content">
                    <canvas class="spectrum-display" id="spectrumCanvas"></canvas>
                    <canvas class="smith-canvas" id="smithCanvasA"></canvas>
                    <div class="control-panel">
                        <div class="control-row">
                            <div class="control-label">Mode</div>
                            <div class="mode-selector">
                                <button class="mode-btn" data-mode="am">AM</button>
                                <button class="mode-btn active" data-mode="fm">FM</button>
                                <button class="mode-btn" data-mode="ssb">SSB</button>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-label">Freq</div>
                            <div class="slider-container">
                                <input type="range" class="slider" id="freqSlider" min="88" max="108" value="98.5" step="0.1">
                                <span id="freqValue">98.5</span>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-label">Scan</div>
                            <button class="mode-btn" id="scanBtn">AUTO-SCAN</button>
                            <button class="mode-btn" id="presetBtn">PRESETS</button>
                        </div>
                    </div>
                    <div class="info-display" id="infoDisplayA">
                        <div class="info-item">Signal: <span id="signalStrength">-45</span> dBm</div>
                        <div class="info-item">SNR: <span id="snr">25</span> dB</div>
                        <div class="info-item">VSWR: <span id="vswrA">1.2</span>:1</div>
                    </div>
                    <div class="preset-container" id="presetContainerA">
                        <button class="preset-btn" data-preset="1">FM 88.1 - Jazz</button>
                        <button class="preset-btn" data-preset="2">FM 92.3 - Rock</button>
                        <button class="preset-btn" data-preset="3">FM 98.5 - Pop</button>
                        <button class="preset-btn" data-preset="4">AM 640 - News</button>
                    </div>
                </div>
            </div>

            <!-- Deck B: Signal Shaping -->
            <div class="deck b" id="deckB">
                <div class="deck-header" onclick="toggleDeck('B')">
                    <div class="deck-title">DECK B - SIGNAL SHAPING</div>
                    <div class="deck-status" id="deckBStatus">Synthesis Active</div>
                </div>
                <div class="deck-content">
                    <canvas class="smith-canvas" id="smithCanvasB"></canvas>
                    <div class="control-panel">
                        <div class="control-row">
                            <div class="control-label">Wave</div>
                            <div class="mode-selector">
                                <button class="mode-btn active" data-wave="sine">SINE</button>
                                <button class="mode-btn" data-wave="square">SQR</button>
                                <button class="mode-btn" data-wave="saw">SAW</button>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-label">Pitch</div>
                            <div class="slider-container">
                                <input type="range" class="slider" id="pitchSlider" min="200" max="2000" value="440">
                                <span id="pitchValue">440</span>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-label">Effects</div>
                            <div class="slider-container">
                                <input type="range" class="slider" id="effectSlider" min="0" max="100" value="30">
                                <span id="effectValue">30</span>
                            </div>
                        </div>
                    </div>
                    <div class="info-display" id="infoDisplayB">
                        <div class="info-item">Freq: <span id="currentFreq">440</span> Hz</div>
                        <div class="info-item">Q: <span id="filterQ">5.0</span></div>
                        <div class="info-item">Res: <span id="resonance">0.3</span></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="tooltip" id="tooltip"></div>
        <div class="gesture-indicator" id="gestureIndicator"></div>
    </div>

    <script>
        class RFDualDeckExplorer {
            constructor() {
                this.audioContext = null;
                this.isAudioEnabled = false;
                
                // Deck A - RF Sampler
                this.deckA = {
                    canvas: null,
                    ctx: null,
                    spectrumCanvas: null,
                    spectrumCtx: null,
                    frequency: 98.5,
                    mode: 'fm',
                    isScanning: false,
                    rfData: [],
                    markers: []
                };
                
                // Deck B - Signal Shaping
                this.deckB = {
                    canvas: null,
                    ctx: null,
                    oscillators: new Map(),
                    gainNodes: new Map(),
                    filterNodes: new Map(),
                    activePoints: new Map(),
                    waveform: 'sine',
                    pitch: 440,
                    effects: 30,
                    particles: []
                };
                
                // Touch handling
                this.touches = new Map();
                this.gestureStart = null;
                this.lastPinchDistance = 0;
                this.rotationAngle = 0;
                
                // UI state
                this.collapsedDecks = new Set();
                this.detailMode = false;
                this.monitoring = true;
                this.showGrid = true;
                
                this.init();
            }
            
            async init() {
                this.setupCanvas();
                this.setupEventListeners();
                await this.setupAudio();
                this.animate();
                this.generateRFData();
            }
            
            setupCanvas() {
                // Deck A canvases
                this.deckA.canvas = document.getElementById('smithCanvasA');
                this.deckA.ctx = this.deckA.canvas.getContext('2d');
                this.deckA.spectrumCanvas = document.getElementById('spectrumCanvas');
                this.deckA.spectrumCtx = this.deckA.spectrumCanvas.getContext('2d');
                
                // Deck B canvas
                this.deckB.canvas = document.getElementById('smithCanvasB');
                this.deckB.ctx = this.deckB.canvas.getContext('2d');
                
                this.resizeCanvases();
                window.addEventListener('resize', () => this.resizeCanvases());
            }
            
            resizeCanvases() {
                const deckAContent = document.querySelector('#deckA .deck-content');
                const deckBContent = document.querySelector('#deckB .deck-content');
                
                // Deck A
                if (this.deckA.spectrumCanvas) {
                    this.deckA.spectrumCanvas.width = this.deckA.spectrumCanvas.offsetWidth;
                    this.deckA.spectrumCanvas.height = 80;
                }
                if (this.deckA.canvas) {
                    this.deckA.canvas.width = deckAContent.offsetWidth;
                    this.deckA.canvas.height = deckAContent.offsetHeight - 80;
                }
                
                // Deck B
                if (this.deckB.canvas) {
                    this.deckB.canvas.width = deckBContent.offsetWidth;
                    this.deckB.canvas.height = deckBContent.offsetHeight;
                }
            }
            
            async setupAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Master gain for Deck B
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = 0.7;
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Effects chain
                    this.reverbNode = this.audioContext.createConvolver();
                    this.delayNode = this.audioContext.createDelay(1.0);
                    this.distortionNode = this.audioContext.createWaveShaper();
                    
                    this.setupEffects();
                    this.isAudioEnabled = true;
                } catch (error) {
                    console.error('Audio setup failed:', error);
                }
            }
            
            setupEffects() {
                // Create reverb impulse response
                const length = this.audioContext.sampleRate * 2;
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                
                this.reverbNode.buffer = impulse;
                
                // Distortion curve
                this.distortionNode.curve = this.makeDistortionCurve(10);
                
                // Connect effects
                this.delayNode.connect(this.reverbNode);
                this.reverbNode.connect(this.masterGain);
            }
            
            makeDistortionCurve(amount) {
                const samples = 44100;
                const curve = new Float32Array(samples);
                const deg = Math.PI / 180;
                
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
                }
                
                return curve;
            }
            
            setupEventListeners() {
                // Touch events for both decks
                this.setupTouchEvents('smithCanvasA', 'A');
                this.setupTouchEvents('smithCanvasB', 'B');
                
                // Control events
                this.setupControlEvents();
                
                // Toggle switches
                this.setupToggleEvents();
                
                // Preset events
                this.setupPresetEvents();
            }
            
            setupTouchEvents(canvasId, deck) {
                const canvas = document.getElementById(canvasId);
                
                // Touch events
                canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e, deck));
                canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e, deck));
                canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e, deck));
                
                // Mouse events (for desktop testing)
                canvas.addEventListener('mousedown', (e) => this.handleMouseStart(e, deck));
                canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e, deck));
                canvas.addEventListener('mouseup', (e) => this.handleMouseEnd(e, deck));
                
                // Prevent context menu
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            handleTouchStart(e, deck) {
                e.preventDefault();
                if (!this.isAudioEnabled) return;
                
                const rect = e.target.getBoundingClientRect();
                
                for (let touch of e.changedTouches) {
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const id = touch.identifier;
                    
                    this.touches.set(id, { x, y, deck, timestamp: Date.now() });
                    
                    if (deck === 'B') {
                        this.createSoundPoint(id, x, y);
                    }
                }
                
                this.detectGesture(e);
            }
            
            handleTouchMove(e, deck) {
                e.preventDefault();
                if (!this.isAudioEnabled) return;
                
                const rect = e.target.getBoundingClientRect();
                
                for (let touch of e.changedTouches) {
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const id = touch.identifier;
                    
                    const touchData = this.touches.get(id);
                    if (touchData) {
                        touchData.x = x;
                        touchData.y = y;
                        
                        if (deck === 'B') {
                            this.updateSoundPoint(id, x, y);
                        }
                    }
                }
                
                this.detectGesture(e);
            }
            
            handleTouchEnd(e, deck) {
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    const id = touch.identifier;
                    this.touches.delete(id);
                    
                    if (deck === 'B') {
                        this.removeSoundPoint(id);
                    }
                }
                
                this.gestureStart = null;
                this.hideGestureIndicator();
            }
            
            handleMouseStart(e, deck) {
                if (!this.isAudioEnabled) return;
                
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const id = 'mouse';
                
                this.touches.set(id, { x, y, deck, timestamp: Date.now() });
                
                if (deck === 'B') {
                    this.createSoundPoint(id, x, y);
                }
            }
            
            handleMouseMove(e, deck) {
                if (!this.isAudioEnabled) return;
                
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const id = 'mouse';
                
                const touchData = this.touches.get(id);
                if (touchData) {
                    touchData.x = x;
                    touchData.y = y;
                    
                    if (deck === 'B') {
                        this.updateSoundPoint(id, x, y);
                    }
                }
            }
            
            handleMouseEnd(e, deck) {
                const id = 'mouse';
                this.touches.delete(id);
                
                if (deck === 'B') {
                    this.removeSoundPoint(id);
                }
            }
            
            detectGesture(e) {
                const touches = Array.from(e.touches);
                if (touches.length === 2) {
                    const touch1 = touches[0];
                    const touch2 = touches[1];
                    
                    const distance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) +
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                    
                    const angle = Math.atan2(
                        touch2.clientY - touch1.clientY,
                        touch2.clientX - touch1.clientX
                    );
                    
                    if (!this.gestureStart) {
                        this.gestureStart = { distance, angle };
                        this.lastPinchDistance = distance;
                        this.rotationAngle = 0;
                    } else {
                        // Pinch zoom
                        const scale = distance / this.gestureStart.distance;
                        if (Math.abs(distance - this.lastPinchDistance) > 10) {
                            this.handlePinchZoom(scale);
                            this.lastPinchDistance = distance;
                        }
                        
                        // Rotation
                        const rotationDelta = angle - this.gestureStart.angle;
                        if (Math.abs(rotationDelta) > 0.1) {
                            this.handleRotation(rotationDelta);
                            this.gestureStart.angle = angle;
                        }
                    }
                }
            }
            
            handlePinchZoom(scale) {
                if (scale > 1.1) {
                    this.showGestureIndicator('🔍 Zoom In');
                } else if (scale < 0.9) {
                    this.showGestureIndicator('🔍 Zoom Out');
                }
            }
            
            handleRotation(angle) {
                this.rotationAngle += angle;
                this.showGestureIndicator(`🔄 Phase: ${Math.round(this.rotationAngle * 180 / Math.PI)}°`);
                
                // Apply phase shift to oscillators
                this.deckB.oscillators.forEach(osc => {
                    if (osc.frequency) {
                        osc.frequency.value *= (1 + angle * 0.01);
                    }
                });
            }
            
            showGestureIndicator(text) {
                const indicator = document.getElementById('gestureIndicator');
                indicator.textContent = text;
                indicator.classList.add('show');
                
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 1000);
            }
            
            hideGestureIndicator() {
                document.getElementById('gestureIndicator').classList.remove('show');
            }
            
            createSoundPoint(id, x, y) {
                const canvas = this.deckB.canvas;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) * 0.35;
                
                const dx = (x - centerX) / radius;
                const dy = (y - centerY) / radius;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= 1.0) {
                    const point = {
                        id,
                        x,
                        y,
                        dx,
                        dy,
                        distance,
                        frequency: this.calculateFrequency(dx, dy),
                        amplitude: this.calculateAmplitude(distance),
                        qFactor: this.calculateQFactor(dx),
                        resonance: this.calculateResonance(dy),
                        phase: Math.atan2(dy, dx)
                    };
                    
                    this.deckB.activePoints.set(id, point);
                    this.createOscillator(id, point);
                    this.createParticle(point);
                }
            }
            
            updateSoundPoint(id, x, y) {
                const point = this.deckB.activePoints.get(id);
                if (!point) return;
                
                const canvas = this.deckB.canvas;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) * 0.35;
                
                const dx = (x - centerX) / radius;
                const dy = (y - centerY) / radius;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= 1.0) {
                    point.x = x;
                    point.y = y;
                    point.dx = dx;
                    point.dy = dy;
                    point.distance = distance;
                    point.frequency = this.calculateFrequency(dx, dy);
                    point.amplitude = this.calculateAmplitude(distance);
                    point.qFactor = this.calculateQFactor(dx);
                    point.resonance = this.calculateResonance(dy);
                    point.phase = Math.atan2(dy, dx);
                    
                    this.updateOscillator(id, point);
                    this.updateDeckBInfo(point);
                }
            }
            
            removeSoundPoint(id) {
                if (this.deckB.activePoints.has(id)) {
                    this.deckB.activePoints.delete(id);
                    this.stopOscillator(id);
                }
            }
            
            calculateFrequency(dx, dy) {
                // Map Smith chart position to frequency
                const baseFreq = parseFloat(document.getElementById('pitchSlider').value);
                const range = 1000;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return baseFreq + (distance * range * Math.sign(dy));
            }
            
            calculateAmplitude(distance) {
                return Math.max(0.1, 1.0 - distance);
            }
            
            calculateQFactor(dx) {
                return Math.abs(dx) * 20 + 0.1;
            }
            
            calculateResonance(dy) {
                return Math.abs(dy);
            }
            
            createOscillator(id, point) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filterNode = this.audioContext.createBiquadFilter();
                const effectGain = this.audioContext.createGain();
                
                oscillator.type = this.deckB.waveform;
                oscillator.frequency.value = point.frequency;
                
                filterNode.type = 'bandpass';
                filterNode.frequency.value = point.frequency * 2;
                filterNode.Q.value = point.qFactor;
                
                gainNode.gain.value = point.amplitude * 0.3;
                effectGain.gain.value = this.deckB.effects / 100;
                
                oscillator.connect(filterNode);
                filterNode.connect(gainNode);
                gainNode.connect(this.masterGain);
                gainNode.connect(effectGain);
                effectGain.connect(this.distortionNode);
                effectGain.connect(this.delayNode);
                
                oscillator.start();
                
                this.deckB.oscillators.set(id, oscillator);
                this.deckB.gainNodes.set(id, gainNode);
                this.deckB.filterNodes.set(id, filterNode);
            }
            
            updateOscillator(id, point) {
                const oscillator = this.deckB.oscillators.get(id);
                const gainNode = this.deckB.gainNodes.get(id);
                const filterNode = this.deckB.filterNodes.get(id);
                
                if (oscillator) {
                    oscillator.frequency.setTargetAtTime(point.frequency, this.audioContext.currentTime, 0.01);
                }
                if (gainNode) {
                    gainNode.gain.setTargetAtTime(point.amplitude * 0.3, this.audioContext.currentTime, 0.01);
                }
                if (filterNode) {
                    filterNode.frequency.setTargetAtTime(point.frequency * 2, this.audioContext.currentTime, 0.01);
                }
            }
            
            createParticle(point) {
                this.deckB.particles.push({
                    x: point.x,
                    y: point.y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 1.0,
                    decay: 0.03,
                    color: `hsl(${120 + point.frequency * 0.2}, 70%, 50%)`,
                    size: Math.random() * 4 + 2
                });
            }
            
            updateParticles() {
                this.deckB.particles = this.deckB.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life -= particle.decay;
                    return particle.life > 0;
                });
            }
            
            setupControlEvents() {
                // Deck A controls
                document.getElementById('freqSlider').addEventListener('input', (e) => {
                    this.deckA.frequency = parseFloat(e.target.value);
                    document.getElementById('freqValue').textContent = e.target.value;
                    document.getElementById('deckAStatus').textContent = `FM ${e.target.value}MHz`;
                });
                
                document.getElementById('scanBtn').addEventListener('click', () => {
                    this.toggleScan();
                });
                
                document.getElementById('presetBtn').addEventListener('click', () => {
                    document.getElementById('presetContainerA').classList.toggle('show');
                });
                
                // Deck B controls
                document.getElementById('pitchSlider').addEventListener('input', (e) => {
                    this.deckB.pitch = parseFloat(e.target.value);
                    document.getElementById('pitchValue').textContent = e.target.value;
                    document.getElementById('currentFreq').textContent = e.target.value;
                });
                
                document.getElementById('effectSlider').addEventListener('input', (e) => {
                    this.deckB.effects = parseFloat(e.target.value);
                    document.getElementById('effectValue').textContent = e.target.value;
                });
                
                // Mode buttons
                document.querySelectorAll('.mode-btn[data-mode]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.mode-btn[data-mode]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.deckA.mode = e.target.dataset.mode;
                    });
                });
                
                document.querySelectorAll('.mode-btn[data-wave]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.mode-btn[data-wave]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.deckB.waveform = e.target.dataset.wave;
                        this.updateAllOscillators();
                    });
                });
            }
            
            setupToggleEvents() {
                document.getElementById('detailToggle').addEventListener('click', (e) => {
                    e.target.classList.toggle('active');
                    this.detailMode = e.target.classList.contains('active');
                });
                
                document.getElementById('monitorToggle').addEventListener('click', (e) => {
                    e.target.classList.toggle('active');
                    this.monitoring = e.target.classList.contains('active');
                });
                
                document.getElementById('gridToggle').addEventListener('click', (e) => {
                    e.target.classList.toggle('active');
                    this.showGrid = e.target.classList.contains('active');
                });
            }
            
            setupPresetEvents() {
                document.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const preset = e.target.dataset.preset;
                        this.loadPreset(preset);
                        document.getElementById('presetContainerA').classList.remove('show');
                    });
                });
            }
            
            updateAllOscillators() {
                this.deckB.oscillators.forEach(oscillator => {
                    oscillator.type = this.deckB.waveform;
                });
            }
            
            updateDeckBInfo(point) {
                document.getElementById('currentFreq').textContent = Math.round(point.frequency);
                document.getElementById('filterQ').textContent = point.qFactor.toFixed(1);
                document.getElementById('resonance').textContent = point.resonance.toFixed(2);
            }
            
            toggleScan() {
                this.deckA.isScanning = !this.deckA.isScanning;
                const btn = document.getElementById('scanBtn');
                btn.textContent = this.deckA.isScanning ? 'STOP' : 'AUTO-SCAN';
                btn.classList.toggle('active');
                
                if (this.deckA.isScanning) {
                    this.startScanning();
                }
            }
            
            startScanning() {
                let freq = 88;
                const scanInterval = setInterval(() => {
                    if (!this.deckA.isScanning) {
                        clearInterval(scanInterval);
                        return;
                    }
                    
                    freq += 0.5;
                    if (freq > 108) freq = 88;
                    
                    document.getElementById('freqSlider').value = freq;
                    document.getElementById('freqValue').textContent = freq.toFixed(1);
                    document.getElementById('deckAStatus').textContent = `FM ${freq.toFixed(1)}MHz`;
                    this.deckA.frequency = freq;
                }, 100);
            }
            
            loadPreset(preset) {
                const presets = {
                    '1': { freq: 88.1, mode: 'fm', name: 'Jazz' },
                    '2': { freq: 92.3, mode: 'fm', name: 'Rock' },
                    '3': { freq: 98.5, mode: 'fm', name: 'Pop' },
                    '4': { freq: 640, mode: 'am', name: 'News' }
                };
                
                const config = presets[preset];
                if (config) {
                    document.getElementById('freqSlider').value = config.freq;
                    document.getElementById('freqValue').textContent = config.freq;
                    document.getElementById('deckAStatus').textContent = `${config.mode.toUpperCase()} ${config.freq}${config.mode === 'am' ? 'kHz' : 'MHz'}`;
                    this.deckA.frequency = config.freq;
                    this.deckA.mode = config.mode;
                    
                    // Update mode buttons
                    document.querySelectorAll('.mode-btn[data-mode]').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.mode === config.mode);
                    });
                }
            }
            
            generateRFData() {
                // Generate realistic RF spectrum data
                for (let i = 0; i < 256; i++) {
                    const freq = 88 + (i / 256) * 20;
                    let amplitude = Math.random() * 0.3;
                    
                    // Add some peaks for realistic spectrum
                    if (Math.abs(freq - this.deckA.frequency) < 0.5) {
                        amplitude = 0.8 + Math.random() * 0.2;
                    }
                    
                    // Add noise floor
                    amplitude += Math.random() * 0.1;
                    
                    this.deckA.rfData[i] = amplitude;
                }
            }
            
            drawSmithChart(ctx, centerX, centerY, radius, isDeckB = false) {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                
                // Background grid
                if (this.showGrid) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    
                    for (let i = 0; i < ctx.canvas.width; i += 20) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, ctx.canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let i = 0; i < ctx.canvas.height; i += 20) {
                        ctx.beginPath();
                        ctx.moveTo(0, i);
                        ctx.lineTo(ctx.canvas.width, i);
                        ctx.stroke();
                    }
                }
                
                // Smith chart circles
                ctx.strokeStyle = isDeckB ? 'rgba(204, 0, 255, 0.6)' : 'rgba(0, 204, 255, 0.6)';
                ctx.lineWidth = this.detailMode ? 2 : 1;
                
                // Outer circle
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Resistance circles
                const resistances = this.detailMode ? [0, 0.2, 0.5, 1, 2, 5] : [0, 1];
                resistances.forEach(r => {
                    if (r === 0) {
                        ctx.beginPath();
                        ctx.moveTo(centerX - radius, centerY);
                        ctx.lineTo(centerX + radius, centerY);
                        ctx.stroke();
                    } else {
                        const circleRadius = radius / (1 + r);
                        const circleCenterX = centerX + (r * radius) / (1 + r);
                        
                        ctx.beginPath();
                        ctx.arc(circleCenterX, centerY, circleRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                });
                
                // Reactance arcs
                const reactances = this.detailMode ? [-3, -2, -1, -0.5, 0.5, 1, 2, 3] : [-1, 1];
                reactances.forEach(x => {
                    const circleRadius = radius / Math.abs(x);
                    const circleCenterY = centerY + (radius / x);
                    
                    const startAngle = x > 0 ? Math.PI : 0;
                    const endAngle = x > 0 ? 2 * Math.PI : Math.PI;
                    
                    ctx.beginPath();
                    ctx.arc(centerX, circleCenterY, circleRadius, startAngle, endAngle);
                    ctx.stroke();
                });
                
                // VSWR circles
                ctx.strokeStyle = 'rgba(255, 102, 0, 0.4)';
                const vswrValues = this.detailMode ? [1.5, 2, 3, 5, 10] : [2, 5];
                vswrValues.forEach(vswr => {
                    const reflection = (vswr - 1) / (vswr + 1);
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius * reflection, 0, Math.PI * 2);
                    ctx.stroke();
                });
                
                // Center point
                ctx.fillStyle = isDeckB ? 'rgba(204, 0, 255, 0.8)' : 'rgba(0, 204, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawSpectrum() {
                const ctx = this.deckA.spectrumCtx;
                const canvas = this.deckA.spectrumCanvas;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw spectrum
                ctx.strokeStyle = 'rgba(0, 255, 136, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < this.deckA.rfData.length; i++) {
                    const x = (i / this.deckA.rfData.length) * canvas.width;
                    const y = canvas.height - (this.deckA.rfData[i] * canvas.height * 0.8);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // Draw frequency marker
                const markerX = ((this.deckA.frequency - 88) / 20) * canvas.width;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(markerX, 0);
                ctx.lineTo(markerX, canvas.height);
                ctx.stroke();
                
                // Update signal strength
                const freqIndex = Math.floor(((this.deckA.frequency - 88) / 20) * this.deckA.rfData.length);
                const signalStrength = -60 + (this.deckA.rfData[freqIndex] || 0) * 40;
                document.getElementById('signalStrength').textContent = Math.round(signalStrength);
                
                // Simulate SNR
                const snr = 15 + (this.deckA.rfData[freqIndex] || 0) * 20;
                document.getElementById('snr').textContent = Math.round(snr);
                
                // Simulate VSWR
                const vswr = 1 + (1 - (this.deckA.rfData[freqIndex] || 0)) * 2;
                document.getElementById('vswrA').textContent = vswr.toFixed(1);
            }
            
            drawActivePoints(ctx, centerX, centerY) {
                this.deckB.activePoints.forEach((point, id) => {
                    // Draw connection line
                    ctx.strokeStyle = 'rgba(204, 0, 255, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(point.x, point.y);
                    ctx.stroke();
                    
                    // Draw point
                    ctx.fillStyle = 'rgba(204, 0, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(204, 0, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Draw VSWR circle for this point
                    ctx.strokeStyle = 'rgba(255, 102, 0, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, point.distance * Math.min(ctx.canvas.width, ctx.canvas.height) * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                });
            }
            
            drawParticles(ctx) {
                this.deckB.particles.forEach(particle => {
                    ctx.fillStyle = particle.color;
                    ctx.globalAlpha = particle.life;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                });
            }
            
            animate() {
                // Update RF data
                this.generateRFData();
                
                // Draw Deck A
                if (this.deckA.canvas && this.deckA.spectrumCanvas) {
                    this.drawSpectrum();
                    const centerXA = this.deckA.canvas.width / 2;
                    const centerYA = this.deckA.canvas.height / 2;
                    const radiusA = Math.min(this.deckA.canvas.width, this.deckA.canvas.height) * 0.35;
                    this.drawSmithChart(this.deckA.ctx, centerXA, centerYA, radiusA, false);
                }
                
                // Draw Deck B
                if (this.deckB.canvas) {
                    const centerXB = this.deckB.canvas.width / 2;
                    const centerYB = this.deckB.canvas.height / 2;
                    const radiusB = Math.min(this.deckB.canvas.width, this.deckB.canvas.height) * 0.35;
                    this.drawSmithChart(this.deckB.ctx, centerXB, centerYB, radiusB, true);
                    this.drawActivePoints(this.deckB.ctx, centerXB, centerYB);
                    this.updateParticles();
                    this.drawParticles(this.deckB.ctx);
                }
                
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Global functions
        function toggleDeck(deckId) {
            const deck = document.getElementById(`deck${deckId}`);
            deck.classList.toggle('collapsed');
            
            // Resize canvases after animation
            setTimeout(() => {
                window.dispatchEvent(new Event('resize'));
            }, 300);
        }
        
        // Initialize app
        window.addEventListener('load', () => {
            const app = new RFDualDeckExplorer();
            
            // Enable audio on first interaction
            document.addEventListener('click', () => {
                if (app.audioContext && app.audioContext.state === 'suspended') {
                    app.audioContext.resume();
                }
            }, { once: true });
        });
        
        // Handle orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                window.dispatchEvent(new Event('resize'));
            }, 300);
        });
    </script>
    </body>
    </html>
    <!-- duplicate removed
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="app-title">RF DUAL-DECK</div>
            <div class="deck-controls">
                <div class="toggle-switch" id="detailToggle" title="High Detail Grid"></div>
                <div class="toggle-switch active" id="monitorToggle" title="Input Monitoring"></div>
                <div class="toggle-switch" id="gridToggle" title="Show Grid"></div>
            </div>
        </header>

        <div class="deck-container">
            <!-- Deck A: RF Sampler -->
            <div class="deck" id="deckA">
                <div class="deck-header" onclick="toggleDeck('A')">
                    <div class="deck-title">DECK A - RF SAMPLER</div>
                    <div class="deck-status" id="deckAStatus">FM 98.5MHz</div>
                </div>
                <div class="deck-content">
                    <canvas class="spectrum-display" id="spectrumCanvas"></canvas>
                    <canvas class="smith-canvas" id="smithCanvasA"></canvas>
                    <div class="control-panel">
                        <div class="control-row">
                            <div class="control-label">Mode</div>
                            <div class="mode-selector">
                                <button class="mode-btn" data-mode="am">AM</button>
                                <button class="mode-btn active" data-mode="fm">FM</button>
                                <button class="mode-btn" data-mode="ssb">SSB</button>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-label">Freq</div>
                            <div class="slider-container">
                                <input type="range" class="slider" id="freqSlider" min="88" max="108" value="98.5" step="0.1">
                                <span id="freqValue">98.5</span>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-label">Scan</div>
                            <button class="mode-btn" id="scanBtn">AUTO-SCAN</button>
                            <button class="mode-btn" id="presetBtn">PRESETS</button>
                        </div>
                    </div>
                    <div class="info-display" id="infoDisplayA">
                        <div class="info-item">Signal: <span id="signalStrength">-45</span> dBm</div>
                        <div class="info-item">SNR: <span id="snr">25</span> dB</div>
                        <div class="info-item">VSWR: <span id="vswrA">1.2</span>:1</div>
                    </div>
                    <div class="preset-container" id="presetContainerA">
                        <button class="preset-btn" data-preset="1">FM 88.1 - Jazz</button>
                        <button class="preset-btn" data-preset="2">FM 92.3 - Rock</button>
                        <button class="preset-btn" data-preset="3">FM 98.5 - Pop</button>
                        <button class="preset-btn" data-preset="4">AM 640 - News</button>
                    </div>
                </div>
            </div>

            <!-- Deck B: Signal Shaping -->
            <div class="deck b" id="deckB">
                <div class="deck-header" onclick="toggleDeck('B')">
                    <div class="deck-title">DECK B - SIGNAL SHAPING</div>
                    <div class="deck-status" id="deckBStatus">Synthesis Active</div>
                </div>
                <div class="deck-content">
                    <canvas class="smith-canvas" id="smithCanvasB"></canvas>
                    <div class="control-panel">
                        <div class="control-row">
                            <div class="control-label">Wave</div>
                            <div class="mode-selector">
                                <button class="mode-btn active" data-wave="sine">SINE</button>
                                <button class="mode-btn" data-wave="square">SQR</button>
                                <button class="mode-btn" data-wave="saw">SAW</button>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-label">Pitch</div>
                            <div class="slider-container">
                                <input type="range" class="slider" id="pitchSlider" min="200" max="2000" value="440">
                                <span id="pitchValue">440</span>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-label">Effects</div>
                            <div class="slider-container">
                                <input type="range" class="slider" id="effectSlider" min="0" max="100" value="30">
                                <span id="effectValue">30</span>
                            </div>
                        </div>
                    </div>
                    <div class="info-display" id="infoDisplayB">
                        <div class="info-item">Freq: <span id="currentFreq">440</span> Hz</div>
                        <div class="info-item">Q: <span id="filterQ">5.0</span></div>
                        <div class="info-item">Res: <span id="resonance">0.3</span></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="tooltip" id="tooltip"></div>
        <div class="gesture-indicator" id="gestureIndicator"></div>
    </div>

    <script>
        class RFDualDeckExplorer {
            constructor() {
                this.audioContext = null;
                this.isAudioEnabled = false;
                
                // Deck A - RF Sampler
                this.deckA = {
                    canvas: null,
                    ctx: null,
                    spectrumCanvas: null,
                    spectrumCtx: null,
                    frequency: 98.5,
                    mode: 'fm',
                    isScanning: false,
                    rfData: [],
                    markers: []
                };
                
                // Deck B - Signal Shaping
                this.deckB = {
                    canvas: null,
                    ctx: null,
                    oscillators: new Map(),
                    gainNodes: new Map(),
                    filterNodes: new Map(),
                    activePoints: new Map(),
                    waveform: 'sine',
                    pitch: 440,
                    effects: 30,
                    particles: []
                };
                
                // Touch handling
                this.touches = new Map();
                this.gestureStart = null;
                this.lastPinchDistance = 0;
                this.rotationAngle = 0;
                
                // UI state
                this.collapsedDecks = new Set();
                this.detailMode = false;
                this.monitoring = true;
                this.showGrid = true;
                
                this.init();
            }
            
            async init() {
                this.setupCanvas();
                this.setupEventListeners();
                await this.setupAudio();
                this.animate();
                this.generateRFData();
            }
            
            setupCanvas() {
                // Deck A canvases
                this.deckA.canvas = document.getElementById('smithCanvasA');
                this.deckA.ctx = this.deckA.canvas.getContext('2d');
                this.deckA.spectrumCanvas = document.getElementById('spectrumCanvas');
                this.deckA.spectrumCtx = this.deckA.spectrumCanvas.getContext('2d');
                
                // Deck B canvas
                this.deckB.canvas = document.getElementById('smithCanvasB');
                this.deckB.ctx = this.deckB.canvas.getContext('2d');
                
                this.resizeCanvases();
                window.addEventListener('resize', () => this.resizeCanvases());
            }
            
            resizeCanvases() {
                const deckAContent = document.querySelector('#deckA .deck-content');
                const deckBContent = document.querySelector('#deckB .deck-content');
                
                // Deck A
                if (this.deckA.spectrumCanvas) {
                    this.deckA.spectrumCanvas.width = this.deckA.spectrumCanvas.offsetWidth;
                    this.deckA.spectrumCanvas.height = 80;
                }
                if (this.deckA.canvas) {
                    this.deckA.canvas.width = deckAContent.offsetWidth;
                    this.deckA.canvas.height = deckAContent.offsetHeight - 80;
                }
                
                // Deck B
                if (this.deckB.canvas) {
                    this.deckB.canvas.width = deckBContent.offsetWidth;
                    this.deckB.canvas.height = deckBContent.offsetHeight;
                }
            }
            
            async setupAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Master gain for Deck B
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = 0.7;
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Effects chain
                    this.reverbNode = this.audioContext.createConvolver();
                    this.delayNode = this.audioContext.createDelay(1.0);
                    this.distortionNode = this.audioContext.createWaveShaper();
                    
                    this.setupEffects();
                    this.isAudioEnabled = true;
                } catch (error) {
                    console.error('Audio setup failed:', error);
                }
            }
            
            setupEffects() {
                // Create reverb impulse response
                const length = this.audioContext.sampleRate * 2;
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                
                this.reverbNode.buffer = impulse;
                
                // Distortion curve
                this.distortionNode.curve = this.makeDistortionCurve(10);
                
                // Connect effects
                this.delayNode.connect(this.reverbNode);
                this.reverbNode.connect(this.masterGain);
            }
            
            makeDistortionCurve(amount) {
                const samples = 44100;
                const curve = new Float32Array(samples);
                const deg = Math.PI / 180;
                
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
                }
                
                return curve;
            }
            
            setupEventListeners() {
                // Touch events for both decks
                this.setupTouchEvents('smithCanvasA', 'A');
                this.setupTouchEvents('smithCanvasB', 'B');
                
                // Control events
                this.setupControlEvents();
                
                // Toggle switches
                this.setupToggleEvents();
                
                // Preset events
                this.setupPresetEvents();
            }
            
            setupTouchEvents(canvasId, deck) {
                const canvas = document.getElementById(canvasId);
                
                // Touch events
                canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e, deck));
                canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e, deck));
                canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e, deck));
                
                // Mouse events (for desktop testing)
                canvas.addEventListener('mousedown', (e) => this.handleMouseStart(e, deck));
                canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e, deck));
                canvas.addEventListener('mouseup', (e) => this.handleMouseEnd(e, deck));
                
                // Prevent context menu
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            handleTouchStart(e, deck) {
                e.preventDefault();
                if (!this.isAudioEnabled) return;
                
                const rect = e.target.getBoundingClientRect();
                
                for (let touch of e.changedTouches) {
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const id = touch.identifier;
                    
                    this.touches.set(id, { x, y, deck, timestamp: Date.now() });
                    
                    if (deck === 'B') {
                        this.createSoundPoint(id, x, y);
                    }
                }
                
                this.detectGesture(e);
            }
            
            handleTouchMove(e, deck) {
                e.preventDefault();
                if (!this.isAudioEnabled) return;
                
                const rect = e.target.getBoundingClientRect();
                
                for (let touch of e.changedTouches) {
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const id = touch.identifier;
                    
                    const touchData = this.touches.get(id);
                    if (touchData) {
                        touchData.x = x;
                        touchData.y = y;
                        
                        if (deck === 'B') {
                            this.updateSoundPoint(id, x, y);
                        }
                    }
                }
                
                this.detectGesture(e);
            }
            
            handleTouchEnd(e, deck) {
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    const id = touch.identifier;
                    this.touches.delete(id);
                    
                    if (deck === 'B') {
                        this.removeSoundPoint(id);
                    }
                }
                
                this.gestureStart = null;
                this.hideGestureIndicator();
            }
            
            handleMouseStart(e, deck) {
                if (!this.isAudioEnabled) return;
                
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const id = 'mouse';
                
                this.touches.set(id, { x, y, deck, timestamp: Date.now() });
                
                if (deck === 'B') {
                    this.createSoundPoint(id, x, y);
                }
            }
            
            handleMouseMove(e, deck) {
                if (!this.isAudioEnabled) return;
                
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const id = 'mouse';
                
                const touchData = this.touches.get(id);
                if (touchData) {
                    touchData.x = x;
                    touchData.y = y;
                    
                    if (deck === 'B') {
                        this.updateSoundPoint(id, x, y);
                    }
                }
            }
            
            handleMouseEnd(e, deck) {
                const id = 'mouse';
                this.touches.delete(id);
                
                if (deck === 'B') {
                    this.removeSoundPoint(id);
                }
            }
            
            detectGesture(e) {
                const touches = Array.from(e.touches);
                if (touches.length === 2) {
                    const touch1 = touches[0];
                    const touch2 = touches[1];
                    
                    const distance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) +
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                    
                    const angle = Math.atan2(
                        touch2.clientY - touch1.clientY,
                        touch2.clientX - touch1.clientX
                    );
                    
                    if (!this.gestureStart) {
                        this.gestureStart = { distance, angle };
                        this.lastPinchDistance = distance;
                        this.rotationAngle = 0;
                    } else {
                        // Pinch zoom
                        const scale = distance / this.gestureStart.distance;
                        if (Math.abs(distance - this.lastPinchDistance) > 10) {
                            this.handlePinchZoom(scale);
                            this.lastPinchDistance = distance;
                        }
                        
                        // Rotation
                        const rotationDelta = angle - this.gestureStart.angle;
                        if (Math.abs(rotationDelta) > 0.1) {
                            this.handleRotation(rotationDelta);
                            this.gestureStart.angle = angle;
                        }
                    }
                }
            }
            
            handlePinchZoom(scale) {
                if (scale > 1.1) {
                    this.showGestureIndicator('🔍 Zoom In');
                } else if (scale < 0.9) {
                    this.showGestureIndicator('🔍 Zoom Out');
                }
            }
            
            handleRotation(angle) {
                this.rotationAngle += angle;
                this.showGestureIndicator(`🔄 Phase: ${Math.round(this.rotationAngle * 180 / Math.PI)}°`);
                
                // Apply phase shift to oscillators
                this.deckB.oscillators.forEach(osc => {
                    if (osc.frequency) {
                        osc.frequency.value *= (1 + angle * 0.01);
                    }
                });
            }
            
            showGestureIndicator(text) {
                const indicator = document.getElementById('gestureIndicator');
                indicator.textContent = text;
                indicator.classList.add('show');
                
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 1000);
            }
            
            hideGestureIndicator() {
                document.getElementById('gestureIndicator').classList.remove('show');
            }
            
            createSoundPoint(id, x, y) {
                const canvas = this.deckB.canvas;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) * 0.35;
                
                const dx = (x - centerX) / radius;
                const dy = (y - centerY) / radius;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= 1.0) {
                    const point = {
                        id,
                        x,
                        y,
                        dx,
                        dy,
                        distance,
                        frequency: this.calculateFrequency(dx, dy),
                        amplitude: this.calculateAmplitude(distance),
                        qFactor: this.calculateQFactor(dx),
                        resonance: this.calculateResonance(dy),
                        phase: Math.atan2(dy, dx)
                    };
                    
                    this.deckB.activePoints.set(id, point);
                    this.createOscillator(id, point);
                    this.createParticle(point);
                }
            }
            
            updateSoundPoint(id, x, y) {
                const point = this.deckB.activePoints.get(id);
                if (!point) return;
                
                const canvas = this.deckB.canvas;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) * 0.35;
                
                const dx = (x - centerX) / radius;
                const dy = (y - centerY) / radius;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= 1.0) {
                    point.x = x;
                    point.y = y;
                    point.dx = dx;
                    point.dy = dy;
                    point.distance = distance;
                    point.frequency = this.calculateFrequency(dx, dy);
                    point.amplitude = this.calculateAmplitude(distance);
                    point.qFactor = this.calculateQFactor(dx);
                    point.resonance = this.calculateResonance(dy);
                    point.phase = Math.atan2(dy, dx);
                    
                    this.updateOscillator(id, point);
                    this.updateDeckBInfo(point);
                }
            }
            
            removeSoundPoint(id) {
                if (this.deckB.activePoints.has(id)) {
                    this.deckB.activePoints.delete(id);
                    this.stopOscillator(id);
                }
            }
            
            calculateFrequency(dx, dy) {
                // Map Smith chart position to frequency
                const baseFreq = parseFloat(document.getElementById('pitchSlider').value);
                const range = 1000;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return baseFreq + (distance * range * Math.sign(dy));
            }
            
            calculateAmplitude(distance) {
                return Math.max(0.1, 1.0 - distance);
            }
            
            calculateQFactor(dx) {
                return Math.abs(dx) * 20 + 0.1;
            }
            
            calculateResonance(dy) {
                return Math.abs(dy);
            }
            
            createOscillator(id, point) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filterNode = this.audioContext.createBiquadFilter();
                const effectGain = this.audioContext.createGain();
                
                oscillator.type = this.deckB.waveform;
                oscillator.frequency.value = point.frequency;
                
                filterNode.type = 'bandpass';
                filterNode.frequency.value = point.frequency * 2;
                filterNode.Q.value = point.qFactor;
                
                gainNode.gain.value = point.amplitude * 0.3;
                effectGain.gain.value = this.deckB.effects / 100;
                
                oscillator.connect(filterNode);
                filterNode.connect(gainNode);
                gainNode.connect(this.masterGain);
                gainNode.connect(effectGain);
                effectGain.connect(this.distortionNode);
                effectGain.connect(this.delayNode);
                
                oscillator.start();
                
                this.deckB.oscillators.set(id, oscillator);
                this.deckB.gainNodes.set(id, gainNode);
                this.deckB.filterNodes.set(id, filterNode);
            }
            
            updateOscillator(id, point) {
                const oscillator = this.deckB.oscillators.get(id);
                const gainNode = this.deckB.gainNodes.get(id);
                const filterNode = this.deckB.filterNodes.get(id);
                
                if (oscillator) {
                    oscillator.frequency.setTargetAtTime(point.frequency, this.audioContext.currentTime, 0.01);
                }
                if (gainNode) {
                    gainNode.gain.setTargetAtTime(point.amplitude * 0.3, this.audioContext.currentTime, 0.01);
                }
                if (filterNode) {
                    filterNode.frequency.setTargetAtTime(point.frequency * 2, this.audioContext.currentTime, 0.01);
                    filterNode.Q.setTargetAtTime(point.qFactor, this.audioContext.currentTime, 0.01);
                }
            }
            
            stopOscillator(id) {
                const oscillator = this.deckB.oscillators.get(id) -->