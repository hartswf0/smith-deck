<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Smith Chart — Musical Interface</title>
<style>
  :root{
    --bg:#0b0c0f; --panel:#0f1115; --ink:#e6e6e6; --muted:#9aa4ad; --accent:#6ee7ff; --accent2:#a7f3d0; --grid:#263241; --grid2:#334155; --good:#34d399; --bad:#f87171; --warn:#fbbf24;
    --neon-blue: #00e5ff; /* Equivalent to --accent */
    --neon-green: #00ff99; /* Equivalent to --accent2 */
    --neon-red: #ff3366;
    --neon-purple: #cc33ff;

    --shadow:0 10px 30px rgba(0,0,0,.35);
  }

  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";}
  #app{position:fixed; inset:0; display:grid; grid-template-rows: 1fr auto;}
  canvas{display:block; width:100%; height:100%; touch-action:none;}

  .hud{position:absolute; top:12px; left:12px; right:12px; display:flex; gap:8px; flex-wrap:wrap; pointer-events:none}
  .pill{pointer-events:auto; background:rgba(15,17,21,.75); backdrop-filter: blur(8px); border:1px solid rgba(255,255,255,.06); border-radius:999px; padding:8px 12px; display:flex; align-items:center; gap:10px; box-shadow:var(--shadow)}
  .badge{font-variant-numeric: tabular-nums; font-size:12px; color:var(--muted)}
  .dot{width:10px; height:10px; border-radius:50%}

  .panel{background:linear-gradient(180deg, rgba(16,18,23,.9), rgba(16,18,23,.9)); border-top:1px solid rgba(255,255,255,.06); box-shadow: var(--shadow);}
  .controls{display:grid; grid-template-columns:repeat(12,1fr); gap:10px; padding:12px; max-width:1200px; margin-inline:auto;}
  .controls label{font-size:12px; color:var(--muted)}
  .controls input[type="number"], .controls input[type="text"], .controls select, .controls button {width:100%; background:#0c0e13; color:var(--ink); border:1px solid #1f2937; border-radius:10px; padding:8px 10px; font-variant-numeric: tabular-nums;}
  .controls input[type="range"]{width:100%}
  .row{display:flex; flex-direction:column; gap:6px}
  .sp12{grid-column: span 12}
  .sp6{grid-column: span 6}
  .sp4{grid-column: span 4}
  .sp3{grid-column: span 3}
  .sp2{grid-column: span 2}
  .btn{cursor:pointer; user-select:none; background:#0c0e13; color:var(--ink); border:1px solid #1f2937; border-radius:12px; padding:10px 12px; display:flex; align-items:center; justify-content:center}
  .btn:active{transform:translateY(1px)}
  .btn.primary{background:#0f172a; border-color:#233042}
  .toggle{display:flex; align-items:center; gap:8px}
  .toggle input{accent-color:#67e8f9}
  .muted{color:var(--muted)}
  .link{color:var(--accent); text-decoration:underline; cursor:pointer}
  .help{position:absolute; right:12px; bottom:90px; background:rgba(15,17,21,.9); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:12px; width:min(420px, calc(100vw - 24px)); box-shadow: var(--shadow); font-size:13px; line-height:1.35; display:none}
  .help.show{display:block}

  /* --- General Pill Button Styling --- */
  .pill-btn {
    cursor: pointer;
    user-select: none;
    background: #0c0e13;
    color: var(--ink);
    border: 1px solid #1f2937;
    border-radius: 12px;
    padding: 10px 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background .15s ease, box-shadow .15s ease, transform .05s ease, color .15s ease, border-color .15s ease;
  }
  .pill-btn:hover {
    box-shadow: 0 0 8px rgba(110, 231, 255, 0.3); /* Default hover glow */
  }
  .pill-btn:active {
    transform: translateY(1px);
  }

  /* Listen Pills & Other Action Buttons Specific Styles */
  #listenBar {
      grid-column: span 12;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      padding: 8px 0;
      border-top: 1px solid rgba(255,255,255,.03);
  }
  #actionButtons {
      grid-column: span 12;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      padding: 8px 0;
      border-top: 1px solid rgba(255,255,255,.03);
  }

  /* Individual Active States for Buttons (consistent with chart colors) */
  #listenMix.active {
      background: var(--neon-blue);
      color: var(--bg);
      border-color: var(--neon-blue);
      box-shadow: 0 0 15px var(--neon-blue);
  }
  #listenRadio.active, #autoMatch.active { /* Radio / AutoMatch / Follow are tied to green */
      background: var(--neon-green);
      color: var(--bg);
      border-color: var(--neon-green);
      box-shadow: 0 0 15px var(--neon-green);
  }
  #listenSynth.active { /* Synth is purple */
      background: var(--neon-purple);
      color: var(--bg);
      border-color: var(--neon-purple);
      box-shadow: 0 0 15px var(--neon-purple);
  }
  #micInputToggle.active { /* Mic is red */
      background: var(--neon-red);
      color: var(--bg);
      border-color: var(--neon-red);
      box-shadow: 0 0 15px var(--neon-red);
  }
  #recordToggle.recording { /* Recording is red */
      background: var(--neon-red);
      color: var(--bg);
      border-color: var(--neon-red);
      box-shadow: 0 0 15px var(--neon-red);
  }
  /* Follow checkbox styling */
  #listenBar .toggle label {
      color: var(--muted);
      font-size: 0.9em;
  }
  #listenBar .toggle input[type="checkbox"] {
      vertical-align: middle;
      margin-right: 4px;
      accent-color: var(--neon-green);
  }

  /* Radio bar styling for the new controls panel */
  #radioBar {
      display: flex;
      flex-wrap: wrap; /* Allow items to wrap on smaller screens */
      gap: 10px;
      align-items: center;
      justify-content: center;
      grid-column: span 12; /* Span full width of grid */
      padding: 8px 0;
      border-top: 1px solid rgba(255,255,255,.03);
      margin-top: 10px;
  }
  #radioBar label {
      color: var(--accent2); /* Radio is green-accented */
      font-size: 14px;
      white-space: nowrap;
  }
  #radioBar select, #radioBar input[type="text"] {
      background: #0c0e13;
      border: 1px solid #1f2937;
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 8px;
      flex-grow: 1;
      min-width: 150px;
      max-width: 300px;
  }
  #radioBar #loadCustomRadioBtn {
      padding: 8px 12px;
      font-size: 1em;
      border-color: var(--accent2); /* Load button matches radio color */
      color: var(--accent2);
  }
  #radioBar #loadCustomRadioBtn:hover {
      background: rgba(167, 243, 208, 0.1);
  }
  #radioBar #radioNow {
      font-size: 0.9em;
      color: var(--accent); /* Radio Now Playing in primary accent */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 200px;
      flex-basis: 100px; /* Allow it to shrink */
  }
  #customUrlInputContainer {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-grow: 1;
      min-width: 200px;
      max-width: 500px;
  }


  @media (max-width: 860px){
    .sp6{grid-column: span 12}
    .sp4{grid-column: span 6}
    .sp3{grid-column: span 6}
    .sp2{grid-column: span 6}
  }
</style>
</head>
<body>
  <div id="app">
    <canvas id="chart" aria-label="Interactive Smith Chart Musical Interface" role="img"></canvas>

    <!-- Heads-up stats -->
    <div class="hud" id="hud">
      <div class="pill" title="Resonance Amplitude (0-1)"><div class="dot" style="background:var(--accent)"></div><span class="badge">Volume</span><b id="mag">0.000</b></div>
      <div class="pill" title="Phase Angle in degrees (can be mapped to stereo/detune)"><div class="dot" style="background:var(--accent2)"></div><span class="badge">Phase</span><b id="ang">0.0°</b></div>
      <div class="pill" title="Harmonic Richness (1=pure tone, higher=more harmonics)"><div class="dot" style="background:var(--warn)"></div><span class="badge">Harmonics</span><b id="vswr">1.00</b></div>
      <div class="pill" title="Sound Clarity / Damping (dB)"><div class="dot" style="background:var(--bad)"></div><span class="badge">Clarity</span><b id="rl">∞ dB</b></div>
      <div class="pill" title="Timbre / Filter Settings"><span class="badge">Timbre</span><b id="zread">—</b></div>
      <div class="pill" title="LFO Control"><span class="badge">LFO</span><b id="yread">—</b></div>
    </div>

    <div class="help" id="helpBox">
      <b>Smith Chart Musical Interface Quick Guide</b><br/>
      • Tap or click inside the circle to set the main sound's timbre. Drag to refine.<br/>
      • The 'L' dot indicates the primary sound (derived from Freq, Filter Q/Cutoff).<br/>
      • The 'S' dot shows the sound after Delay effect.<br/>
      • Toggle <i>Complementary Timbre</i> to add a second voice.<br/>
      • <b>Share</b> copies a URL with your current sound settings.<br/>
      <div style="height:6px"></div>
      <span class="muted">Acoustic impedance matching is essential in musical instruments. The Smith Chart visualizes resonance (volume), harmonics (VSWR), and timbre (filter settings) based on your interactions.</span>
    </div>

    <div class="panel">
      <div class="controls">
        <div class="row sp3"><label>Z₀ (Acoustic Ref.)</label><input id="z0" type="number" step="1" min="0.1" value="50"></div>
        <div class="row sp3"><label>Freq (Hz)</label><input id="freqHz" type="number" step="1" min="20" max="20000" value="440"></div>
        <div class="row sp3"><label>Filter Q (0-100)</label><input id="filterQ" type="number" step="0.1" min="0" max="100" value="1"></div>
        <div class="row sp3"><label>Cutoff Offset (Hz)</label><input id="filterCutoffOffset" type="number" step="0.1" value="0"></div>

        <div class="row sp3"><label>LFO Rate (Hz)</label><input id="lfoRate" type="number" step="0.1" min="0" max="20" value="0"></div>
        <div class="row sp3"><label>LFO Depth (0-1)</label><input id="lfoDepth" type="range" step="0.01" min="0" max="1" value="0"><span class="muted" id="lfoDepthRead">0.00</span></div>
        <div class="row sp3"><label>Delay Time (ms)</label><input id="delayTimeMs" type="range" min="0" max="1000" step="1" value="0"><span class="muted" id="delayTimeRead">0 ms</span></div>
        <div class="row sp3"><label>Delay Feedback (0-1)</label><input id="delayFeedback" type="range" min="0" max="0.99" step="0.01" value="0.4"><span class="muted" id="delayFeedbackRead">0.40</span></div>

        <div class="row sp3 toggle"><label><input id="waveform" type="radio" name="waveform" value="sine" checked> Sine</label><label><input type="radio" name="waveform" value="square"> Square</label><label><input type="radio" name="waveform" value="sawtooth"> Sawtooth</label><label><input type="radio" name="waveform" value="triangle"> Triangle</label></div>
        <div class="row sp3 toggle"><label><input id="showAdmit" type="checkbox"> Complementary Timbre</label></div>
        <div class="row sp2 toggle"><label><input id="hiGrid" type="checkbox" checked> Hi‑detail grid</label></div>
        <div class="row sp2"><button class="btn" id="reset">Reset</button></div>
        <div class="row sp2"><button class="btn primary" id="share">Share</button></div>
        
        <!-- Blend Controls -->
        <div class="row sp3"><label>Blend Mode</label>
            <select id="blendMode">
                <option value="crossfade">Crossfade</option>
                <option value="sum">Sum</option>
                <option value="multiply">Multiply (AM)</option>
                <option value="difference">Difference</option>
            </select>
        </div>
        <div class="row sp3"><label>Blend Amount (0-1)</label><input id="blendAmount" type="range" step="0.01" min="0" max="1" value="0.5"><span class="muted" id="blendAmountRead">0.50</span></div>
        <div class="row sp6"><label>Radio Volume</label><input id="radioVolume" type="range" min="0" max="1" step="0.01" value="0.5"><span class="muted" id="radioVolumeRead">0.50</span></div>

        <!-- Listen Mode Presets (Pills) -->
        <div id="listenBar">
            <button class="pill-btn" data-listen-preset="mix" id="listenMix">Mix</button>
            <button class="pill-btn" data-listen-preset="radio" id="listenRadio">Radio</button>
            <button class="pill-btn" data-listen-preset="synth" id="listenSynth">Synth</button>
            <span style="width:8px"></span>
            <button class="pill-btn" id="autoMatch">Auto Match</button>
            <div class="toggle"><label><input type="checkbox" id="followToggle"> Follow</label></div>
        </div>

        <!-- Integrated Radio Bar -->
        <div id="radioBar">
            <label>Radio • <span id="radioStatus">Stopped</span></label>
            <select id="radioSource">
                <option value="off">Off</option>
                <option value="https://ice4.somafm.com/groovesalad-128-mp3">SomaFM Groove Salad</option>
                <option value="https://streams.ilovemusic.de/iloveradio1.mp3">I Love Radio</option>
                <option value="https://stream.live.vc.bbcmedia.co.uk/bbc_radio_one">BBC R1 (may block CORS)</option>
                <option value="custom-url">Add Custom Stream URL...</option>
            </select>
            <div id="customUrlInputContainer" style="display:none;">
                <input type="text" id="dynamicRadioUrl" placeholder="Enter stream URL">
                <button class="btn" id="loadCustomRadioBtn">Load</button>
            </div>
            <span id="radioNow">—</span>
        </div>

        <!-- Action Buttons (Mic, Record) -->
        <div id="actionButtons">
            <button class="pill-btn" id="micInputToggle">Mic Input OFF</button>
            <!-- Learning Mode Toggle removed for now, can be re-added later if needed -->
            <button class="pill-btn" id="recordToggle">Record</button>
        </div>

        <div class="row sp12"><button class="btn" id="help">Help / Tips</button></div>
      </div>
    </div>
  </div>

<script>
(function(){
  const $ = sel=>document.querySelector(sel);
  const canvas = $('#chart');
  const ctx = canvas.getContext('2d');
  let DPR = Math.min(2, window.devicePixelRatio || 1);
  let W=0,H=0,CX=0,CY=0,R=0; // canvas sizing

  // Audio Context and Nodes
  let audioCtx;
  let osc, filter, masterGain, monitorGain;
  let synthAmplitudeGain; // Controls synth base volume by |Gamma| BEFORE LFO
  let lfo, lfoModulatorGain; // LFO and its depth modulator
  let synthChannelGain, radioChannelGain; // For blending amounts
  let dryMixer, delaySendGain, delayReturnGain; // For global dry/wet delay mix
  let mainOutputBus; // The bus where blended signals meet, before final masterGain and dry/wet delay

  let oscY, filterY; // for complementary timbre
  let delay, delayFeedbackGain;
  let isAudioReady = false;

  // Radio specific audio nodes
  let mediaEl = null, mediaNode = null;
  let radioFilter = null, radioPreGain = null, radioPanner = null;
  let radioEnabled = false;

  // Mic Input
  let micInputEnabled = false;
  let micStream = null;
  let micAnalyserNode, micGainNode; // For mic input processing

  // Recording
  let isRecording = false;
  let mediaRecorder;
  let recordedChunks = [];
  let destinationStream;

  // Analysers for Blend Modes (Multiply) and Auto-Match
  let synthAnalyser, synthEnvelopeFollowerGain, synthEnvelopePrev = 0;
  let radioAnalyser;
  let phaseFlipperGain; // For Difference blend mode

  // Auto-Match/Follow
  let followTimer = null;

  // State
  const state = {
    z0: 50, // Acoustic reference (analogous to characteristic impedance)
    freqHz: 440, // Base frequency in Hz
    filterQ: 1, // Filter Q factor
    filterCutoffOffset: 0, // Filter cutoff offset from base freq
    lfoRate: 0, // LFO frequency in Hz
    lfoDepth: 0, // LFO gain modulation depth (0-1)
    delayTimeMs: 0, // Delay time in milliseconds
    delayFeedback: 0.4, // Delay feedback (0-1)
    waveform: 'sine', // Oscillator waveform
    showAdmit: false, // Show complementary timbre
    hiGrid: true,
    radioVolume: 0.5, // Radio volume control
    blendMode: 'crossfade', // New: Blend mode (crossfade, sum, multiply, difference)
    blendAmount: 0.5, // New: Blend amount (0-1)
    micInputEnabled: false,
    isRecording: false,
    autoMatchFollow: false,
    // user marker in Gamma plane (complex) — set by inputs or tapping
    gamma: {re: 0, im: 0},
    fromTap: false // if the current state.gamma comes from user tapping (disables R/X input parsing)
  };

  // --- Rotary volume rings state (synth/radio trims) ---
  let activeRing = null; // 'synth' | 'radio' | null
  let ringSynthAngle = 0; // 0..2π
  let ringRadioAngle = 0; // 0..2π
  let ringSynthTrim = 1.0; // 0..1
  let ringRadioTrim = 1.0; // 0..1
  let ringSynthDetent = -1, ringRadioDetent = -1;
  const RING_DETENTS_COARSE = 36; // 10° steps
  const RING_DETENTS_FINE = 180; // 2° steps
  let ringSnapMode = 'coarse'; // 'coarse' | 'fine' | 'free'
  function syncRingAnglesFromTrims(){
    ringSynthAngle = 2*Math.PI * Math.max(0, Math.min(1, ringSynthTrim));
    ringRadioAngle = 2*Math.PI * Math.max(0, Math.min(1, ringRadioTrim));
  }
  // initialize
  syncRingAnglesFromTrims();

  // UI Elements
  const inputs = {
    z0: $('#z0'), freqHz: $('#freqHz'), filterQ: $('#filterQ'), filterCutoffOffset: $('#filterCutoffOffset'),
    lfoRate: $('#lfoRate'), lfoDepth: $('#lfoDepth'), lfoDepthRead: $('#lfoDepthRead'),
    delayTimeMs: $('#delayTimeMs'), delayFeedback: $('#delayFeedback'),
    delayTimeRead: $('#delayTimeRead'), delayFeedbackRead: $('#delayFeedbackRead'),
    radioVolume: $('#radioVolume'), radioVolumeRead: $('#radioVolumeRead'),
    blendMode: $('#blendMode'), blendAmount: $('#blendAmount'), blendAmountRead: $('#blendAmountRead'),
    mag: $('#mag'), ang: $('#ang'), vswr: $('#vswr'), rl: $('#rl'), zread: $('#zread'), yread: $('#yread'),
    waveformRadios: document.querySelectorAll('input[name="waveform"]'),
    showAdmit: $('#showAdmit'), hiGrid: $('#hiGrid'),
    reset: $('#reset'), share: $('#share'), help: $('#help'), helpBox: $('#helpBox'),
    // Radio UI
    radioSource: $('#radioSource'),
    dynamicRadioUrl: $('#dynamicRadioUrl'),
    loadCustomRadioBtn: $('#loadCustomRadioBtn'),
    customUrlInputContainer: $('#customUrlInputContainer'),
    radioStatus: $('#radioStatus'),
    radioNow: $('#radioNow'),
    // Listen Presets & Auto Match
    listenMix: $('#listenMix'), listenRadio: $('#listenRadio'), listenSynth: $('#listenSynth'),
    autoMatch: $('#autoMatch'), followToggle: $('#followToggle'),
    // Action Buttons
    micInputToggle: $('#micInputToggle'), recordToggle: $('#recordToggle')
  };

  // Complex helpers
  const C = {
    add: (a,b)=>({re:a.re+b.re, im:a.im+b.im}),
    sub: (a,b)=>({re:a.re-b.re, im:a.im-b.im}),
    mul: (a,b)=>({re:a.re*b.re - a.im*b.im, im:a.re*b.re + a.im*b.re}),
    div: (a,b)=>{ const d=b.re*b.re + b.im*b.im || 1e-18; return {re:(a.re*b.re + a.im*b.im)/d, im:(a.im*b.re - a.re*b.im)/d}; },
    conj:(a)=>({re:a.re, im:-a.im}),
    mag:(a)=>Math.hypot(a.re, a.im),
    ang:(a)=>Math.atan2(a.im, a.re),
    expj:(phi)=>({re:Math.cos(phi), im:Math.sin(phi)}),
  };

  // Mapping between normalized z and reflection coefficient gamma
  function z2g(z){ // z is {re, im}
    const num = C.sub(z, {re:1, im:0});
    const den = C.add(z, {re:1, im:0});
    return C.div(num, den);
  }
  function g2z(g){
    const num = C.add({re:1, im:0}, g);
    const den = C.sub({re:1, im:0}, g);
    return C.div(num, den);
  }

  function yFromZ(z){ // y = 1/z
    const den = z.re*z.re + z.im*z.im || 1e-18; return {re: z.re/den, im: -z.im/den};
  }

  // Coordinates
  function toPX(pt){ return {x: CX + R*pt.re, y: CY - R*pt.im}; }
  function fromPX(x,y){ return {re:(x-CX)/R, im:-(y-CY)/R}; }

  function resize(){
    const rect = canvas.getBoundingClientRect();
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.round(rect.width * DPR); H = Math.round(rect.height * DPR);
    canvas.width = W; canvas.height = H;
    canvas.style.width = rect.width + 'px'; canvas.style.height = rect.height + 'px';
    ctx.setTransform(1,0,0,1,0,0); ctx.scale(DPR,DPR);
    // layout
    const w = rect.width, h = rect.height;
    const pad = 16; const s = Math.min(w, h) - pad*2; R = (s/2);
    CX = w/2; CY = h/2 - 10; // slight lift for bottom panel spacing
    draw();
  }

  // Grid drawing
  function drawGrid(){
    ctx.save();
    // Background gradient subtle
    const grad = ctx.createRadialGradient(CX, CY, R*0.1, CX, CY, R*1.2);
    grad.addColorStop(0, '#0b0c0f');
    grad.addColorStop(1, '#0a0c10');
    ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);

    // Clip to unit circle
    ctx.beginPath();
    ctx.arc(CX, CY, R, 0, Math.PI*2);
    ctx.clip();

    // minor grid
    const rMaj = [0,0.2,0.5,1,2,5];
    const xMaj = [0.2,0.5,1,2,5];
    const rMin = state.hiGrid ? [0.1,0.3,0.7,1.5,3,7] : [];
    const xMin = state.hiGrid ? [0.1,0.3,0.7,1.5,3,7] : [];

    // helper to draw circle in Gamma plane (center, radius) masked
    function circle(cx, cy, rr, lw, col){
      ctx.beginPath(); ctx.lineWidth = lw; ctx.strokeStyle = col; ctx.arc(CX + R*cx, CY - R*cy, R*rr, 0, Math.PI*2); ctx.stroke();
    }

    // constant resistance circles: center (r/(r+1),0), radius 1/(r+1)
    const colMin = getCSS('--grid');
    const colMaj = getCSS('--grid2');

    // draw minor first
    ctx.globalAlpha=.7;
    rMin.forEach(r=>{ circle(r/(r+1), 0, 1/(r+1), 1, colMin); });
    xMin.forEach(x=>{
      const rad = 1/Math.abs(x); const cy = 1/x; // centers at (1, 1/x)
      circle(1, cy, rad, 1, colMin);
      circle(1, -cy, rad, 1, colMin);
    });

    // major
    ctx.globalAlpha=1;
    rMaj.forEach((r,i)=>{ circle(r/(r+1), 0, 1/(r+1), 1.5, colMaj); });
    xMaj.forEach(x=>{
      const rad = 1/Math.abs(x); const cy = 1/x;
      circle(1, cy, rad, 1.5, colMaj);
      circle(1, -cy, rad, 1.5, colMaj);
    });

    // boundary
    ctx.globalAlpha=1; ctx.lineWidth=2; ctx.strokeStyle = 'rgba(255,255,255,.15)';
    ctx.beginPath(); ctx.arc(CX, CY, R, 0, Math.PI*2); ctx.stroke();

    // real axis
    ctx.lineWidth=1.5; ctx.strokeStyle='rgba(255,255,255,.18)';
    ctx.beginPath(); ctx.moveTo(CX - R, CY); ctx.lineTo(CX + R, CY); ctx.stroke();

    // labels (r, x)
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto'; ctx.fillStyle='rgba(255,255,255,.6)'; ctx.textAlign='center'; ctx.textBaseline='top';
    rMaj.forEach(r=>{
      const p = toPX({re: (r-1)/(r+1), im: 0}); // leftmost point on each r circle crosses real axis at ( (r-1)/(r+1), 0 )
      ctx.fillText('r='+r, p.x, CY+4);
    });
    ctx.textBaseline='bottom';
    xMaj.forEach(x=>{
      // Adjust label placement for better visibility
      const labelX = CX + R * 0.78; // Offset slightly from edge
      const labelYPos = CY - R * (1 / Math.abs(x)); // Position relative to current x arc
      const labelYNeg = CY + R * (1 / Math.abs(x));

      // Small adjustment for text baseline
      if (x > 0) { // Top arcs
        ctx.fillText('+j'+x, labelX, labelYPos - 4);
      } else { // Bottom arcs
        ctx.fillText('−j'+x, labelX, labelYNeg + 16);
      }
    });

    ctx.restore();
  }

  function getCSS(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }

  // Helper to convert CSS color var to rgba string for canvas
  function varToRgba(varName, alpha = 1){
    const color = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    const r = parseInt(color.slice(1,3),16), g = parseInt(color.slice(3,5),16), b = parseInt(color.slice(5,7),16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }

  // Calculate load gamma from inputs or tap
  function computeGammaFromInputs(){
    const z0 = state.z0;
    const filterQ = state.filterQ; // R equivalent
    const filterCutoffOffset = state.filterCutoffOffset; // X equivalent
    const z = {re: Math.max(0, filterQ/z0), im: filterCutoffOffset/z0}; // Normalize
    const g = z2g(z);
    return g;
  }

  function vswrFromMag(m){ return m>=0.999999 ? Infinity : (1+m)/(1-m); }
  function rlFromMag(m){ return m<=0 ? Infinity : -20*Math.log10(m); }

  function rotateGamma(g, delayTimeMs){ // Simulating delay by rotation. Angle is not direct λ here.
    // For a physical line, rotation is -4pi * (l/lambda). We can map delayTimeMs to a fraction of a "max" wavelength
    const maxDelay = 1000; // ms
    const rotationFactor = delayTimeMs / maxDelay; // Normalize 0-1
    const phi = -2 * Math.PI * rotationFactor; // Rotate from 0 to -360 degrees
    const ej = C.expj(phi);
    return C.mul(g, ej);
  }

  // Draw points and guides
  function drawData(){
    // Determine gamma from either tap state or inputs
    const baseGamma = state.fromTap ? state.gamma : computeGammaFromInputs();
    // Save computed gamma back so stats reflect it if not from tap
    if (!state.fromTap) state.gamma = baseGamma;

    // Rotated gamma after delay effect
    const gSrc = rotateGamma(baseGamma, state.delayTimeMs);

    // Draw SWR circle
    const mag = C.mag(baseGamma);
    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = 1.5; ctx.setLineDash([6,6]); ctx.strokeStyle = `rgba(255,255,255,${0.25 * Math.max(0.2, mag)})`; // Opacity depends on mag
    const rSWR = R*mag; ctx.arc(CX, CY, rSWR, 0, Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);

    // Load point (Primary Sound)
    plotMarker(baseGamma, getCSS('--accent'), 4 + mag*4, 'L'); // Marker size scales with amplitude
    // Source point after delay
    if (state.delayTimeMs > 0) {
      plotMarker(gSrc, getCSS('--accent2'), 3 + mag*3, 'S');
    }

    // Admittance point (Complementary Timbre)
    if (state.showAdmit){
      const gY = {re: -baseGamma.re, im: -baseGamma.im};
      plotMarker(gY, '#fde68a', 3 + mag*3, 'Y');
    }

    ctx.restore();

    // Stats
    const z = g2z(baseGamma); // normalized
    const Z_eff = {re: z.re*state.z0, im: z.im*state.z0}; // "Effective impedance" values for display
    const y = yFromZ(z);
    const Y_eff = {re: y.re/state.z0, im: y.im/state.z0}; // "Effective admittance" values for display

    const m = mag;
    const vs = vswrFromMag(m);
    const rl = rlFromMag(m);
    inputs.mag.textContent = m.toFixed(3);
    inputs.ang.textContent = (C.ang(baseGamma)*180/Math.PI).toFixed(1)+'°';
    inputs.vswr.textContent = (vs===Infinity? '∞' : vs.toFixed(2));
    inputs.rl.textContent = (rl===Infinity? '∞ dB' : rl.toFixed(2)+' dB');
    inputs.zread.textContent = `Q: ${state.filterQ.toFixed(1)} / Cutoff: ${state.filterCutoffOffset.toFixed(1)}Hz`;
    inputs.yread.textContent = `Rate: ${state.lfoRate.toFixed(1)}Hz / Depth: ${state.lfoDepth.toFixed(2)}`;
  }

  function plotMarker(g, color, r=3, label){
    const p = toPX(g);
    // guard: only plot inside unit circle
    if (C.mag(g) > 1.0001) return;
    ctx.beginPath(); ctx.fillStyle=color; ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
    // label
    ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto'; ctx.textAlign='left'; ctx.textBaseline='middle';
    ctx.fillStyle='rgba(255,255,255,.8)';
    ctx.fillText(label, p.x+r+2, p.y);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();
    drawData();
    drawRings();
  }

  function drawRings(){
    // Draw rotary trim rings with explicit spacing to prevent overlap (mobile-friendly)
    const center = { x: CX, y: CY };
    const smithChartRadius = R;
    // Inner gap from Smith circle, ring thickness, and spacing between the two rings
    const ringInnerOffset = smithChartRadius * 0.08; // gap from chart edge
    const ringBandWidth = Math.max(12, Math.min(14, smithChartRadius * 0.06));
    const ringSpacing = Math.max(8, Math.min(14, smithChartRadius * 0.05));

    const rSynthMid = smithChartRadius + ringInnerOffset + ringBandWidth/2;
    const rRadioMid = rSynthMid + ringBandWidth + ringSpacing + ringBandWidth/2;

    // Background bands
    ctx.beginPath(); ctx.arc(center.x, center.y, rSynthMid, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-purple', 0.2); ctx.lineWidth = ringBandWidth; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rRadioMid, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-green', 0.2); ctx.lineWidth = ringBandWidth; ctx.stroke();

    // Filled arcs indicating current trims
    ctx.beginPath(); ctx.arc(center.x, center.y, rSynthMid, 0, ringSynthAngle); ctx.strokeStyle = varToRgba('--neon-purple', 0.8); ctx.lineWidth = ringBandWidth; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rRadioMid, 0, ringRadioAngle); ctx.strokeStyle = varToRgba('--neon-green', 0.8); ctx.lineWidth = ringBandWidth; ctx.stroke();

    // Outer/inner outlines for both bands
    const rSynthInner = rSynthMid - ringBandWidth/2;
    const rSynthOuter = rSynthMid + ringBandWidth/2;
    const rRadioInner = rRadioMid - ringBandWidth/2;
    const rRadioOuter = rRadioMid + ringBandWidth/2;
    ctx.beginPath(); ctx.arc(center.x, center.y, rSynthInner, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-purple', 0.4); ctx.lineWidth = 2; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rSynthOuter, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-purple', 0.4); ctx.lineWidth = 2; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rRadioInner, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-green', 0.4); ctx.lineWidth = 2; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rRadioOuter, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-green', 0.4); ctx.lineWidth = 2; ctx.stroke();

    // Ticks and 10% labels
    const tickCount = 100, tickLen = 6;
    ctx.lineWidth = 2; ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto'; ctx.textAlign='center'; ctx.textBaseline='middle';
    for(let i=0;i<tickCount;i++){
      const a = i * (2*Math.PI/tickCount);
      const major10 = (i % 10 === 0);
      // Synth ticks (inward from outer edge of synth band)
      let x1s = center.x + (rSynthOuter - (major10?14:tickLen)) * Math.cos(a), y1s = center.y + (rSynthOuter - (major10?14:tickLen)) * Math.sin(a);
      let x2s = center.x + rSynthOuter * Math.cos(a), y2s = center.y + rSynthOuter * Math.sin(a);
      ctx.beginPath(); ctx.moveTo(x1s,y1s); ctx.lineTo(x2s,y2s); ctx.strokeStyle = varToRgba('--neon-purple', major10?0.5:0.25); ctx.stroke();
      // Radio ticks (outward from inner edge of radio band)
      let x1r = center.x + (rRadioInner + (major10?14:tickLen)) * Math.cos(a), y1r = center.y + (rRadioInner + (major10?14:tickLen)) * Math.sin(a);
      let x2r = center.x + rRadioInner * Math.cos(a), y2r = center.y + rRadioInner * Math.sin(a);
      ctx.beginPath(); ctx.moveTo(x1r,y1r); ctx.lineTo(x2r,y2r); ctx.strokeStyle = varToRgba('--neon-green', major10?0.5:0.25); ctx.stroke();
      if (major10){
        const label = `${i}%`;
        // Place labels clear of bands
        const lx1 = center.x + (rSynthOuter - 24) * Math.cos(a), ly1 = center.y + (rSynthOuter - 24) * Math.sin(a);
        ctx.fillStyle = varToRgba('--neon-purple', 0.8); ctx.fillText(label, lx1, ly1);
        const lx2 = center.x + (rRadioInner + 24) * Math.cos(a), ly2 = center.y + (rRadioInner + 24) * Math.sin(a);
        ctx.fillStyle = varToRgba('--neon-green', 0.8); ctx.fillText(label, lx2, ly2);
      }
    }

    // Handles positioned on mid-lines for each band
    const hsx = center.x + rSynthMid * Math.cos(ringSynthAngle);
    const hsy = center.y + rSynthMid * Math.sin(ringSynthAngle);
    const hrx = center.x + rRadioMid * Math.cos(ringRadioAngle);
    const hry = center.y + rRadioMid * Math.sin(ringRadioAngle);
    ctx.beginPath(); ctx.arc(hsx, hsy, 6, 0, Math.PI*2); ctx.fillStyle = varToRgba('--neon-purple', 0.9); ctx.shadowColor = varToRgba('--neon-purple',1); ctx.shadowBlur=12; ctx.fill(); ctx.shadowBlur=0;
    ctx.beginPath(); ctx.arc(hrx, hry, 6, 0, Math.PI*2); ctx.fillStyle = varToRgba('--neon-green', 0.9); ctx.shadowColor = varToRgba('--neon-green',1); ctx.shadowBlur=12; ctx.fill(); ctx.shadowBlur=0;

    // Numeric values
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
    ctx.fillStyle = varToRgba('--neon-purple', 1); ctx.fillText(`${Math.round(ringSynthTrim*100)}%`, hsx + 15*Math.cos(ringSynthAngle), hsy + 15*Math.sin(ringSynthAngle));
    ctx.fillStyle = varToRgba('--neon-green', 1); ctx.fillText(`${Math.round(ringRadioTrim*100)}%`, hrx + 15*Math.cos(ringRadioAngle), hry + 15*Math.sin(ringRadioAngle));
  }

  function updateRingFromPoint(which, dx, dy){
    const ang = Math.atan2(dy, dx); // -π..π
    let a = (ang>=0? ang : (2*Math.PI+ang)); // 0..2π
    let detCount = (ringSnapMode==='fine') ? RING_DETENTS_FINE : (ringSnapMode==='coarse' ? RING_DETENTS_COARSE : 0);
    let det = -1, snapped = a;
    if (detCount>0){ det = Math.round(a / (2*Math.PI/detCount)); snapped = det * (2*Math.PI/detCount); }
    if (which==='synth'){
      if (detCount>0 && ringSynthDetent !== det){ ringSynthDetent = det; }
      ringSynthAngle = snapped; ringSynthTrim = Math.max(0, Math.min(1, snapped/(2*Math.PI)));
    } else {
      if (detCount>0 && ringRadioDetent !== det){ ringRadioDetent = det; }
      ringRadioAngle = snapped; ringRadioTrim = Math.max(0, Math.min(1, snapped/(2*Math.PI)));
    }
  }

  // --- Web Audio API Integration ---
  // Envelope Follower for Multiply Blend Mode
  function getSynthEnv(){
    if (!synthAnalyser) return 0;
    const buffer = new Uint8Array(synthAnalyser.frequencyBinCount);
    synthAnalyser.getByteTimeDomainData(buffer);
    // RMS of centered signal
    let sum=0; for(let i=0;i<buffer.length;i++){ const v=(buffer[i]-128)/128; sum+=v*v; }
    let rms = Math.sqrt(sum/buffer.length); // 0..~1
    // scale up a bit and apply attack/release smoothing
    const raw = Math.min(1, rms*2.0);
    const atk = 0.3;  // faster rise
    const rel = 0.08; // slower fall
    const a = raw > synthEnvelopePrev ? atk : rel;
    synthEnvelopePrev = synthEnvelopePrev + a*(raw - synthEnvelopePrev);
    return synthEnvelopePrev;
  }

  function initAudio() {
    if (isAudioReady) return;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      // Master gain (final output to speakers)
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.5; // Overall default output level
      // Monitor path that can be toggled by parent mixer
      monitorGain = audioCtx.createGain();
      monitorGain.gain.value = 1.0; // monitor ON by default
      masterGain.connect(monitorGain);
      monitorGain.connect(audioCtx.destination);

      // For Recording
      destinationStream = audioCtx.createMediaStreamDestination();
      masterGain.connect(destinationStream);

      // Main Oscillator path
      osc = audioCtx.createOscillator();
      osc.type = state.waveform;
      osc.frequency.value = state.freqHz;
      osc.start();

      filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = state.freqHz;
      filter.Q.value = state.filterQ;
      osc.connect(filter);

      synthAmplitudeGain = audioCtx.createGain(); // Controls synth base volume by |Gamma| and LFO
      synthAmplitudeGain.gain.value = 0; // Will be set by updateAudioParameters
      filter.connect(synthAmplitudeGain); // CRITICAL FIX: Connect filter output to amplitude gain

      // --- LFO setup for additive tremolo ---
      lfo = audioCtx.createOscillator();
      lfo.type = 'sine'; // LFO typically sine for tremolo
      lfo.frequency.value = state.lfoRate;
      lfo.start();

      lfoModulatorGain = audioCtx.createGain(); // Scales LFO output by depth
      lfoModulatorGain.gain.value = state.lfoDepth * 0.5; // Initial value, will be updated
      lfo.connect(lfoModulatorGain); // LFO output goes to this gain node

      // Connect the LFO modulator output to *add* to synthAmplitudeGain's gain parameter
      lfoModulatorGain.connect(synthAmplitudeGain.gain);

      // Synth Analyser for Multiply Blend Mode
      synthAnalyser = audioCtx.createAnalyser();
      synthAnalyser.fftSize = 512;
      synthEnvelopeFollowerGain = audioCtx.createGain(); // For tap-off for envelope follower
      synthAmplitudeGain.connect(synthEnvelopeFollowerGain); // Tap from after LFO and Chart Amp
      synthEnvelopeFollowerGain.connect(synthAnalyser);


      synthChannelGain = audioCtx.createGain(); // Gain for blend control
      synthAmplitudeGain.connect(synthChannelGain); // Connect amplitude gain to blend channel

      // --- Radio specific audio nodes ---
      radioFilter = audioCtx.createBiquadFilter();
      radioFilter.type = 'lowpass';
      radioFilter.frequency.value = 20000; // Start wide open
      radioFilter.Q.value = 0.707; // Flat response

      radioPreGain = audioCtx.createGain(); // Radio's independent volume control
      radioPreGain.gain.value = state.radioVolume;

      radioPanner = audioCtx.createStereoPanner();
      radioPanner.pan.value = 0; // Centered

      // Radio Analyser for Auto Match
      radioAnalyser = audioCtx.createAnalyser();
      radioAnalyser.fftSize = 512;
      radioPreGain.connect(radioAnalyser); // Tap from after radioPreGain

      // Radio Chain: mediaNode -> radioFilter -> radioPreGain -> radioPanner -> radioChannelGain
      // mediaNode connected in connectRadio()
      radioFilter.connect(radioPreGain);
      radioPreGain.connect(radioPanner);

      radioChannelGain = audioCtx.createGain(); // Gain for blend control
      radioPanner.connect(radioChannelGain);

      // Phase Flipper for Difference Blend Mode
      phaseFlipperGain = audioCtx.createGain();
      phaseFlipperGain.gain.value = 1; // Default to 1 (no inversion), set to -1 for difference mode


      // Main mix bus where synth and radio signals are combined
      mainOutputBus = audioCtx.createGain();
      synthChannelGain.connect(mainOutputBus);
      // Radio channel connects via phaseFlipperGain to allow difference blending
      radioChannelGain.connect(phaseFlipperGain);
      phaseFlipperGain.connect(mainOutputBus);


      // Global Dry/Wet Delay setup
      dryMixer = audioCtx.createGain();
      delaySendGain = audioCtx.createGain(); // How much of the blended signal goes to delay
      delayReturnGain = audioCtx.createGain(); // How much of the delayed signal comes back

      delay = audioCtx.createDelay(1.0); // Max 1 second delay
      delayFeedbackGain = audioCtx.createGain(); // Feedback loop for delay

      // Route mainOutputBus to dryMixer (dry path) and delaySendGain (wet path)
      mainOutputBus.connect(dryMixer);
      mainOutputBus.connect(delaySendGain);

      dryMixer.connect(masterGain); // Dry signal goes to master

      delaySendGain.connect(delay); // Send signal to delay unit
      delay.connect(delayFeedbackGain); // Delay output feeds back
      delayFeedbackGain.connect(delay); // Feedback loop
      delay.connect(delayReturnGain); // Delayed signal return
      delayReturnGain.connect(masterGain); // Wet signal goes to master

      // Default values for delay
      delay.delayTime.value = state.delayTimeMs / 1000;
      delayFeedbackGain.gain.value = state.delayFeedback;


      // Complementary Timbre (oscY, filterY)
      oscY = audioCtx.createOscillator();
      oscY.type = state.waveform;
      oscY.frequency.value = state.freqHz * 1.005; // Slightly detuned
      oscY.start();

      filterY = audioCtx.createBiquadFilter();
      filterY.type = 'highpass'; // Different filter type for contrast
      filterY.frequency.value = state.freqHz * 0.9;
      filterY.Q.value = state.filterQ;
      oscY.connect(filterY);
      filterY.connect(masterGain); // Direct to master for complementary timbre


      isAudioReady = true;
      console.log("AudioContext initialized with blend and global delay effect!");
      updateAudioParameters(); // Set initial audio state
    } catch (e) {
      console.error("Web Audio API not supported or failed to initialize:", e);
      // Fallback or user notification here
    }
  }

  function updateAudioParameters() {
    if (!isAudioReady) return;

    // Use current state to derive gamma, then update audio params
    const baseGamma = state.fromTap ? state.gamma : computeGammaFromInputs();
    const mag = C.mag(baseGamma);

    // Apply mappings to main synth oscillator
    osc.type = state.waveform;
    osc.frequency.value = Math.max(20, Math.min(20000, state.freqHz)); // Clamp frequency

    filter.Q.value = Math.min(100, Math.max(0, state.filterQ));
    filter.frequency.value = Math.min(20000, Math.max(20, state.freqHz + state.filterCutoffOffset));

    // Update LFO frequency
    lfo.frequency.value = Math.min(20, Math.max(0, state.lfoRate));

    // Update LFO modulator gain to scale LFO output by state.lfoDepth
    lfoModulatorGain.gain.setValueAtTime(state.lfoDepth * 0.5, audioCtx.currentTime); // LFO goes from -1 to 1, so depth/2 for +/- range

    // Update synth base amplitude, scaled by ring trim.
    // The LFO will then *add* its scaled output to this base value.
    synthAmplitudeGain.gain.setValueAtTime(Math.min(1, Math.max(0, mag * ringSynthTrim)), audioCtx.currentTime);


    // Update global delay controls
    delay.delayTime.value = Math.min(1, Math.max(0, state.delayTimeMs / 1000));
    delayFeedbackGain.gain.value = Math.min(0.99, Math.max(0, state.delayFeedback));

    // Calculate dry/wet for the delay based on feedback amount
    const delayWetAmount = state.delayFeedback;
    delaySendGain.gain.value = (state.delayTimeMs > 0 && delayWetAmount > 0) ? 1 : 0; // Only send to delay if delay time & feedback > 0
    delayReturnGain.gain.value = delayWetAmount; // Wet mix controlled by feedback
    dryMixer.gain.value = 1 - delayWetAmount; // Dry mix is inverse

    // Complementary timbre logic
    if (state.showAdmit) {
      oscY.type = state.waveform;
      oscY.frequency.value = Math.max(20, Math.min(20000, state.freqHz * 1.005));
      filterY.Q.value = Math.min(100, Math.max(0, state.filterQ));
      filterY.frequency.value = Math.min(20000, Math.max(20, state.freqHz * 0.9));
      // Ensure it's connected and playing
      if (filterY.numberOfInputs < 1) oscY.connect(filterY); // Only connect if not already
      if (masterGain.numberOfInputs < 1) filterY.connect(masterGain); // Only connect if not already
    } else {
      // Disconnect if not shown
      if (oscY.numberOfOutputs > 0) oscY.disconnect(filterY);
      if (filterY.numberOfOutputs > 0) filterY.disconnect(masterGain);
    }

    // Update radio base gain (independent volume, before blend) and apply trim early as well
    // This ensures audible change even if channel gain is high/low due to blend
    if (radioPreGain) radioPreGain.gain.value = state.radioVolume * ringRadioTrim;

    // --- Apply Blend Mode ---
    switch (state.blendMode) {
        case 'crossfade':
            synthChannelGain.gain.value = (1 - state.blendAmount);
            radioChannelGain.gain.value = state.blendAmount * ringRadioTrim;
            phaseFlipperGain.gain.value = 1; // Ensure no phase inversion
            break;
        case 'sum':
            synthChannelGain.gain.value = 1; // Synth always at full (modulated by mag and LFO)
            radioChannelGain.gain.value = state.blendAmount * ringRadioTrim; // Radio blended in
            phaseFlipperGain.gain.value = 1; // Ensure no phase inversion
            break;
        case 'multiply': { // AM Modulation: radio ducked by synth envelope
            const synthEnv = getSynthEnv();
            const modulationFactor = Math.pow(synthEnv, 0.6); // Perceptual emphasis
            const modulatedRadioGain = ((1 - state.blendAmount) + state.blendAmount * (modulationFactor)) * ringRadioTrim;
            radioChannelGain.gain.setValueAtTime(modulatedRadioGain, audioCtx.currentTime);
            synthChannelGain.gain.value = 1; // Synth always at full
            phaseFlipperGain.gain.value = 1; // Ensure no phase inversion
            break;
        }
        case 'difference':
            synthChannelGain.gain.value = 1;
            radioChannelGain.gain.value = state.blendAmount * ringRadioTrim;
            phaseFlipperGain.gain.value = -1; // Invert phase of radio
            break;
        default: // Default to crossfade if unknown
            synthChannelGain.gain.value = 1 - state.blendAmount;
            radioChannelGain.gain.value = state.blendAmount * ringRadioTrim;
            phaseFlipperGain.gain.value = 1;
            break;
    }
    // Note: Synth trim is already applied at source via synthAmplitudeGain.
    // We do not multiply synthChannelGain further to avoid double-scaling.
  }

  // --- Radio Controls Functions ---
  let customUrlOption = document.createElement('option');
  customUrlOption.value = 'custom-loaded';
  customUrlOption.textContent = 'Custom Stream (Loaded)';
  customUrlOption.style.display = 'none';

  function setRadioStatus(text){ inputs.radioStatus.textContent = text; }
  function hostnameOf(u){ try{ return new URL(u).hostname; }catch{ return ''; } }
  function isBlockedUrl(u){ try{ const h=new URL(u).hostname.replace(/^www\./,''); return h.endsWith('youtube.com')||h.endsWith('youtu.be')||h.endsWith('vimeo.com'); }catch{ return false; } }

  function connectRadio(url){
      if (!isAudioReady) initAudio(); // Ensure audio context is initialized
      disconnectRadio();
      if (!url || url === 'off'){
          setRadioStatus('Stopped');
          radioEnabled=false;
          inputs.radioSource.value = 'off';
          inputs.radioNow.textContent = '—';
          inputs.customUrlInputContainer.style.display = 'none';
          if (inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
              inputs.radioSource.removeChild(customUrlOption);
          }
          return;
      }
      if (isBlockedUrl(url)){
          setRadioStatus('Blocked by CORS policy (YouTube/Vimeo likely)');
          alert('YouTube/Vimeo URLs are typically blocked by browser security policies (CORS). Please use direct MP3/AAC stream links.');
          inputs.radioSource.value = 'off';
          inputs.radioNow.textContent = '—';
          return;
      }

      mediaEl = new Audio();
      mediaEl.crossOrigin='anonymous'; // Crucial for Web Audio API analysis/processing
      mediaEl.src = url;
      mediaEl.loop = true;
      mediaEl.preload='none';

      mediaEl.addEventListener('error', (e)=> {
          console.error('Media element error:', e);
          setRadioStatus('Error loading stream');
          inputs.radioSource.value = 'off';
          inputs.radioNow.textContent = '—';
      });
      mediaEl.addEventListener('waiting', ()=> setRadioStatus('Buffering…'));
      mediaEl.addEventListener('stalled', ()=> setRadioStatus('Buffering…'));
      mediaEl.addEventListener('playing', ()=> setRadioStatus('Playing'));
      mediaEl.addEventListener('pause', ()=> setRadioStatus('Paused'));

      // Connect media element to audio graph
      mediaNode = audioCtx.createMediaElementSource(mediaEl);
      mediaNode.connect(radioFilter);

      inputs.radioNow.textContent = hostnameOf(url) || 'Stream';

      mediaEl.play().then(() => {
          radioEnabled = true;
          // If a custom URL was just loaded, set the dropdown to reflect it
          if (url === inputs.dynamicRadioUrl.value && inputs.dynamicRadioUrl.value !== '') {
              if (!inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
                  inputs.radioSource.appendChild(customUrlOption);
              }
              customUrlOption.style.display = 'block';
              inputs.radioSource.value = 'custom-loaded';
              inputs.customUrlInputContainer.style.display = 'none'; // Hide custom input after successful load
          }
      }).catch((e)=>{
          console.warn('[Radio] Autoplay failed or stream error:', e);
          setRadioStatus('Error: Play failed/blocked (CORS?)');
          radioEnabled = false;
          // If custom URL failed, keep custom input visible for retry
          if (url === inputs.dynamicRadioUrl.value) {
              inputs.customUrlInputContainer.style.display = 'flex';
          }
          inputs.radioSource.value = 'off';
          inputs.radioNow.textContent = '—';
      });
  }

  function disconnectRadio(){
      try{ if (mediaEl){ mediaEl.pause(); mediaEl.src=''; } }catch{}
      try{ if (mediaNode){ mediaNode.disconnect(); } }catch{}
      mediaEl=null; mediaNode=null; radioEnabled=false;
      if (inputs.radioSource.value === 'custom-loaded') {
          // If a custom stream was active, revert to "Add Custom Stream URL..." visually
          inputs.radioSource.value = 'custom-url';
          inputs.customUrlInputContainer.style.display = 'flex'; // Show input field for re-entry
      }
      setRadioStatus('Stopped');
      inputs.radioNow.textContent = '—';
  }

  inputs.radioSource.addEventListener('change', ()=>{
      initAudio(); // Ensure audio context is ready on first interaction
      const selectedValue = inputs.radioSource.value;

      if (selectedValue === 'off'){
          disconnectRadio();
      } else if (selectedValue === 'custom-url'){
          // Show custom URL input field
          inputs.customUrlInputContainer.style.display = 'flex';
          inputs.dynamicRadioUrl.value = ''; // Clear previous input
          inputs.dynamicRadioUrl.focus();
          setRadioStatus('Enter stream URL');
          // If custom-loaded option exists, remove it when user opts to add a new custom URL
          if (inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
              inputs.radioSource.removeChild(customUrlOption);
          }
      } else if (selectedValue === 'custom-loaded') {
          // This option means a custom stream is currently playing/loaded.
          // If user selects it from dropdown, just ensure custom input is visible in case they want to modify/reload.
          inputs.customUrlInputContainer.style.display = 'flex';
          inputs.dynamicRadioUrl.focus();
          // The stream should already be connected. If not, connect again.
          if (!mediaEl || !mediaNode) {
              connectRadio(inputs.dynamicRadioUrl.value.trim());
          }
      } else {
          // A predefined stream is selected
          inputs.customUrlInputContainer.style.display = 'none';
          if (inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
              inputs.radioSource.removeChild(customUrlOption); // Remove "Custom Stream (Loaded)"
          }
          connectRadio(selectedValue);
      }
      updateAudioParameters(); // Ensure blend/volume applies immediately
  });

  inputs.loadCustomRadioBtn.addEventListener('click', () => {
      const url = inputs.dynamicRadioUrl.value.trim();
      if (url) {
          console.log('[Radio] Loading custom URL:', url);
          connectRadio(url);
      } else {
          setRadioStatus('Please enter a URL');
      }
  });

  // --- Mic Input Logic ---
  inputs.micInputToggle.addEventListener('click', async () => {
    initAudio();
    state.micInputEnabled = !state.micInputEnabled;

    if (state.micInputEnabled) {
      try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        micInputToggle.classList.add('active');
        inputs.micInputToggle.textContent = 'Mic Input ON';

        micInputSource = audioCtx.createMediaStreamSource(micStream);
        micAnalyserNode = audioCtx.createAnalyser();
        micAnalyserNode.fftSize = 2048; // Can use for future visualization if needed
        micGainNode = audioCtx.createGain();
        micGainNode.gain.value = 1.0; // Default mic gain, can be a slider later

        micInputSource.connect(micGainNode);
        micGainNode.connect(mainOutputBus); // Route mic to main output bus
        console.log('Microphone input enabled.');
      } catch (err) {
        console.error('Error accessing microphone:', err);
        alert('Could not access microphone. Please ensure permissions are granted.');
        state.micInputEnabled = false;
        inputs.micInputToggle.textContent = 'Mic Input OFF';
        inputs.micInputToggle.classList.remove('active');
      }
    } else {
      if (micStream) {
        micStream.getTracks().forEach(track => track.stop());
        micInputSource.disconnect();
        micGainNode.disconnect();
        micAnalyserNode?.disconnect(); // Disconnect if it exists
        micStream = null;
      }
      inputs.micInputToggle.textContent = 'Mic Input OFF';
      inputs.micInputToggle.classList.remove('active');
      console.log('Microphone input disabled.');
    }
    updateHash(false);
  });

  // --- Recording Logic ---
  inputs.recordToggle.addEventListener('click', () => {
    initAudio();
    state.isRecording = !state.isRecording;

    if (state.isRecording) {
      recordedChunks = [];
      const options = { mimeType: 'audio/webm; codecs=opus' };
      try {
        mediaRecorder = new MediaRecorder(destinationStream.stream, options);
      } catch (e) {
        console.error('MediaRecorder creation failed:', e);
        alert('Recording is not supported in this browser or an error occurred.');
        state.isRecording = false;
        return;
      }

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) recordedChunks.push(event.data);
      };

      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        document.body.appendChild(a);
        a.style.display = 'none';
        a.href = url;
        a.download = `smith_chart_sonifier_${new Date().toISOString()}.webm`;
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        recordedChunks = [];
        console.log('Recording saved.');
      };

      mediaRecorder.start();
      inputs.recordToggle.textContent = 'Recording...';
      inputs.recordToggle.classList.add('recording');
      console.log('Recording started.');
    } else {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
      inputs.recordToggle.textContent = 'Record';
      inputs.recordToggle.classList.remove('recording');
      console.log('Recording stopped.');
    }
    updateHash(false);
  });

  // --- Auto Match / Follow Logic ---
  function getRadioPeakHz(){
    try {
      if (!radioAnalyser || !audioCtx) return null;
      const data = new Uint8Array(radioAnalyser.frequencyBinCount);
      radioAnalyser.getByteFrequencyData(data);
      let maxV=0,maxI=0; for(let i=0;i<data.length;i++){ if(data[i]>maxV){maxV=data[i];maxI=i;} }
      return (maxI/data.length)*(audioCtx.sampleRate/2);
    } catch { return null; }
  }
  function autoMatchOnce(){
    if (!radioEnabled || !radioAnalyser) return; // Only if radio is playing
    const hz = getRadioPeakHz(); if(!hz || hz<50) return;
    const freq = Math.max(50, Math.min(1000, Math.round(hz)));
    state.freqHz = freq; inputs.freqHz.value = freq;
    const cutoff = Math.max(100, Math.min(8000, Math.round(hz*3)));
    state.filterCutoffOffset = cutoff - state.freqHz; // Adjust offset based on new base freq
    inputs.filterCutoffOffset.value = state.filterCutoffOffset;
    state.fromTap = false; // Parameters set by auto-match, not tap
    draw(); updateAudioParameters(); updateHash(false);
    inputs.autoMatch.classList.add('active'); // Temporarily highlight
    setTimeout(() => inputs.autoMatch.classList.remove('active'), 200);
  }
  function setFollow(on){
    if(followTimer){clearInterval(followTimer);followTimer=null;}
    if(on){
      followTimer=setInterval(autoMatchOnce, 2000);
      inputs.followToggle.closest('.toggle').querySelector('label').classList.add('active');
    } else {
      inputs.followToggle.closest('.toggle').querySelector('label').classList.remove('active');
    }
    state.autoMatchFollow = on;
    updateHash(false);
  }
  inputs.autoMatch.addEventListener('click', autoMatchOnce);
  inputs.followToggle.addEventListener('change', e => setFollow(e.target.checked));


  // Event wiring for main controls
  ['z0','freqHz','filterQ','filterCutoffOffset','lfoRate'].forEach(k=>{
    inputs[k].addEventListener('input', ()=>{ state[k] = parseFloat(inputs[k].value)||0; state.fromTap=false; draw(); updateAudioParameters(); updateHash(false); });
  });
  inputs.lfoDepth.addEventListener('input', ()=>{ state.lfoDepth = parseFloat(inputs.lfoDepth.value)||0; inputs.lfoDepthRead.textContent = state.lfoDepth.toFixed(2); state.fromTap=false; draw(); updateAudioParameters(); updateHash(false); });
  inputs.delayTimeMs.addEventListener('input', ()=>{ state.delayTimeMs = parseFloat(inputs.delayTimeMs.value)||0; inputs.delayTimeRead.textContent = state.delayTimeMs.toFixed(0)+' ms'; state.fromTap=false; draw(); updateAudioParameters(); updateHash(false); });
  inputs.delayFeedback.addEventListener('input', ()=>{ state.delayFeedback = parseFloat(inputs.delayFeedback.value)||0; inputs.delayFeedbackRead.textContent = state.delayFeedback.toFixed(2); state.fromTap=false; draw(); updateAudioParameters(); updateHash(false); });
  inputs.radioVolume.addEventListener('input', ()=>{ state.radioVolume = parseFloat(inputs.radioVolume.value)||0; inputs.radioVolumeRead.textContent = state.radioVolume.toFixed(2); updateAudioParameters(); updateHash(false); });

  // Event wiring for new blend controls
  inputs.blendMode.addEventListener('change', ()=>{
      state.blendMode = inputs.blendMode.value;
      // Remove active state from listen preset buttons when blend mode changes manually
      document.querySelectorAll('#listenBar [data-listen-preset]').forEach(btn => btn.classList.remove('active'));
      updateAudioParameters(); updateHash(false);
  });
  inputs.blendAmount.addEventListener('input', ()=>{ state.blendAmount = parseFloat(inputs.blendAmount.value)||0; inputs.blendAmountRead.textContent = state.blendAmount.toFixed(2); updateAudioParameters(); updateHash(false); });


  inputs.waveformRadios.forEach(radio => {
    radio.addEventListener('change', () => { state.waveform = radio.value; state.fromTap=false; draw(); updateAudioParameters(); updateHash(false); });
  });
  inputs.showAdmit.addEventListener('change', ()=>{ state.showAdmit = inputs.showAdmit.checked; draw(); updateAudioParameters(); updateHash(false); });
  inputs.hiGrid.addEventListener('change', ()=>{ state.hiGrid = inputs.hiGrid.checked; draw(); updateHash(false); });

  // --- Listen Preset Buttons Logic ---
  document.querySelectorAll('#listenBar [data-listen-preset]').forEach(btn => {
    btn.addEventListener('click', () => {
      initAudio();
      const preset = btn.dataset.listenPreset;
      let newBlendMode = state.blendMode;
      let newBlendAmount = state.blendAmount;

      // Deactivate all preset buttons first
      document.querySelectorAll('#listenBar [data-listen-preset]').forEach(b => b.classList.remove('active'));
      // Activate clicked button
      btn.classList.add('active');

      if (preset === 'mix') {
        newBlendMode = 'crossfade';
        newBlendAmount = 0.5;
      } else if (preset === 'radio') {
        newBlendMode = 'sum';
        newBlendAmount = 1.0;
        if (!radioEnabled) connectRadio(inputs.radioSource.value === 'off' ? 'https://ice4.somafm.com/groovesalad-128-mp3' : inputs.radioSource.value); // Autoplay a default radio if off
      } else if (preset === 'synth') {
        newBlendMode = 'sum';
        newBlendAmount = 0.0;
      }

      state.blendMode = newBlendMode;
      state.blendAmount = newBlendAmount;
      inputs.blendMode.value = newBlendMode;
      inputs.blendAmount.value = newBlendAmount;
      inputs.blendAmountRead.textContent = newBlendAmount.toFixed(2);
      updateAudioParameters();
      updateHash(false);
    });
  });


  inputs.reset.addEventListener('click', ()=>{ 
    Object.assign(state,{
      z0:50, freqHz:440, filterQ:1, filterCutoffOffset:0, lfoRate:0, lfoDepth:0, delayTimeMs:0, delayFeedback:0.4, 
      waveform:'sine', showAdmit:false, hiGrid:true, radioVolume:0.5, blendMode:'crossfade', blendAmount:0.5,
      micInputEnabled:false, isRecording:false, autoMatchFollow:false,
      gamma:{re:0,im:0}, fromTap:false
    }); 
    // Reset ring trims/angles
    ringSynthTrim = 1.0; ringRadioTrim = 1.0; syncRingAnglesFromTrims();
    disconnectRadio(); // Also reset radio
    setFollow(false); // Stop follow
    inputs.micInputToggle.classList.remove('active'); // Deactivate mic button
    inputs.recordToggle.classList.remove('recording'); // Deactivate record button
    document.querySelectorAll('#listenBar [data-listen-preset]').forEach(b => b.classList.remove('active')); // Deactivate listen presets
    inputs.followToggle.checked = false; // Uncheck follow
    
    syncToUI(); draw(); updateAudioParameters(); updateHash(false); 
  });
  inputs.share.addEventListener('click', ()=>{ const url = updateHash(true); navigator.clipboard?.writeText(url); flash('Copied shareable URL to clipboard'); });
  inputs.help.addEventListener('click', ()=>{ inputs.helpBox.classList.toggle('show'); });

  function syncToUI(){
    inputs.z0.value=state.z0; inputs.freqHz.value=state.freqHz; inputs.filterQ.value=state.filterQ; inputs.filterCutoffOffset.value=state.filterCutoffOffset; 
    inputs.lfoRate.value=state.lfoRate; inputs.lfoDepth.value=state.lfoDepth; inputs.lfoDepthRead.textContent = state.lfoDepth.toFixed(2);
    inputs.delayTimeMs.value=state.delayTimeMs; inputs.delayFeedback.value=state.delayFeedback;
    inputs.delayTimeRead.textContent = state.delayTimeMs.toFixed(0)+' ms'; 
    inputs.delayFeedbackRead.textContent = state.delayFeedback.toFixed(2);
    inputs.radioVolume.value = state.radioVolume; inputs.radioVolumeRead.textContent = state.radioVolume.toFixed(2);
    inputs.blendMode.value = state.blendMode; inputs.blendAmount.value = state.blendAmount; inputs.blendAmountRead.textContent = state.blendAmount.toFixed(2);
    inputs.showAdmit.checked=state.showAdmit; inputs.hiGrid.checked=state.hiGrid;
    document.querySelector(`input[name="waveform"][value="${state.waveform}"]`).checked = true;

    // Sync state for Mic/Record/Follow buttons
    inputs.micInputToggle.classList.toggle('active', state.micInputEnabled);
    inputs.micInputToggle.textContent = `Mic Input ${state.micInputEnabled ? 'ON' : 'OFF'}`;
    inputs.recordToggle.classList.toggle('recording', state.isRecording);
    inputs.recordToggle.textContent = `${state.isRecording ? 'Recording...' : 'Record'}`;
    inputs.followToggle.checked = state.autoMatchFollow;
    inputs.followToggle.closest('.toggle').querySelector('label').classList.toggle('active', state.autoMatchFollow);

    // Sync listen presets based on current blend mode/amount
    document.querySelectorAll('#listenBar [data-listen-preset]').forEach(btn => btn.classList.remove('active'));
    if (state.blendMode === 'crossfade' && state.blendAmount === 0.5) inputs.listenMix.classList.add('active');
    else if (state.blendMode === 'sum' && state.blendAmount === 1.0) inputs.listenRadio.classList.add('active');
    else if (state.blendMode === 'sum' && state.blendAmount === 0.0) inputs.listenSynth.classList.add('active');


    // Reset radio UI state
    inputs.radioSource.value = 'off';
    inputs.customUrlInputContainer.style.display = 'none';
    if (inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
        inputs.radioSource.removeChild(customUrlOption);
    }
  }

  // Tap/drag to set gamma
  let dragging=false;
  canvas.addEventListener('pointerdown', (e)=>{ 
    initAudio(); // Ensure audio context starts on first interaction
    dragging=true; setFromEvent(e, true); 
  });
  canvas.addEventListener('pointermove', (e)=>{ if(dragging){ setFromEvent(e, false); }});
  window.addEventListener('pointerup', ()=> { dragging=false; activeRing=null; });

  function setFromEvent(e, isDown){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left); const y = (e.clientY - rect.top);
    // Update ring snap mode from modifiers (desktop)
    ringSnapMode = e.altKey ? 'free' : (e.shiftKey ? 'fine' : 'coarse');

    // Check ring hits first on pointerdown
    if (isDown){
      const dx = x - CX, dy = y - CY; const dist = Math.hypot(dx, dy);
      const smithChartRadius = R; const ringBandWidth = 14;
      const r1 = smithChartRadius * 1.08, r2 = smithChartRadius * 1.16;
      const r1_mid = r1 + ringBandWidth/2 - 2, r2_mid = r2 - ringBandWidth/2 + 2;
      const hitTolerance = ringBandWidth/2 + 5;
      if (Math.abs(dist - r2_mid) <= hitTolerance){
        activeRing='radio';
        // Ensure radio is actually audible; if off, auto-load selection or default
        try{
          if (!radioEnabled){
            const sel = inputs.radioSource?.value;
            const url = (!sel || sel==='off') ? 'https://ice4.somafm.com/groovesalad-128-mp3' : sel;
            connectRadio(url);
          }
        }catch{}
        updateRingFromPoint('radio', dx, dy); draw(); updateAudioParameters(); return;
      }
      if (Math.abs(dist - r1_mid) <= hitTolerance){ activeRing='synth'; updateRingFromPoint('synth', dx, dy); draw(); updateAudioParameters(); return; }
    } else if (activeRing){
      const dx = x - CX, dy = y - CY; updateRingFromPoint(activeRing, dx, dy); draw(); updateAudioParameters(); return;
    }

    const g = fromPX(x,y);
    const m = C.mag(g);
    if (m<=1){
      state.gamma = g; state.fromTap = true; // derive R/X and set fields
      const z = g2z(g); // normalized impedance
      
      // Map normalized z.re and z.im back to filter Q and cutoff offset
      // We need to scale them appropriately for the input ranges.
      state.filterQ = Math.max(0, z.re * state.z0); // Assuming filterQ maps directly to R
      // For X, use a range that's appropriate for cutoff offset
      const maxCutoffOffsetRange = 4000; // Example max offset range (e.g., -2000 to +2000)
      state.filterCutoffOffset = z.im * state.z0 * (maxCutoffOffsetRange / (state.z0 * 2)); // Scale by Z0 and max offset range
      
      // Clamp values to UI limits
      state.filterQ = Math.min(100, Math.max(0, state.filterQ));
      state.filterCutoffOffset = Math.min(2000, Math.max(-2000, state.filterCutoffOffset)); // Example range for offset

      // When tapping, other controls (LFO, Delay, Freq, Radio Volume) remain as set unless specified
      // For simplicity, we only update R, X here.
      syncToUI(); draw(); updateAudioParameters(); updateHash(false);
    }
  }

  // Share via URL hash
  function updateHash(write){
    const obj = { 
      z0:state.z0, freqHz:state.freqHz, filterQ:state.filterQ, filterCutoffOffset:state.filterCutoffOffset, 
      lfoRate:state.lfoRate, lfoDepth:state.lfoDepth, delayTimeMs:state.delayTimeMs, delayFeedback:state.delayFeedback,
      waveform:state.waveform, showAdmit:state.showAdmit?1:0, hiGrid:state.hiGrid?1:0, radioVolume:state.radioVolume,
      blendMode:state.blendMode, blendAmount:state.blendAmount, mic:state.micInputEnabled?1:0, rec:state.isRecording?1:0, follow:state.autoMatchFollow?1:0,
      g:[+state.gamma.re.toFixed(6), +state.gamma.im.toFixed(6)], t: state.fromTap?1:0 
    };
    const hash = btoa(encodeURIComponent(JSON.stringify(obj)));
    if (write){ location.hash = hash; return location.href; }
    else { history.replaceState(null,'', location.pathname + '#' + hash); return location.href; }
  }
  function restoreFromHash(){
    const h = location.hash.slice(1); if(!h) return;
    try{
      const obj = JSON.parse(decodeURIComponent(atob(h)));
      Object.assign(state, {
        z0:obj.z0, freqHz:obj.freqHz, filterQ:obj.filterQ, filterCutoffOffset:obj.filterCutoffOffset, 
        lfoRate:obj.lfoRate, lfoDepth:obj.lfoDepth, delayTimeMs:obj.delayTimeMs, delayFeedback:obj.delayFeedback,
        waveform:obj.waveform || 'sine', showAdmit:!!obj.showAdmit, hiGrid:!!obj.hiGrid, 
        radioVolume:obj.radioVolume ?? 0.5,
        blendMode:obj.blendMode ?? 'crossfade',
        blendAmount:obj.blendAmount ?? 0.5,
        micInputEnabled:obj.mic ?? false,
        isRecording:obj.rec ?? false,
        autoMatchFollow:obj.follow ?? false,
        gamma:{re:obj.g?.[0]||0, im:obj.g?.[1]||0}, fromTap: !!obj.t
      });
    }catch(e){ console.warn('Bad hash', e); }
  }

  function flash(msg){
    const pill = document.createElement('div'); pill.className='pill'; pill.textContent = msg; pill.style.position='absolute'; pill.style.left='12px'; pill.style.bottom='110px'; pill.style.zIndex='10';
    document.body.appendChild(pill); setTimeout(()=>pill.remove(), 1600);
  }

  // Init
  restoreFromHash();
  syncToUI();
  window.addEventListener('resize', resize, {passive:true});
  resize(); // Initial draw
  // Audio will be initialized on first user interaction (canvas click/touch or any button/slider interaction)
  // Expose mixed audio stream to parent window (for recording both decks in index.html)
  window.addEventListener('message', async (e)=>{
    try{
      const msg = e.data || {};
      if (msg && msg.type === 'request-audio-stream'){
        if (!isAudioReady) initAudio();
        if (!destinationStream && audioCtx){
          destinationStream = audioCtx.createMediaStreamDestination();
          try{ masterGain?.connect(destinationStream); }catch{}
        }
        if (destinationStream){
          e.source?.postMessage({ type: 'audio-stream', id: msg.id, stream: destinationStream.stream }, '*');
        }
      } else if (msg && msg.type==='suspend-audio'){
        try{ if (!isAudioReady) initAudio(); await audioCtx?.suspend?.(); }catch{}
      } else if (msg && msg.type==='resume-audio'){
        try{ if (!isAudioReady) initAudio(); await audioCtx?.resume?.(); }catch{}
      }
    }catch(err){ console.warn('[postMessage] error', err); }
  });
})();
</script>
</body>
</html>