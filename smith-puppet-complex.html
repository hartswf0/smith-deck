<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Smith Chart — Musical Interface (Puppet + Vocoder)</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');

  :root{
    --bg:#0b0c0f; --panel:#0f1115; --ink:#e6e6e6; --muted:#9aa4ad; --accent:#6ee7ff; --accent2:#a7f3d0; --grid:#263241; --grid2:#334155; --good:#34d399; --bad:#f87171; --warn:#fbbf24;
    --neon-blue: #00e5ff; /* Equivalent to --accent */
    --neon-green: #00ff99; /* Equivalent to --accent2 */
    --neon-red: #ff3366;
    --neon-purple: #cc33ff;

    --shadow:0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";}
  #app{position:fixed; inset:0; display:grid; grid-template-rows: 1fr auto;}
  canvas{display:block; width:100%; height:100%; touch-action:none;}

  /* --- Top HUD (minimal stats, corner placement) --- */
  #topHud{
    position:absolute;
    top:12px; left:12px; right:12px;
    display:flex;
    justify-content: space-between; /* Pushes content to corners */
    gap:8px;
    flex-wrap:nowrap; /* Keep corner groups together */
    pointer-events:none; /* Allow clicks to pass through to canvas */
    z-index: 50; /* Above canvas, below help box */
  }
  #topLeftHud, #topRightHud {
    display: flex;
    gap: 8px;
    flex-wrap: nowrap; /* Prevent pills from wrapping */
    pointer-events: auto; /* Re-enable for the pills themselves */
  }
  #topHud .pill{
    background:rgba(15,17,21,.75);
    backdrop-filter: blur(8px);
    border:1px solid rgba(255,255,255,.06);
    border-radius:999px;
    padding:6px 10px; /* Smaller padding */
    display:flex;
    align-items:center;
    gap:8px; /* Smaller gap */
    box-shadow:var(--shadow);
    color:var(--ink);
    font-size: 13px; /* Smaller font */
    line-height: 1;
    min-width: 0;
    flex-shrink: 0; /* CRITICAL: Prevent pills from shrinking or growing */
    white-space: nowrap; /* CRITICAL: Prevent text from wrapping */
  }
  #topHud .badge{font-variant-numeric: tabular-nums; font-size:11px; color:var(--muted); white-space: nowrap;} /* Smaller badge font */
  #topHud .dot{width:8px; height:8px; border-radius:50%} /* Smaller dot */
  #topHud b { font-weight: 500; white-space: nowrap; /* CRITICAL */ flex-shrink: 0; font-feature-settings: "tnum"; /* Ensure tabular numbers */ }
  /* Fixed widths for HUD values to prevent jitter */
  #topHud #mag { min-width: 2.7em; text-align: right; } /* e.g., 0.XXX */
  #topHud #ang { min-width: 4.5em; text-align: right; } /* e.g., -XXX.X° */
  #topHud #zread { min-width: 10em; text-align: right; } /* e.g., Q:XX.X/CO:±XXXXHz */
  #topHud #vswr { min-width: 3em; text-align: right; } /* e.g., XX.XX */
  #topHud #rl { min-width: 5em; text-align: right; } /* e.g., ±XX.XX dB */
  #topHud #yread { min-width: 8em; text-align: right; } /* e.g., R:X.X/D:0.00 */


  /* --- Dashboard (main control panel) --- */
  #dashboard{
    position:absolute;
    bottom:0; left:0; right:0;
    display:flex;
    flex-wrap: wrap;
    gap: 8px; /* Space between pill groups */
    padding: 12px;
    pointer-events: auto;
    background:linear-gradient(180deg, rgba(16,18,23,.9), rgba(16,18,23,.9));
    border-top:1px solid rgba(255,255,255,.06);
    box-shadow: var(--shadow);
    max-height: 50%; /* Prevent dashboard from taking up too much screen */
    overflow-y: auto; /* Scroll if content exceeds max-height */
    align-items: flex-start;
    justify-content: center;
    align-content: flex-start;
    transition: transform 0.3s ease-in-out, max-height 0.3s ease-in-out, padding 0.3s ease-in-out, border-top 0.3s ease-in-out;
    transform: translateY(0);
  }
  #dashboard.hidden {
    transform: translateY(100%);
    pointer-events: none;
    max-height: 0;
    padding: 0;
    border-top: none;
  }
  .pill{
    pointer-events:auto;
    background:rgba(15,17,21,.75);
    backdrop-filter: blur(8px);
    border:1px solid rgba(255,255,255,.06);
    border-radius:999px;
    padding:8px 12px;
    display:flex;
    align-items:center;
    gap:10px;
    box-shadow:var(--shadow);
    color:var(--ink);
    font-size: 14px;
    line-height: 1;
    min-width: 0;
  }
  .badge{font-variant-numeric: tabular-nums; font-size:12px; color:var(--muted); white-space: nowrap; flex-shrink: 0;}
  b { font-weight: 500; white-space: nowrap; /* CRITICAL */ flex-shrink: 0; font-feature-settings: "tnum"; text-align: right; min-width: 3em; /* Default min-width for range readouts */ }
  /* Specific min-widths for range readouts to prevent jitter */
  #z0Read { min-width: 3em; } /* 000 */
  #freqHzRead { min-width: 4.5em; } /* 0000 Hz */
  #filterQRead { min-width: 3em; } /* 00.0 */
  #filterCutoffOffsetRead { min-width: 5.5em; } /* ±0000 Hz */
  #lfoRateRead { min-width: 3.5em; } /* 00.0 Hz */
  #lfoDepthRead { min-width: 2.7em; } /* 0.00 */
  #delayTimeRead { min-width: 4.5em; } /* 0000 ms */
  #delayFeedbackRead { min-width: 2.7em; } /* 0.00 */
  #blendAmountRead { min-width: 2.7em; } /* 0.00 */
  /* NEW SLIDERS */
  #inputGainRead { min-width: 2.7em; } /* 0.00 */
  #baseCutoffRead { min-width: 4.5em; } /* 0000 Hz */


  /* Pill-specific styling for inputs */
  .pill input[type="number"],
  .pill input[type="text"],
  .pill select {
      background: none;
      border: none;
      color: var(--ink);
      padding: 0;
      flex-grow: 1;
      min-width: 50px;
      text-align: left;
      font-size: 14px;
      font-family: inherit;
      -moz-appearance: textfield;
      font-feature-settings: "tnum"; /* Tabular numbers for input fields too */
  }
  .pill input[type="number"]::-webkit-outer-spin-button,
  .pill input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
  }
  .pill select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%239aa4ad'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 4px center;
      background-size: 16px;
      padding-right: 20px;
      cursor: pointer;
  }
  .pill input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100px;
      height: 6px;
      background: var(--grid);
      outline: none;
      opacity: 0.9;
      transition: opacity .2s;
      border-radius: 999px;
      flex-grow: 1;
      margin: 0 4px;
  }
  .pill input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--accent);
      cursor: grab;
      box-shadow: 0 0 8px var(--accent);
      margin-top: -9px;
  }
  .pill input[type="range"]::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--accent);
      cursor: grab;
      box-shadow: 0 0 8px var(--accent);
  }
  .pill input[type="range"]:hover {
    opacity: 1;
  }

  /* Pill Buttons - general style */
  .pill-btn {
    cursor: pointer;
    user-select: none;
    background: #0c0e13;
    color: var(--ink);
    border: 1px solid #1f2937;
    border-radius: 999px;
    padding: 8px 12px;
    display: flex;
    align-items:center;
    justify-content:center;
    transition: background .15s ease, box-shadow .15s ease, transform .05s ease, color .15s ease, border-color .15s ease;
    font-size: 14px;
    line-height: 1;
    white-space: nowrap;
    min-width: 0;
  }
  .pill-btn:hover {
    box-shadow: 0 0 8px rgba(110, 231, 255, 0.3);
  }
  .pill-btn:active {
    transform: translateY(1px);
  }

  /* Specific active states for pill buttons */
  #listenMix.active {
      background: var(--neon-blue); color: var(--bg); border-color: var(--neon-blue); box-shadow: 0 0 15px var(--neon-blue);
  }
  #listenRadio.active, #autoMatch.active {
      background: var(--neon-green); color: var(--bg); border-color: var(--neon-green); box-shadow: 0 0 15px var(--neon-green);
  }
  #listenSynth.active {
      background: var(--neon-purple); color: var(--bg); border-color: var(--neon-purple); box-shadow: 0 0 15px var(--neon-purple);
  }
  #micInputToggle.active, #puppetToggle.active, #learningModeToggle.active, #vocoderToggle.active { /* Added new toggles */
      background: var(--neon-red); color: var(--bg); border-color: var(--neon-red); box-shadow: 0 0 15px var(--neon-red);
  }
  #recordToggle.recording {
      background: var(--neon-red); color: var(--bg); border-color: var(--neon-red); box-shadow: 0 0 15px var(--neon-red);
  }

  /* Custom checkbox pill-btn styles */
  .pill-btn.checkbox-pill.active {
    background: var(--neon-green);
    color: var(--bg);
    border-color: var(--neon-green);
    box-shadow: 0 0 8px var(--neon-green);
  }
  .pill-btn.checkbox-pill input[type="checkbox"] {
    display: none;
  }

  /* Waveform radios in a pill */
  .waveform-pill {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    flex-grow: 1;
  }
  .waveform-pill label {
    display: flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
    font-size: 14px;
    color: var(--ink);
    padding: 4px 0;
    border-radius: 999px;
  }
  .waveform-pill input[type="radio"] {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border: 1px solid var(--muted);
    border-radius: 50%;
    outline: none;
    cursor: pointer;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }
  .waveform-pill input[type="radio"]:checked {
    border-color: var(--accent);
  }
  .waveform-pill input[type="radio"]:checked::before {
    content: '';
    width: 10px;
    height: 10px;
    background-color: var(--accent);
    border-radius: 50%;
    display: block;
  }
  .waveform-pill label:hover {
    color: var(--accent);
  }

  /* Pill Groups (Collapsible Areas) */
  .pill-group {
    display: flex;
    flex-direction: column;
    gap: 0;
    background: rgba(15,17,21,.5);
    border: 1px solid rgba(255,255,255,.04);
    border-radius: 16px;
    padding: 0;
    flex-grow: 1;
    min-width: min(300px, 100%);
    overflow: hidden;
  }
  .pill-group-header {
    width: 100%;
    background: rgba(15,17,21,.1);
    border: none;
    color: var(--muted);
    padding: 8px 15px;
    font-size: 14px;
    font-weight: 500;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    border-bottom: 1px solid rgba(255,255,255,.01);
    border-radius: 16px 16px 0 0;
    text-align: left;
    white-space: nowrap;
  }
  .pill-group-header h3 {
      margin: 0;
      font-size: 1em;
      color: inherit;
      font-weight: inherit;
  }
  .pill-group-header .icon {
    transition: transform 0.2s ease-in-out;
    margin-left: 10px;
    font-size: 1.2em; /* Use simple > char, make it slightly larger for visibility */
    line-height: 1;
    flex-shrink: 0;
  }
  .pill-group.collapsed .pill-group-header .icon {
    transform: rotate(0deg); /* Points right when collapsed */
  }
  .pill-group-header[aria-expanded="true"] .icon {
      transform: rotate(90deg); /* Points down when expanded */
  }


  .pill-group-header:hover {
    background: rgba(20,22,28,.15);
  }

  .pill-group-content {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    padding: 10px;
    max-height: 500px; /* Max height to allow animation */
    transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out;
  }
  .pill-group.collapsed .pill-group-content {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
    overflow: hidden;
  }

  /* Styling for pills/buttons within content */
  .pill-group-content > .pill,
  .pill-group-content > .pill-btn {
    flex-grow: 1;
    min-width: unset;
  }

  /* Specific styling for nested radio group */
  .radio-pill-group {
      flex-direction: column;
      flex-grow: 1;
      padding: 0px; /* Managed by parent .pill-group-content */
      min-width: unset;
      gap: 6px;
      border: none;
      background: none;
      box-shadow: none;
  }
  .radio-pill-group > .pill,
  .radio-pill-group > .pill-btn {
      width: 100%;
      flex-grow: 1;
  }

  #radioNow {
      font-size: 0.9em;
      color: var(--accent);
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
      flex-shrink: 1;
  }

  /* Custom URL input styling within a pill */
  #customUrlInputContainer.pill {
      flex-wrap: nowrap;
      width: 100%;
      flex-grow: 1;
  }
  #customUrlInputContainer input[type="text"] {
      padding: 0;
  }
  #customUrlInputContainer #loadCustomRadioBtn {
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.9em;
      flex-shrink: 0;
  }

  /* Help Box */
  .help{
      position: absolute;
      right: 12px;
      bottom: 12px; /* Adjusted by JS to sit above dashboard/footer */
      background:rgba(15,17,23,.9);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:12px;
      width:min(420px, calc(100vw - 24px));
      box-shadow: var(--shadow);
      font-size:13px;
      line-height:1.35;
      display:none;
      z-index: 100;
  }
  .help.show{display:block}

  /* --- Global Actions Bar (Always Visible, between canvas and dashboard) --- */
  #globalActionsBar {
      position: absolute; /* Changed from fixed to absolute to position relative to app grid */
      bottom: 0; /* Will be adjusted by JS to sit just above dashboard */
      left: 0;
      right: 0;
      padding: 8px 12px;
      display: flex;
      gap: 8px;
      justify-content: center;
      z-index: 90; /* Below help box, above dashboard */
      pointer-events: auto;
      background: linear-gradient(0deg, rgba(16,18,23,.9), rgba(16,18,23,.0)); /* Subtle gradient from bottom */
      border-top:1px solid rgba(255,255,255,.03);
      box-shadow: var(--shadow);
      transition: transform 0.3s ease-in-out, background 0.3s ease-in-out, bottom 0.3s ease-in-out;
  }
  /* When dashboard is hidden, global actions bar should shift to the bottom of the viewport */
  #dashboard.hidden + #globalActionsBar {
      bottom: 0 !important; /* Override JS setting for bottom when dashboard is hidden */
      background: linear-gradient(180deg, rgba(16,18,23,.0), rgba(16,18,23,.9));
      border-top: 1px solid rgba(255,255,255,.06);
      padding-top: 12px;
  }
  #globalActionsBar .pill-btn { /* Style for buttons within the global actions bar */
      font-size: 18px; /* Larger icons/glyphs */
      padding: 6px 12px;
      min-width: unset; /* Allow them to shrink to content */
      flex-shrink: 0; /* Prevent from shrinking */
  }

  /* === NEW STYLES FROM SNIPPET B === */
  #sgStamp{position:fixed;left:12px;top:8px;z-index:10000;background:rgba(0,0,0,.55);border:1px solid rgba(0,229,255,.35);border-radius:999px;padding:4px 10px;color:#8ff;font:12px/1.2 'Space Mono', monospace;pointer-events:none}
  #learningModeOverlay{position:absolute;top:0;left:0;width:100%;height:100%;display:none;justify-content:center;align-items:center;flex-direction:column;background:rgba(0,0,0,.7);color:var(--ink);z-index:200;padding:20px; font-family:'Space Mono', monospace;} /* Use Space Mono for this overlay */
  #learningModeOverlay.active{display:flex}
  #learningModeContent{background:rgba(0,0,0,.85);padding:30px;border-radius:10px;box-shadow:0 0 25px var(--neon-blue);max-width:80%;max-height:80%;overflow:auto;position:relative}
  #learningModeContent h2{color:var(--neon-blue);margin-top:0}
  #closeLearningMode{position:absolute;top:10px;right:10px;background:none;border:none;color:var(--neon-red);font-size:1.5em;cursor:pointer}
  #learningModeContent button{background:var(--neon-purple);color:var(--ink);border:none;padding:8px 12px;border-radius:5px;cursor:pointer;font-size:.9em;box-shadow:0 0 8px rgba(204,51,255,.5);margin:5px;transition:background .3s,box-shadow .3s}
  #learningModeContent button:hover{background:#e066ff;box-shadow:0 0 12px #e066ff}

  @media (max-width: 860px) {
      #topHud .pill{
          padding:5px 8px; /* Even smaller for mobile */
          font-size: 12px;
          gap:6px;
      }
      #topHud .badge{font-size:10px;}
      /* Fixed widths for HUD values to prevent jitter on mobile */
      #topHud #mag { min-width: 2.7em; } /* e.g., 0.XXX */
      #topHud #ang { min-width: 4.5em; } /* e.g., -XXX.X° */
      #topHud #zread { min-width: 10em; } /* e.g., Q:XX.X/CO:±XXXXHz */
      #topHud #vswr { min-width: 3em; } /* e.g., XX.XX */
      #topHud #rl { min-width: 5em; } /* e.g., ±XX.XX dB */
      #topHud #yread { min-width: 8em; } /* e.g., R:X.X/D:0.00 */


      #dashboard {
          padding: 8px;
          gap: 6px;
          max-height: 60%;
      }
      .pill-group {
          padding: 0;
          min-width: 100%;
      }
      .pill-group-header {
        font-size: 14px;
        padding: 8px 12px;
      }
      .pill-group-content {
          padding: 8px;
          gap: 6px;
      }
      .pill {
          padding: 6px 10px;
          font-size: 13px;
      }
      .pill input[type="number"],
      .pill input[type="text"],
      .pill select,
      .pill input[type="range"] {
          font-size: 13px;
      }
      .pill input[type="range"] {
          height: 5px;
      }
      .pill input[type="range"]::-webkit-slider-thumb,
      .pill input[type="range"]::-moz-range-thumb {
          width: 20px;
          height: 20px;
          margin-top: -8px;
      }
      .pill-btn {
          padding: 6px 10px;
          font-size: 13px;
      }
      .waveform-pill label {
        font-size: 13px;
      }
      .waveform-pill input[type="radio"] {
          width: 14px;
          height: 14px;
      }
      .waveform-pill input[type="radio"]:checked::before {
          width: 9px;
          height: 9px;
      }
      #globalActionsBar {
          padding: 8px 6px;
          flex-wrap: nowrap; /* Keep global buttons on one line */
      }
      #globalActionsBar .pill-btn { /* Smaller font for global buttons on mobile */
          font-size: 16px;
          padding: 5px 8px;
      }
  }
</style>
</head>
<body>
  <div id="app">
    <canvas id="chart" aria-label="Interactive Smith Chart Musical Interface" role="img"></canvas>

    <!-- Smith Graph Stamp (from Snippet B) -->
    <div id="sgStamp">Smith Graph • puppet+vocoder • v0.5.0</div>

    <!-- Top HUD: Minimal Stats -->
    <div id="topHud">
      <div id="topLeftHud">
        <div class="pill" title="Reflection Coefficient Magnitude (0-1)"><div class="dot" style="background:var(--accent)"></div><span class="badge">Vol</span><b id="mag">0.000</b></div>
        <div class="pill" title="Phase Angle in degrees (-180° to 180°)"><div class="dot" style="background:var(--accent2)"></div><span class="badge">Phase</span><b id="ang">0.0°</b></div>
        <div class="pill" title="Filter Settings (Q / Cutoff Offset)"><span class="badge">Timbre</span><b id="zread">Q:00.0/CO:0000Hz</b></div>
      </div>
      <div id="topRightHud">
        <div class="pill" title="Standing Wave Ratio (1=pure tone, higher=more harmonics)"><div class="dot" style="background:var(--warn)"></div><span class="badge">Harm</span><b id="vswr">00.00</b></div>
        <div class="pill" title="Return Loss in dB (Sound Clarity / Damping)"><div class="dot" style="background:var(--bad)"></div><span class="badge">Clarity</span><b id="rl">±00.00 dB</b></div>
        <div class="pill" title="LFO Rate (Hz) / Depth (0-1)"><span class="badge">LFO</span><b id="yread">R:0.0/D:0.00</b></div>
      </div>
    </div>

    <div class="help" id="helpBox">
      <b>Smith Chart Musical Interface Quick Guide</b><br/>
      • Tap or click inside the circle to set the main sound's timbre. Drag to refine.<br/>
      • The 'L' dot indicates the primary sound (derived from Freq, Filter Q/Cutoff).<br/>
      • The 'S' dot shows the sound after Reverb effect.<br/>
      • The 'P' dot indicates the Puppet Mode sound.<br/>
      • Toggle <i>Comp. Timbre</i> to add a second voice.<br/>
      • The outer rings control the final volume trim for Synth (purple) and Radio (green).<br/>
      • <b>Puppet Mode</b>: Drives a chart point based on spectral features of an audio input (Mic, Radio, or Mix). This creates an additional synth voice.<br/>
      • <b>Vocoder</b>: Processes an audio source with a synthetic carrier, creating robotic/pitched effects. The carrier is a blend of your main synth and generated noise/saw.<br/>
      • <b>Learning Mode</b>: Demonstrates impedance matching transformations and musical sequences, visually represented on the chart.<br/>
      • <b>Share</b> copies a URL with your current sound settings.<br/>
      <div style="height:6px"></div>
      <span class="muted">Acoustic impedance matching is essential in musical instruments. The Smith Chart visualizes resonance (volume), harmonics (VSWR), and timbre (filter settings) based on your interactions.</span>
    </div>

    <!-- Dashboard (main control panel) -->
    <div id="dashboard">
      <!-- Group: Radio & Global Actions -->
      <div class="pill-group" id="radioGlobalGroup">
        <button class="pill-group-header" aria-expanded="true" aria-controls="radioGlobalContent"><h3>Radio & Global</h3><span class="icon">›</span></button>
        <div class="pill-group-content" id="radioGlobalContent">
          <div class="pill"><span class="badge">Radio • <span id="radioStatus">Stopped</span></span>
              <select id="radioSource">
                  <option value="off">Off</option>
                  <option value="https://ice4.somafm.com/groovesalad-128-mp3">SomaFM Groove Salad</option>
                  <option value="https://streams.ilovemusic.de/iloveradio1.mp3">I Love Radio</option>
                  <option value="https://stream.live.vc.bbcmedia.co.uk/bbc_radio_one">BBC R1</option>
                  <option value="custom-url">Custom URL...</option>
                  <option value="local-file">Local File…</option>
              </select>
          </div>
          <div id="customUrlInputContainer" class="pill" style="display:none;">
              <input type="text" id="dynamicRadioUrl" placeholder="Enter stream URL">
              <button class="pill-btn" id="loadCustomRadioBtn">Load</button>
          </div>
          <div class="pill"><span class="badge">Now Playing</span><b id="radioNow">—</b></div>
          <button class="pill-btn" id="micInputToggle">Mic Input OFF</button>
          <div class="pill"><span class="badge">Mic Gain</span><input id="inputGain" type="range" min="0" max="1" step="0.01" value="0.5"><b class="badge" id="inputGainRead">0.50</b></div>
          <button class="pill-btn" id="recordToggle">Record</button>
          <button class="pill-btn primary" id="share">Share</button>
        </div>
      </div>

      <!-- Group: Core Synth & FX -->
      <div class="pill-group" id="synthFXGroup">
        <button class="pill-group-header" aria-expanded="true" aria-controls="synthFXContent"><h3>Synth & FX</h3><span class="icon">›</span></button>
        <div class="pill-group-content" id="synthFXContent">
          <div class="pill"><span class="badge">Z₀ (Ref)</span><input id="z0" type="range" min="1" max="500" step="1" value="50"><b class="badge" id="z0Read">050</b></div>
          <div class="pill"><span class="badge">Base Freq</span><input id="freqHz" type="range" min="20" max="2000" step="1" value="440"><b class="badge" id="freqHzRead">0440 Hz</b></div>
          <div class="pill"><span class="badge">Base Cutoff</span><input id="baseCutoff" type="range" min="100" max="8000" step="10" value="2000"><b class="badge" id="baseCutoffRead">2000 Hz</b></div>
          <div class="pill"><span class="badge">Filter Q</span><input id="filterQ" type="range" min="0" max="100" step="0.1" value="1"><b class="badge" id="filterQRead">01.0</b></div>
          <div class="pill"><span class="badge">Cutoff Offset</span><input id="filterCutoffOffset" type="range" min="-2000" max="2000" step="1" value="0"><b class="badge" id="filterCutoffOffsetRead">±0000 Hz</b></div>
          <div class="pill"><span class="badge">LFO Rate</span><input id="lfoRate" type="range" min="0" max="20" step="0.1" value="0"><b class="badge" id="lfoRateRead">00.0 Hz</b></div>
          <div class="pill"><span class="badge">LFO Depth</span><input id="lfoDepth" type="range" step="0.01" min="0" max="1" value="0"><b class="badge" id="lfoDepthRead">0.00</b></div>
          <div class="pill"><span class="badge">Reverb Time</span><input id="delayTimeMs" type="range" min="0" max="2000" step="1" value="0"><b class="badge" id="delayTimeRead">0000 ms</b></div>
          <div class="pill"><span class="badge">Reverb FB</span><input id="delayFeedback" type="range" min="0" max="0.99" step="0.01" value="0.4"><b class="badge" id="delayFeedbackRead">0.40</b></div>
          <div class="pill waveform-pill">
              <span class="badge">Wave:</span>
              <label><input id="waveformSine" type="radio" name="waveform" value="sine" checked>Sine</label>
              <label><input id="waveformSquare" type="radio" name="waveform" value="square">Square</label>
              <label><input id="waveformSawtooth" type="radio" name="waveform" value="sawtooth">Saw</label>
              <label><input id="waveformTriangle" type="radio" name="waveform" value="triangle">Tri</label>
          </div>
          <button class="pill-btn checkbox-pill" id="showAdmitToggle" role="switch" aria-checked="false"><input id="showAdmit" type="checkbox">Comp. Timbre</button>
          <button class="pill-btn checkbox-pill" id="hiGridToggle" role="switch" aria-checked="true"><input id="hiGrid" type="checkbox" checked>Hi-detail Grid</button>
        </div>
      </div>

      <!-- Group: Blending & Listen -->
      <div class="pill-group" id="blendListenGroup">
        <button class="pill-group-header" aria-expanded="true" aria-controls="blendListenContent"><h3>Blending & Listen</h3><span class="icon">›</span></button>
        <div class="pill-group-content" id="blendListenContent">
          <div class="pill"><span class="badge">Blend Mode</span>
              <select id="blendMode">
                  <option value="crossfade">X-fade</option>
                  <option value="sum">Sum (Screen)</option>
                  <option value="multiply">Mult (AM)</option>
                  <option value="difference">Diff</option>
                  <option value="duck">Sidechain Duck</option>
              </select>
          </div>
          <div class="pill"><span class="badge">Blend Amount</span><input id="blendAmount" type="range" step="0.01" min="0" max="1" value="0.5"><b class="badge" id="blendAmountRead">0.50</b></div>
          <button class="pill-btn" data-listen-preset="mix" id="listenMix">Mix</button>
          <button class="pill-btn" data-listen-preset="radio" id="listenRadio">Radio</button>
          <button class="pill-btn" data-listen-preset="synth" id="listenSynth">Synth</button>
          <button class="pill-btn" id="autoMatch">Auto Match</button>
          <button class="pill-btn checkbox-pill" id="followToggleBtn" role="switch" aria-checked="false"><input type="checkbox" id="followToggle">Follow</button>
        </div>
      </div>

      <!-- NEW: Advanced FX (Puppet, Vocoder, Learning) -->
      <div class="pill-group" id="advancedFXGroup">
        <button class="pill-group-header" aria-expanded="true" aria-controls="advancedFXContent"><h3>Advanced FX</h3><span class="icon">›</span></button>
        <div class="pill-group-content" id="advancedFXContent">
          <button class="pill-btn" id="puppetToggle">Puppet Mode OFF</button>
          <button class="pill-btn" id="vocoderToggle">Vocoder OFF</button>
          <div class="pill"><span class="badge">Vocoder Bands</span>
              <select id="vocoderBands">
                <option value="16">16 bands</option>
                <option value="24" selected>24 bands</option>
                <option value="32">32 bands</option>
              </select>
          </div>
          <button class="pill-btn" id="learningModeToggle">Learning Mode OFF</button>
        </div>
      </div>
    </div>

    <!-- Global Actions Bar (Always Visible, below canvas) -->
    <div id="globalActionsBar">
        <button class="pill-btn" id="helpBtn" title="Show Help">🛈</button>
        <button class="pill-btn" id="reset" title="Reset All Settings">⟲</button>
        <button class="pill-btn" id="fullscreenToggle" title="Toggle Fullscreen">⛶</button>
        <button class="pill-btn" id="hideMenuToggle" title="Hide/Show UI">▼</button>
    </div>
  </div>

  <!-- Learning overlay (from Snippet B) -->
  <div id="learningModeOverlay">
    <div id="learningModeContent">
      <button id="closeLearningMode">×</button>
      <h2>Learning Mode: Explore Impedance Concepts</h2>
      <p><strong>Impedance Matching Pathways:</strong> Drag a point, then click a pathway button to see the impedance transform.</p>
      <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-bottom:20px">
        <button data-path="lMatch">L-Match</button>
        <button data-path="stubTuner">Stub Tuner</button>
      </div>
      <p><strong>Musical Sequences:</strong></p>
      <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-bottom:20px">
        <button data-sequence="radialOut">Radial Out</button>
        <button data-sequence="circleSweep">Circle Sweep</button>
      </div>
    </div>
  </div>

<script>
(function(){
  const $ = sel=>document.querySelector(sel);
  const canvas = $('#chart');
  const ctx = canvas.getContext('2d');
  let DPR = Math.min(2, window.devicePixelRatio || 1);
  let W=0,H=0,CX=0,CY=0,R=0; // canvas sizing

  // Audio Context and Nodes
  let audioCtx;
  let osc, filter, masterGain, monitorGain, limiter; // Added limiter
  let synthAmplitudeGain; // Controls synth base volume by |Gamma| BEFORE LFO
  let lfo, lfoModulatorGain; // LFO and its depth modulator
  let synthChannelGain, radioChannelGain; // For blending amounts
  let dryMixer, delaySendGain, delayReturnGain; // For global dry/wet delay mix
  let mainOutputBus; // The bus where blended signals meet, before final masterGain and dry/wet delay

  let oscY, filterY; // for complementary timbre
  let delay, delayFeedbackGain;
  let isAudioReady = false;

  // Radio specific audio nodes
  let mediaEl = null, mediaNode = null;
  let radioFilter = null, radioPreGain = null, radioPanner = null;
  let radioEnabled = false;
  let localFileInput = null; // for local files

  // Mic Input
  let micInputEnabled = false;
  let micStream = null;
  let micInputSource, micAnalyserNode, micGainNode; // For mic input processing

  // Recording
  let isRecording = false;
  let mediaRecorder;
  let recordedChunks = [];
  let destinationStream;

  // Analysers for Blend Modes (Multiply) and Auto-Match & Spectrum Display
  let synthAnalyser, synthEnvelopeFollowerGain, synthEnvelopePrev = 0;
  let radioAnalyser, mixAnalyser;
  let phaseFlipperGain; // For Difference Blend Mode

  // Auto-Match/Follow
  let followTimer = null;

  // Puppet Mode (from Snippet B)
  let puppetOn = false;
  let puppetTimer = null;
  let puppetVoice = null; // The dedicated voice for puppet mode
  let puppetAnalyser = null; // Analyser for puppet mode's input
  let puppetGamma = {re: 0, im: 0}; // Stored gamma for puppet

  // Vocoder (from Snippet B)
  let vocoderOn = false;
  let voc = null; // Stores vocoder nodes and references
  let modulatorTapGain; // Common tap for vocoder modulator and puppet spectral analysis

  // Learning Mode (from Snippet B)
  let learningModeActive = false;
  let learningAnimation = null;
  let learningActivePoints = new Map(); // For learning mode animations

  // Constants
  const MAX_DELAY_MS = 2000; // Increased max delay for "Reverb Time"
  const LFO_MODULATION_SCALE = 0.5; // LFO goes -1 to 1, so depth * 0.5 gives +/- depth/2
  const SYNTH_ENV_SCALE = 2.0;
  const SYNTH_ENV_POWER = 0.6;
  const MIC_DEFAULT_GAIN = 0.5; // Adjusted to match snippet B's default
  const MAX_CUTOFF_OFFSET_RANGE_HZ = 4000; // Total range for cutoff offset (e.g., -2000 to +2000)
  const MIN_FREQ = 20;
  const MAX_FREQ = 20000;
  const MIN_Q = 0;
  const MAX_Q = 100;
  const AUDIO_MASTER_GAIN = 0.5;

  // State
  const state = {
    z0: 50, // Acoustic reference (analogous to characteristic impedance)
    freqHz: 440, // Base frequency in Hz
    baseCutoff: 2000, // New: Global base cutoff from Snippet B
    filterQ: 1, // Filter Q factor
    filterCutoffOffset: 0, // Filter cutoff offset from base freq
    lfoRate: 0, // LFO frequency in Hz
    lfoDepth: 0, // LFO gain modulation depth (0-1)
    delayTimeMs: 0, // Renamed to Reverb Time
    delayFeedback: 0.4, // Renamed to Reverb FB
    waveform: 'sine', // Oscillator waveform
    showAdmit: false, // Show complementary timbre
    hiGrid: true,
    blendMode: 'crossfade', // New: Blend mode (crossfade, sum, multiply, difference, duck)
    blendAmount: 0.5, // New: Blend amount (0-1)
    micInputEnabled: false,
    inputGain: MIC_DEFAULT_GAIN, // New: Mic input gain from Snippet B
    isRecording: false,
    autoMatchFollow: false,
    ringSynthTrim: 1.0, // 0..1, acts as a master trim for synth volume
    ringRadioTrim: 1.0, // 0..1, acts as a master trim for radio volume
    radioUrl: 'off', // Stores the last selected/custom radio URL
    // NEW Puppet/Vocoder/Learning
    puppetOn: false,
    vocoderOn: false,
    vocoderBands: 24, // Default vocoder bands
    learningModeActive: false, // New Learning Mode

    // user marker in Gamma plane (complex) — set by inputs or tapping
    gamma: {re: 0, im: 0},
    fromTap: false, // if the current state.gamma comes from user tapping (disables R/X input parsing)
    // UI state
    isDashboardHidden: false,
    collapsedGroups: {} // Store collapsed state for each pill group
  };

  // --- Rotary volume rings visual state ---
  let activeRing = null; // 'synth' | 'radio' | null
  let ringSynthAngle = 0; // 0..2π
  let ringRadioAngle = 0; // 0..2π
  const RING_DETENTS_COARSE = 36; // 10° steps
  const RING_DETENTS_FINE = 180; // 2° steps
  let ringSnapMode = 'coarse'; // 'coarse' | 'fine' | 'free'

  function syncRingAnglesFromTrims(){
    ringSynthAngle = 2*Math.PI * Math.max(0, Math.min(1, state.ringSynthTrim));
    ringRadioAngle = 2*Math.PI * Math.max(0, Math.min(1, state.ringRadioTrim));
  }
  // Initialize ring angles based on state (will be updated from hash/reset)
  syncRingAnglesFromTrims();

  // UI Elements
  const inputs = {
    z0: $('#z0'), z0Read: $('#z0Read'),
    freqHz: $('#freqHz'), freqHzRead: $('#freqHzRead'),
    baseCutoff: $('#baseCutoff'), baseCutoffRead: $('#baseCutoffRead'), // New
    filterQ: $('#filterQ'), filterQRead: $('#filterQRead'),
    filterCutoffOffset: $('#filterCutoffOffset'), filterCutoffOffsetRead: $('#filterCutoffOffsetRead'),
    lfoRate: $('#lfoRate'), lfoRateRead: $('#lfoRateRead'),
    lfoDepth: $('#lfoDepth'), lfoDepthRead: $('#lfoDepthRead'),
    delayTimeMs: $('#delayTimeMs'), delayFeedback: $('#delayFeedback'), // Renamed to Reverb
    delayTimeRead: $('#delayTimeRead'), delayFeedbackRead: $('#delayFeedbackRead'),
    blendMode: $('#blendMode'), blendAmount: $('#blendAmount'), blendAmountRead: $('#blendAmountRead'),
    mag: $('#mag'), ang: $('#ang'), vswr: $('#vswr'), rl: $('#rl'),
    zread: $('#zread'), yread: $('#yread'),
    waveformRadios: document.querySelectorAll('input[name="waveform"]'),
    showAdmit: $('#showAdmit'), showAdmitToggle: $('#showAdmitToggle'),
    hiGrid: $('#hiGrid'), hiGridToggle: $('#hiGridToggle'),
    reset: $('#reset'), share: $('#share'), help: $('#helpBox'), helpBtn: $('#helpBtn'),
    // Radio UI
    radioSource: $('#radioSource'),
    dynamicRadioUrl: $('#dynamicRadioUrl'),
    loadCustomRadioBtn: $('#loadCustomRadioBtn'),
    customUrlInputContainer: $('#customUrlInputContainer'),
    radioStatus: $('#radioStatus'),
    radioNow: $('#radioNow'),
    // Listen Presets & Auto Match
    listenMix: $('#listenMix'), listenRadio: $('#listenRadio'), listenSynth: $('#listenSynth'),
    autoMatch: $('#autoMatch'), followToggle: $('#followToggle'), followToggleBtn: $('#followToggleBtn'),
    // Action Buttons
    micInputToggle: $('#micInputToggle'), inputGain: $('#inputGain'), inputGainRead: $('#inputGainRead'), // New inputGain
    recordToggle: $('#recordToggle'),
    // New Interface Buttons
    fullscreenToggle: $('#fullscreenToggle'), hideMenuToggle: $('#hideMenuToggle'),
    // NEW Puppet/Vocoder/Learning
    puppetToggle: $('#puppetToggle'),
    vocoderToggle: $('#vocoderToggle'),
    vocoderBands: $('#vocoderBands'),
    learningModeToggle: $('#learningModeToggle'), learningModeOverlay: $('#learningModeOverlay'),
    closeLearningMode: $('#closeLearningMode'), learningModeContent: $('#learningModeContent'),
    // Collapsible group headers
    radioGlobalGroupHeader: $('#radioGlobalGroup button.pill-group-header'),
    synthFXGroupHeader: $('#synthFXGroup button.pill-group-header'),
    blendListenGroupHeader: $('#blendListenGroup button.pill-group-header'),
    advancedFXGroupHeader: $('#advancedFXGroup button.pill-group-header'), // New group
  };

  // --- Haptic Feedback ---
  function vibrate(pattern = 50) { // Default to a short, sharp vibration
    if (navigator.vibrate) {
      navigator.vibrate(pattern);
    }
  }

  // Complex helpers
  const C = {
    add: (a,b)=>({re:a.re+b.re, im:a.im+b.im}),
    sub: (a,b)=>({re:a.re-b.re, im:a.im-b.im}),
    mul: (a,b)=>({re:a.re*b.re - a.im*b.im, im:a.re*b.re + a.im*b.re}),
    div: (a,b)=>{ const d=b.re*b.re + b.im*b.im || 1e-18; return {re:(a.re*b.re + a.im*b.im)/d, im:(a.im*b.re - a.re*b.im)/d}; },
    conj:(a)=>({re:a.re, im:-a.im}),
    mag:(a)=>Math.hypot(a.re, a.im),
    ang:(a)=>Math.atan2(a.im, a.re),
    expj:(phi)=>({re:Math.cos(phi), im:Math.sin(phi)}),
  };

  // Mapping between normalized z and reflection coefficient gamma
  function z2g(z){ // z is {re, im}
    const num = C.sub(z, {re:1, im:0});
    const den = C.add(z, {re:1, im:0});
    return C.div(num, den);
  }
  function g2z(g){
    const num = C.add({re:1, im:0}, g);
    const den = C.sub({re:1, im:0}, g);
    return C.div(num, den);
  }

  function yFromZ(z){ // y = 1/z
    const den = z.re*z.re + z.im*z.im || 1e-18; return {re: z.re/den, im: -z.im/den};
  }

  // Coordinates
  function toPX(pt){ return {x: CX + R*pt.re, y: CY - R*pt.im}; }
  function fromPX(x,y){ return {re:(x-CX)/R, im:-(y-CY)/R}; }

  function resize(){
    const rect = canvas.getBoundingClientRect();
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.round(rect.width * DPR); H = Math.round(rect.height * DPR);
    canvas.width = W; canvas.height = H;
    canvas.style.width = rect.width + 'px'; canvas.style.height = rect.height + 'px';
    ctx.setTransform(1,0,0,1,0,0); ctx.scale(DPR,DPR);

    const dashboardElement = $('#dashboard');
    const globalActionsBar = $('#globalActionsBar');
    const topHudElement = $('#topHud');

    let dashboardHeight = 0;
    // Calculate dashboard height *only if it's visible*
    if (!dashboardElement.classList.contains('hidden')) {
      // Temporarily unset max-height to get natural height, then restore
      const originalMaxHeight = dashboardElement.style.maxHeight;
      dashboardElement.style.maxHeight = 'none';
      dashboardHeight = dashboardElement.offsetHeight;
      dashboardElement.style.maxHeight = originalMaxHeight; // Restore max-height
    }

    const globalActionsBarHeight = globalActionsBar.offsetHeight;
    const topHudHeight = topHudElement.offsetHeight + 12; // + top/bottom padding for spacing to chart

    // Adjust globalActionsBar position dynamically relative to dashboard
    globalActionsBar.style.bottom = `${dashboardHeight}px`;

    // Calculate available canvas height
    const availableCanvasHeight = rect.height - dashboardHeight - globalActionsBarHeight - topHudHeight;
    const availableCanvasWidth = rect.width;

    // Determine chart radius based on available space
    const padding = 16;
    const chartSize = Math.min(availableCanvasWidth, availableCanvasHeight) - padding * 2;
    R = chartSize / 2;

    // Position chart center within the available space
    CX = availableCanvasWidth / 2;
    CY = topHudHeight + (availableCanvasHeight / 2);

    // Adjust help box position
    const helpBox = inputs.help;
    if (helpBox) {
        helpBox.style.bottom = `${(state.isDashboardHidden ? globalActionsBarHeight : dashboardHeight + globalActionsBarHeight) + 12}px`;
    }

    draw();
  }

  // Grid drawing
  function drawGrid(){
    ctx.save();
    // Background gradient subtle
    const grad = ctx.createRadialGradient(CX, CY, R*0.1, CX, CY, R*1.2);
    grad.addColorStop(0, '#0b0c0f');
    grad.addColorStop(1, '#0a0c10');
    ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);

    // Clip to unit circle
    ctx.beginPath();
    ctx.arc(CX, CY, R, 0, Math.PI*2);
    ctx.clip();

    // minor grid
    const rMaj = [0,0.2,0.5,1,2,5];
    const xMaj = [0.2,0.5,1,2,5];
    const rMin = state.hiGrid ? [0.1,0.3,0.7,1.5,3,7] : [];
    const xMin = state.hiGrid ? [0.1,0.3,0.7,1.5,3,7] : [];

    // helper to draw circle in Gamma plane (center, radius) masked
    function circle(cx, cy, rr, lw, col){
      ctx.beginPath(); ctx.lineWidth = lw; ctx.strokeStyle = col; ctx.arc(CX + R*cx, CY - R*cy, R*rr, 0, Math.PI*2); ctx.stroke();
    }

    // constant resistance circles: center (r/(r+1),0), radius 1/(r+1)
    const colMin = getCSS('--grid');
    const colMaj = getCSS('--grid2');

    // draw minor first
    ctx.globalAlpha=.7;
    rMin.forEach(r=>{ circle(r/(r+1), 0, 1/(r+1), 1, colMin); });
    xMin.forEach(x=>{
      const rad = 1/Math.abs(x); const cy = 1/x; // centers at (1, 1/x)
      circle(1, cy, rad, 1, colMin);
      circle(1, -cy, rad, 1, colMin);
    });

    // major
    ctx.globalAlpha=1;
    rMaj.forEach((r,i)=>{ circle(r/(r+1), 0, 1/(r+1), 1.5, colMaj); });
    xMaj.forEach(x=>{
      const rad = 1/Math.abs(x); const cy = 1/x;
      circle(1, cy, rad, 1.5, colMaj);
      circle(1, -cy, rad, 1.5, colMaj);
    });

    // boundary
    ctx.globalAlpha=1; ctx.lineWidth=2; ctx.strokeStyle = 'rgba(255,255,255,.15)';
    ctx.beginPath(); ctx.arc(CX, CY, R, 0, Math.PI*2); ctx.stroke();

    // real axis
    ctx.lineWidth=1.5; ctx.strokeStyle='rgba(255,255,255,.18)';
    ctx.beginPath(); ctx.moveTo(CX - R, CY); ctx.lineTo(CX + R, CY); ctx.stroke();

    // labels (r, x)
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto'; ctx.fillStyle='rgba(255,255,255,.6)'; ctx.textAlign='center'; ctx.textBaseline='top';
    rMaj.forEach(r=>{
      const p = toPX({re: (r-1)/(r+1), im: 0}); // leftmost point on each r circle crosses real axis at ( (r-1)/(r+1), 0 )
      ctx.fillText('r='+r, p.x, CY+4);
    });
    ctx.textBaseline='bottom';
    xMaj.forEach(x=>{
      // Adjust label placement for better visibility
      const labelX = CX + R * 0.78; // Offset slightly from edge
      const labelYPos = CY - R * (1 / Math.abs(x)); // Position relative to current x arc
      const labelYNeg = CY + R * (1 / Math.abs(x));

      // Small adjustment for text baseline
      if (x > 0) { // Top arcs
        ctx.fillText('+j'+x, labelX, labelYPos - 4);
      } else { // Bottom arcs
        ctx.fillText('−j'+x, labelX, labelYNeg + 16);
      }
    });

    ctx.restore();
  }

  function getCSS(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }

  // Helper to convert CSS color var to rgba string for canvas
  function varToRgba(varName, alpha = 1){
    const color = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    const r = parseInt(color.slice(1,3),16), g = parseInt(color.slice(3,5),16), b = parseInt(color.slice(5,7),16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }

  // Calculate load gamma from inputs or tap
  function computeGammaFromInputs(){
    const z0 = state.z0;
    const filterQ = state.filterQ; // R equivalent
    const filterCutoffOffset = state.filterCutoffOffset; // X equivalent
    const z = {re: Math.max(0, filterQ/z0), im: filterCutoffOffset/z0}; // Normalize
    const g = z2g(z);
    return g;
  }

  function vswrFromMag(m){ return m>=0.999999 ? Infinity : (1+m)/(1-m); }
  function rlFromMag(m){ return m<=0 ? Infinity : -20*Math.log10(m); }

  function rotateGamma(g, delayTimeMs){ // Simulating delay by rotation. Angle is not direct λ here.
    const rotationFactor = delayTimeMs / MAX_DELAY_MS; // Normalize 0-1
    const phi = -2 * Math.PI * rotationFactor; // Rotate from 0 to -360 degrees
    const ej = C.expj(phi);
    return C.mul(g, ej);
  }

  // Draw points and guides
  function drawData(){
    // Determine gamma from either tap state or inputs
    const baseGamma = state.fromTap ? state.gamma : computeGammaFromInputs();
    // Save computed gamma back so stats reflect it if not from tap
    if (!state.fromTap) state.gamma = baseGamma;

    // Rotated gamma after delay effect
    const gSrc = rotateGamma(baseGamma, state.delayTimeMs);

    // Draw SWR circle
    const mag = C.mag(baseGamma);
    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = 1.5; ctx.setLineDash([6,6]); ctx.strokeStyle = `rgba(255,255,255,${0.25 * Math.max(0.2, mag)})`; // Opacity depends on mag
    const rSWR = R*mag; ctx.arc(CX, CY, rSWR, 0, Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);

    // Load point (Primary Sound)
    plotMarker(baseGamma, getCSS('--accent'), 4 + mag*4, 'L'); // Marker size scales with amplitude
    // Source point after delay
    if (state.delayTimeMs > 0) {
      plotMarker(gSrc, getCSS('--accent2'), 3 + mag*3, 'S');
    }

    // Admittance point (Complementary Timbre)
    if (state.showAdmit){
      const gY = {re: -baseGamma.re, im: -baseGamma.im};
      plotMarker(gY, '#fde68a', 3 + mag*3, 'Y');
    }

    // Puppet Voice point
    if (state.puppetOn && puppetVoice && puppetVoice.isPlaying()) {
      plotMarker(puppetGamma, getCSS('--neon-red'), 4 + C.mag(puppetGamma)*4, 'P');
    }

    // Learning mode points
    if (learningModeActive && learningActivePoints.size > 0) {
      learningActivePoints.forEach(p => {
        plotMarker(p.voice.getGamma(), getCSS('--neon-blue'), 4, ''); // Learning points are blue
      });
    }

    ctx.restore();

    // Stats for Top HUD - CRITICAL: FORMATTED FOR STABILITY
    const m = mag;
    const vs = vswrFromMag(m);
    const rl = rlFromMag(m);

    // Using formatValue for all HUD metrics to ensure fixed width and no jitter
    inputs.mag.textContent = formatValue(m, 0.001, { padInt: 1 }); // 0.XXX
    inputs.ang.textContent = `${formatValue(C.ang(baseGamma)*180/Math.PI, 0.1, { signed: true, padInt: 3 })}°`; // ±XXX.X°
    inputs.vswr.textContent = vs === Infinity ? '  ∞' : formatValue(vs, 0.01, { padInt: 2 }); // XX.XX (space for sign to align, but no sign)
    inputs.rl.textContent = rl === Infinity ? '  ∞ dB' : `${formatValue(rl, 0.01, { signed: true, padInt: 2 })} dB`; // ±XX.XX dB

    // Timbre & LFO for HUD
    const formattedQ = formatValue(state.filterQ, 0.1, { padInt: 2 }); // 00.0
    const formattedCO = formatValue(state.filterCutoffOffset, 1, { signed: true, padInt: 4 }); // ±0000
    inputs.zread.textContent = `Q:${formattedQ}/CO:${formattedCO}Hz`;

    const formattedLFORate = formatValue(state.lfoRate, 0.1, { padInt: 1 }); // 0.0
    const formattedLFODepth = formatValue(state.lfoDepth, 0.01, { padInt: 1 }); // 0.00
    inputs.yread.textContent = `R:${formattedLFORate}/D:${formattedLFODepth}`;
  }

  function plotMarker(g, color, r=3, label){
    const p = toPX(g);
    // guard: only plot inside unit circle
    if (C.mag(g) > 1.0001) return;
    ctx.beginPath(); ctx.fillStyle=color; ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
    // label
    if (label) {
      ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto'; ctx.textAlign='left'; ctx.textBaseline='middle';
      ctx.fillStyle='rgba(255,255,255,.8)';
      ctx.fillText(label, p.x+r+2, p.y);
    }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();
    drawData();
    drawRings();
    if(isAudioReady) drawSpectrumPanels(); // New: Draw spectrums
  }

  // New: Draw Spectrum Panels (from Snippet B)
  function drawSpectrumPanels(){
    const W=Math.min(260, canvas.width*0.32/DPR), H=60, gap=8; let ox=12, oy=12;
    drawSpectrumPanel(radioAnalyser,ox,oy,W,H,varToRgba('--neon-green',0.9)); oy+=H+gap;
    drawSpectrumPanel(synthAnalyser,ox,oy,W,H,varToRgba('--neon-purple',0.9)); oy+=H+gap;
    drawSpectrumPanel(mixAnalyser,  ox,oy,W,H,varToRgba('--neon-blue',0.9));
  }
  function drawSpectrumPanel(analyser,x,y,w,h,color){
    if(!analyser) return;
    const data=new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(data);
    ctx.save(); ctx.globalAlpha=0.9; ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(x,y,w,h); ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.strokeRect(x,y,w,h);
    ctx.beginPath(); const len=data.length, step=Math.max(1,Math.floor(len/w));
    for(let i=0;i<w;i++){ const idx=Math.min(len-1, i*step); const v=data[idx]/255; const yy=y + h - v*h; if(i===0) ctx.moveTo(x,yy); else ctx.lineTo(x+i,yy); }
    ctx.strokeStyle=color; ctx.lineWidth=1.5; ctx.stroke(); ctx.restore();
  }


  function drawRings(){
    // Draw rotary trim rings just outside the Smith chart
    const center = { x: CX, y: CY };
    const smithChartRadius = R;
    const ringInnerOffset = smithChartRadius * 0.08; // Gap between chart and first ring
    const ringBandWidth = 14;
    const ringSpacing = 10; // Space between rings

    const rSynthMid = smithChartRadius + ringInnerOffset + ringBandWidth/2;
    const rRadioMid = rSynthMid + ringBandWidth + ringSpacing + ringBandWidth/2;

    // Background bands
    ctx.beginPath(); ctx.arc(center.x, center.y, rSynthMid, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-purple', 0.2); ctx.lineWidth = ringBandWidth; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rRadioMid, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-green', 0.2); ctx.lineWidth = ringBandWidth; ctx.stroke();

    // Filled arcs indicating current trims
    ctx.beginPath(); ctx.arc(center.x, center.y, rSynthMid, 0, ringSynthAngle); ctx.strokeStyle = varToRgba('--neon-purple', 0.8); ctx.lineWidth = ringBandWidth; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rRadioMid, 0, ringRadioAngle); ctx.strokeStyle = varToRgba('--neon-green', 0.8); ctx.lineWidth = ringBandWidth; ctx.stroke();

    // Outer/inner outlines
    const rSynthInner = rSynthMid - ringBandWidth/2;
    const rSynthOuter = rSynthMid + ringBandWidth/2;
    const rRadioInner = rRadioMid - ringBandWidth/2;
    const rRadioOuter = rRadioMid + ringBandWidth/2;
    ctx.beginPath(); ctx.arc(center.x, center.y, rSynthInner, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-purple', 0.4); ctx.lineWidth = 2; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rSynthOuter, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-purple', 0.4); ctx.lineWidth = 2; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rRadioInner, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-green', 0.4); ctx.lineWidth = 2; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rRadioOuter, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-green', 0.4); ctx.lineWidth = 2; ctx.stroke();


    // Ticks and 10% labels
    const tickCount = 100, tickLen = 6;
    ctx.lineWidth = 2; ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto'; ctx.textAlign='center'; ctx.textBaseline='middle';
    for(let i=0;i<tickCount;i++){
      const a = i * (2*Math.PI/tickCount);
      const major10 = (i % 10 === 0);

      // Synth ticks (inward from outer edge of ring band)
      let x1s = center.x + (rSynthOuter - (major10?14:tickLen)) * Math.cos(a), y1s = center.y + (rSynthOuter - (major10?14:tickLen)) * Math.sin(a);
      let x2s = center.x + rSynthOuter * Math.cos(a), y2s = center.y + rSynthOuter * Math.sin(a);
      ctx.beginPath(); ctx.moveTo(x1s,y1s); ctx.lineTo(x2s,y2s); ctx.strokeStyle = varToRgba('--neon-purple', major10?0.5:0.25); ctx.stroke();

      // Radio ticks (outward from inner edge of ring band)
      let x1r = center.x + (rRadioInner + (major10?14:tickLen)) * Math.cos(a), y1r = center.y + (rRadioInner + (major10?14:tickLen)) * Math.sin(a);
      let x2r = center.x + rRadioInner * Math.cos(a), y2r = center.y + rRadioInner * Math.sin(a);
      ctx.beginPath(); ctx.moveTo(x1r,y1r); ctx.lineTo(x2r,y2r); ctx.strokeStyle = varToRgba('--neon-green', major10?0.5:0.25); ctx.stroke();

      if (major10){
        const label = `${i}%`;
        // Synth labels (inward from ring band)
        const lx1 = center.x + (rSynthOuter - 24) * Math.cos(a), ly1 = center.y + (rSynthOuter - 24) * Math.sin(a);
        ctx.fillStyle = varToRgba('--neon-purple', 0.8); ctx.fillText(label, lx1, ly1);

        // Radio labels (outward from ring band)
        const lx2 = center.x + (rRadioInner + 24) * Math.cos(a), ly2 = center.y + (rRadioInner + 24) * Math.sin(a);
        ctx.fillStyle = varToRgba('--neon-green', 0.8); ctx.fillText(label, lx2, ly2);
      }
    }

    // Handles
    const hsx = center.x + rSynthMid * Math.cos(ringSynthAngle);
    const hsy = center.y + rSynthMid * Math.sin(ringSynthAngle);
    const hrx = center.x + rRadioMid * Math.cos(ringRadioAngle);
    const hry = center.y + rRadioMid * Math.sin(ringRadioAngle);
    ctx.beginPath(); ctx.arc(hsx, hsy, 6, 0, Math.PI*2); ctx.fillStyle = varToRgba('--neon-purple', 0.9); ctx.shadowColor = varToRgba('--neon-purple',1); ctx.shadowBlur=12; ctx.fill(); ctx.shadowBlur=0;
    ctx.beginPath(); ctx.arc(hrx, hry, 6, 0, Math.PI*2); ctx.fillStyle = varToRgba('--neon-green', 0.9); ctx.shadowColor = varToRgba('--neon-green',1); ctx.shadowBlur=12; ctx.fill(); ctx.shadowBlur=0;

    // Numeric values
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
    ctx.fillStyle = varToRgba('--neon-purple', 1); ctx.fillText(`${Math.round(state.ringSynthTrim*100)}%`, hsx + 15*Math.cos(ringSynthAngle), hsy + 15*Math.sin(ringSynthAngle));
    ctx.fillStyle = varToRgba('--neon-green', 1); ctx.fillText(`${Math.round(state.ringRadioTrim*100)}%`, hrx + 15*Math.cos(ringRadioAngle), hry + 15*Math.sin(ringRadioAngle));
  }

  function updateRingFromPoint(which, dx, dy){
    const ang = Math.atan2(dy, dx); // -π..π
    let a = (ang>=0? ang : (2*Math.PI+ang)); // 0..2π
    let detCount = (ringSnapMode==='fine') ? RING_DETENTS_FINE : (ringSnapMode==='coarse' ? RING_DETENTS_COARSE : 0);
    let det = -1, snapped = a;
    if (detCount>0){ det = Math.round(a / (2*Math.PI/detCount)); snapped = det * (2*Math.PI/detCount); }

    if (which==='synth'){
      ringSynthAngle = snapped;
      state.ringSynthTrim = Math.max(0, Math.min(1, snapped/(2*Math.PI)));
    } else { // 'radio'
      ringRadioAngle = snapped;
      state.ringRadioTrim = Math.max(0, Math.min(1, snapped/(2*Math.PI)));
    }
  }

  // --- Web Audio API Integration ---
  // Envelope Follower for Multiply Blend Mode
  function getSynthEnv(){
    if (!synthAnalyser) return 0;
    const buffer = new Uint8Array(synthAnalyser.frequencyBinCount);
    synthAnalyser.getByteTimeDomainData(buffer);
    // RMS of centered signal
    let sum=0; for(let i=0;i<buffer.length;i++){ const v=(buffer[i]-128)/128; sum+=v*v; }
    let rms = Math.sqrt(sum/buffer.length); // 0..~1
    // scale up a bit and apply attack/release smoothing
    const raw = Math.min(1, rms * SYNTH_ENV_SCALE);
    const atk = 0.3;  // faster rise
    const rel = 0.08; // slower fall
    const a = raw > synthEnvelopePrev ? atk : rel;
    synthEnvelopePrev = synthEnvelopePrev + a*(raw - synthEnvelopePrev);
    return synthEnvelopePrev;
  }

  function initAudio() {
    if (isAudioReady) return;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      // Master gain (final output to speakers)
      masterGain = audioCtx.createGain();
      masterGain.gain.value = AUDIO_MASTER_GAIN; // Overall default output level

      // Add Limiter (from Snippet B)
      limiter = audioCtx.createDynamicsCompressor();
      limiter.threshold.value=-8; limiter.knee.value=12; limiter.ratio.value=2; limiter.attack.value=0.003; limiter.release.value=0.25;
      limiter.connect(masterGain);

      // Monitor path that can be toggled by parent mixer
      monitorGain = audioCtx.createGain();
      monitorGain.gain.value = 1.0; // monitor ON by default
      masterGain.connect(monitorGain);
      monitorGain.connect(audioCtx.destination);

      // For Recording
      destinationStream = audioCtx.createMediaStreamDestination();
      masterGain.connect(destinationStream);

      // Main Oscillator path
      osc = audioCtx.createOscillator();
      osc.type = state.waveform;
      osc.frequency.value = state.freqHz;
      osc.start();

      filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = state.freqHz;
      filter.Q.value = state.filterQ;
      osc.connect(filter);

      synthAmplitudeGain = audioCtx.createGain(); // Controls synth base volume by |Gamma| and LFO
      synthAmplitudeGain.gain.value = 0; // Will be set by updateAudioParameters
      filter.connect(synthAmplitudeGain);

      // --- LFO setup for additive tremolo ---
      lfo = audioCtx.createOscillator();
      lfo.type = 'sine'; // LFO typically sine for tremolo
      lfo.frequency.value = state.lfoRate;
      lfo.start();

      lfoModulatorGain = audioCtx.createGain(); // Scales LFO output by depth
      lfoModulatorGain.gain.value = state.lfoDepth * LFO_MODULATION_SCALE; // Initial value, will be updated
      lfo.connect(lfoModulatorGain); // LFO output goes to this gain node

      // Connect the LFO modulator output to *add* to synthAmplitudeGain's gain parameter
      lfoModulatorGain.connect(synthAmplitudeGain.gain);

      // Synth Analyser for Multiply Blend Mode & Spectrum Display
      synthAnalyser = audioCtx.createAnalyser();
      synthAnalyser.fftSize = 512;
      synthEnvelopeFollowerGain = audioCtx.createGain(); // For tap-off for envelope follower
      synthAmplitudeGain.connect(synthEnvelopeFollowerGain); // Tap from after LFO and Chart Amp
      synthEnvelopeFollowerGain.connect(synthAnalyser);

      synthChannelGain = audioCtx.createGain(); // Gain for blend control
      synthAmplitudeGain.connect(synthChannelGain); // Connect amplitude gain to blend channel

      // --- Radio specific audio nodes ---
      radioFilter = audioCtx.createBiquadFilter();
      radioFilter.type = 'lowpass';
      radioFilter.frequency.value = state.baseCutoff; // Connected to Base Cutoff slider
      radioFilter.Q.value = 0.707; // Flat response

      radioPreGain = audioCtx.createGain(); // Radio's independent volume control
      radioPreGain.gain.value = state.ringRadioTrim; // **Directly controlled by ring trim**

      radioPanner = audioCtx.createStereoPanner();
      radioPanner.pan.value = 0; // Centered

      // Radio Analyser for Auto Match & Spectrum Display
      radioAnalyser = audioCtx.createAnalyser();
      radioAnalyser.fftSize = 512;
      radioPreGain.connect(radioAnalyser); // Tap from after radioPreGain

      // Radio Chain: mediaNode -> radioFilter -> radioPreGain -> radioPanner
      // mediaNode connected in connectRadio()
      radioFilter.connect(radioPreGain);
      radioPreGain.connect(radioPanner);

      radioChannelGain = audioCtx.createGain(); // Gain for blend control
      radioPanner.connect(radioChannelGain);

      // Phase Flipper for Difference Blend Mode
      phaseFlipperGain = audioCtx.createGain();
      phaseFlipperGain.gain.value = 1; // Default to 1 (no inversion), set to -1 for difference mode


      // Main mix bus where synth, radio, puppet, vocoder signals are combined
      mainOutputBus = audioCtx.createGain();
      synthChannelGain.connect(mainOutputBus);
      // Radio channel connects via phaseFlipperGain to allow difference blending
      radioChannelGain.connect(phaseFlipperGain);
      phaseFlipperGain.connect(mainOutputBus);

      // Mix Analyser for Spectrum Display & Puppet Modulator Source
      mixAnalyser = audioCtx.createAnalyser();
      mixAnalyser.fftSize = 512;
      mainOutputBus.connect(mixAnalyser); // Tap from main mix

      // Global Dry/Wet Delay setup (Reverb)
      dryMixer = audioCtx.createGain();
      delaySendGain = audioCtx.createGain(); // How much of the blended signal goes to delay
      delayReturnGain = audioCtx.createGain(); // How much of the delayed signal comes back

      delay = audioCtx.createDelay(MAX_DELAY_MS / 1000); // Max 1 or 2 seconds delay
      delayFeedbackGain = audioCtx.createGain(); // Feedback loop for delay

      // Route mainOutputBus to dryMixer (dry path) and delaySendGain (wet path)
      mainOutputBus.connect(dryMixer);
      mainOutputBus.connect(delaySendGain);

      dryMixer.connect(limiter); // Dry signal goes to limiter (instead of masterGain directly)

      delaySendGain.connect(delay); // Send signal to delay unit
      delay.connect(delayFeedbackGain); // Delay output feeds back
      delayFeedbackGain.connect(delay); // Feedback loop
      delay.connect(delayReturnGain); // Delayed signal return
      delayReturnGain.connect(limiter); // Wet signal goes to limiter

      // Default values for delay (Reverb)
      delay.delayTime.value = state.delayTimeMs / 1000;
      delayFeedbackGain.gain.value = state.delayFeedback;


      // Complementary Timbre (oscY, filterY)
      oscY = audioCtx.createOscillator();
      oscY.type = state.waveform;
      oscY.frequency.value = state.freqHz * 1.005; // Slightly detuned
      oscY.start();

      filterY = audioCtx.createBiquadFilter();
      filterY.type = 'highpass'; // Different filter type for contrast
      filterY.frequency.value = state.freqHz * 0.9;
      filterY.Q.value = state.filterQ;
      oscY.connect(filterY);
      filterY.connect(limiter); // Connect complementary timbre to limiter


      // New: Modulator Tap Gain for Vocoder and Puppet (from Snippet B)
      modulatorTapGain = audioCtx.createGain();
      modulatorTapGain.gain.value = 1; // Default to 1, will be connected dynamically
      modulatorTapGain.connect(mixAnalyser); // Ensure mixAnalyser always gets input, also from mic/radio if they are mod sources.


      isAudioReady = true;
      console.log("AudioContext initialized with blend, global delay, limiter, and new FX buses!");
      updateAudioParameters(); // Set initial audio state
    } catch (e) {
      console.error("Web Audio API not supported or failed to initialize:", e);
      // Fallback or user notification here
    }
  }

  function updateAudioParameters() {
    if (!isAudioReady) return;

    // Use current state to derive gamma, then update audio params
    const baseGamma = state.fromTap ? state.gamma : computeGammaFromInputs();
    const mag = C.mag(baseGamma);

    // Apply mappings to main synth oscillator
    osc.type = state.waveform;
    osc.frequency.value = Math.max(MIN_FREQ, Math.min(MAX_FREQ, state.freqHz)); // Clamp frequency

    filter.Q.value = Math.min(MAX_Q, Math.max(MIN_Q, state.filterQ));
    filter.frequency.value = Math.min(MAX_FREQ, Math.max(MIN_FREQ, state.freqHz + state.filterCutoffOffset));

    // Update LFO frequency
    lfo.frequency.value = Math.min(20, Math.max(0, state.lfoRate));

    // Update LFO modulator gain to scale LFO output by state.lfoDepth
    lfoModulatorGain.gain.setValueAtTime(state.lfoDepth * LFO_MODULATION_SCALE, audioCtx.currentTime); // LFO goes from -1 to 1, so depth/2 for +/- range

    // Update synth base amplitude, scaled by ring trim.
    // The LFO will then *add* its scaled output to this base value.
    synthAmplitudeGain.gain.setValueAtTime(Math.min(1, Math.max(0, mag * state.ringSynthTrim)), audioCtx.currentTime);


    // Update global delay controls (Reverb)
    delay.delayTime.value = Math.min(MAX_DELAY_MS / 1000, Math.max(0, state.delayTimeMs / 1000));
    delayFeedbackGain.gain.value = Math.min(0.99, Math.max(0, state.delayFeedback));

    // Calculate dry/wet for the delay based on feedback amount
    const delayWetAmount = state.delayFeedback;
    delaySendGain.gain.value = (state.delayTimeMs > 0 && delayWetAmount > 0) ? 1 : 0; // Only send to delay if delay time & feedback > 0
    delayReturnGain.gain.value = delayWetAmount; // Wet mix controlled by feedback
    dryMixer.gain.value = 1 - delayWetAmount; // Dry mix is inverse

    // Complementary timbre logic
    if (state.showAdmit) {
      oscY.type = state.waveform;
      oscY.frequency.value = Math.max(MIN_FREQ, Math.min(MAX_FREQ, state.freqHz * 1.005));
      filterY.Q.value = Math.min(MAX_Q, Math.max(MIN_Q, state.filterQ));
      filterY.frequency.value = Math.min(MAX_FREQ, Math.max(MIN_FREQ, state.freqHz * 0.9));
      // Ensure it's connected and playing
      if (filterY.numberOfInputs < 1) oscY.connect(filterY); // Only connect if not already
      if (filterY.numberOfOutputs < 1) filterY.connect(limiter); // Only connect if not already
    } else {
      // Disconnect if not shown
      if (oscY.numberOfOutputs > 0) oscY.disconnect(filterY);
      if (filterY.numberOfOutputs > 0) filterY.disconnect(limiter);
    }

    // Update radio base gain (independent volume, controlled by ring trim)
    if (radioPreGain) radioPreGain.gain.value = state.ringRadioTrim;
    // Update radio filter cutoff with global baseCutoff
    if (radioFilter) radioFilter.frequency.value = state.baseCutoff;


    // --- Apply Blend Mode ---
    switch (state.blendMode) {
        case 'crossfade':
            synthChannelGain.gain.value = (1 - state.blendAmount);
            radioChannelGain.gain.value = state.blendAmount;
            phaseFlipperGain.gain.value = 1; // Ensure no phase inversion
            break;
        case 'sum': // Equivalent to Snippet B's 'screen'
            synthChannelGain.gain.value = 1; // Synth always at full (modulated by mag and LFO)
            radioChannelGain.gain.value = state.blendAmount; // Radio blended in
            phaseFlipperGain.gain.value = 1; // Ensure no phase inversion
            break;
        case 'multiply': { // AM Modulation: radio ducked by synth envelope
            const synthEnv = getSynthEnv();
            const modulationFactor = Math.pow(synthEnv, SYNTH_ENV_POWER); // Perceptual emphasis
            const modulatedRadioGain = ((1 - state.blendAmount) + state.blendAmount * (modulationFactor));
            radioChannelGain.gain.setValueAtTime(modulatedRadioGain, audioCtx.currentTime);
            synthChannelGain.gain.value = 1; // Synth always at full
            phaseFlipperGain.gain.value = 1; // Ensure no phase inversion
            break;
        }
        case 'difference':
            synthChannelGain.gain.value = 1;
            radioChannelGain.gain.value = state.blendAmount;
            phaseFlipperGain.gain.value = -1; // Invert phase of radio
            break;
        case 'duck': { // New blend mode from Snippet B
            const synthEnv = getSynthEnv();
            const depth = Math.pow(state.blendAmount, 0.5); // Deeper duck for higher blend amount
            const duckFactor = Math.max(0, 1 - depth * Math.pow(synthEnv, 0.6));
            radioChannelGain.gain.setValueAtTime(duckFactor, audioCtx.currentTime);
            synthChannelGain.gain.value = 1;
            phaseFlipperGain.gain.value = 1;
            break;
        }
        default: // Default to crossfade if unknown
            synthChannelGain.gain.value = 1 - state.blendAmount;
            radioChannelGain.gain.value = state.blendAmount;
            phaseFlipperGain.gain.value = 1;
            break;
    }

    // Mic Gain update
    if (micGainNode) micGainNode.gain.value = state.inputGain;

    // Update Puppet and Vocoder state
    if (state.puppetOn && !puppetTimer) startPuppet();
    else if (!state.puppetOn && puppetTimer) stopPuppet();

    if (state.vocoderOn && !voc) buildVocoder(state.vocoderBands);
    else if (!state.vocoderOn && voc) updateVocoder(); // If vocoder is on, update internal parameters
  }

  // --- Voice Class from Snippet B ---
  class Voice{
    constructor(re,im){
      this.re=re; this.im=im; // Store gamma components directly
      this.osc=audioCtx.createOscillator();
      this.filter=audioCtx.createBiquadFilter();
      this.gain=audioCtx.createGain();
      this.isPlayingFlag = true;

      this.osc.connect(this.filter); this.filter.connect(this.gain); this.gain.connect(mainOutputBus); // Connect to main bus
      this.osc.type='sine'; this.filter.type='lowpass'; this.osc.start();
      this.updateParameters(re,im);
    }
    updateParameters(nx,ny){
      this.re = nx; this.im = ny; // Update stored gamma
      const r=Math.sqrt(nx*nx+ny*ny), angle=Math.atan2(ny,nx);

      const pitchRange=2; const freq = state.freqHz*Math.pow(2, ny*pitchRange); // Use state.freqHz as base
      this.osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

      const cutoffRange=0.8; let cutoff=state.baseCutoff*(1+nx*cutoffRange); cutoff=Math.max(50, Math.min(audioCtx.sampleRate/2, cutoff));
      this.filter.frequency.setValueAtTime(cutoff, audioCtx.currentTime);

      const minG=0.05, maxG=0.5; const g=minG + r*(maxG-minG); this.gain.gain.setValueAtTime(g, audioCtx.currentTime);
      const q=0.5 + r*(10-0.5); this.filter.Q.setValueAtTime(q, audioCtx.currentTime);

      const numH=16, real=new Float32Array(numH+1), imag=new Float32Array(numH+1);
      real[0]=0; imag[0]=0; real[1] = 1 - r*0.5;
      for(let i=2;i<=numH;i++){ const amp=r*(1/(i*i)), ph=angle*i/Math.PI; real[i]=amp*Math.cos(ph); imag[i]=amp*Math.sin(ph); }
      if(r>0.8){ for(let i=2;i<=numH;i++){ if(i%2){ const add=(r-0.8)*(1/i); const ph=angle*i/Math.PI; real[i]+=add*Math.cos(ph); imag[i]+=add*Math.sin(ph);} } }
      const wave=audioCtx.createPeriodicWave(real,imag,{disableNormalization:false}); this.osc.setPeriodicWave(wave);
    }
    getGamma(){ return {re: this.re, im: this.im}; }
    isPlaying(){ return this.isPlayingFlag; }
    stop(){
      try{ this.osc.stop(); }catch{}
      try{ this.osc.disconnect(); this.filter.disconnect(); this.gain.disconnect(); }catch{}
      this.isPlayingFlag = false;
    }
  }


  // --- Radio Controls Functions ---
  let customUrlOption = document.createElement('option');
  customUrlOption.value = 'custom-loaded';
  customUrlOption.textContent = 'Custom Stream (Loaded)';
  customUrlOption.style.display = 'none';

  function setRadioStatus(text){ inputs.radioStatus.textContent = text; }
  function hostnameOf(u){ try{ return new URL(u).hostname; }catch{ return ''; } }
  function isBlockedUrl(u){ try{ const h=new URL(u).hostname.replace(/^www\./,''); return h.endsWith('youtube.com')||h.endsWith('youtu.be')||h.endsWith('vimeo.com'); }catch{ return false; } }

  function connectRadio(url){
      if (!isAudioReady) initAudio(); // Ensure audio context is initialized
      disconnectRadio();
      if (!url || url === 'off'){
          setRadioStatus('Stopped');
          radioEnabled=false;
          state.radioUrl = 'off'; // Update state
          inputs.radioSource.value = 'off';
          inputs.radioNow.textContent = '—';
          inputs.customUrlInputContainer.style.display = 'none';
          if (inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
              inputs.radioSource.removeChild(customUrlOption);
          }
          try{ if(localFileInput) localFileInput.value = ''; }catch{} // Clear local file input
          // Disconnect modulator tap from mic if no other source
          if(modulatorTapGain && micInputSource && micInputSource.numberOfOutputs > 0) micInputSource.disconnect(modulatorTapGain);
          return;
      }
      if (isBlockedUrl(url)){
          setRadioStatus('Blocked by CORS policy (YouTube/Vimeo likely)');
          alert('YouTube/Vimeo URLs are typically blocked by browser security policies (CORS). Please use direct MP3/AAC stream links.');
          state.radioUrl = 'off'; // Update state
          inputs.radioSource.value = 'off';
          inputs.radioNow.textContent = '—';
          return;
      }

      mediaEl = new Audio();
      mediaEl.crossOrigin='anonymous'; // Crucial for Web Audio API analysis/processing
      mediaEl.src = url;
      mediaEl.loop = true;
      mediaEl.preload='none';

      mediaEl.addEventListener('error', (e)=> {
          console.error('Media element error:', e);
          setRadioStatus('Error loading stream');
          state.radioUrl = 'off'; // Update state
          inputs.radioSource.value = 'off';
          inputs.radioNow.textContent = '—';
      });
      mediaEl.addEventListener('waiting', ()=> setRadioStatus('Buffering…'));
      mediaEl.addEventListener('stalled', ()=> setRadioStatus('Buffering…'));
      mediaEl.addEventListener('playing', ()=> setRadioStatus('Playing'));
      mediaEl.addEventListener('pause', ()=> setRadioStatus('Paused'));

      // Connect media element to audio graph
      mediaNode = audioCtx.createMediaElementSource(mediaEl);
      mediaNode.connect(radioFilter);
      // Connect radio to modulator tap
      if(modulatorTapGain && radioPanner) radioPanner.connect(modulatorTapGain);


      inputs.radioNow.textContent = hostnameOf(url) || 'Stream';
      state.radioUrl = url; // Update state with the playing URL

      mediaEl.play().then(() => {
          radioEnabled = true;
          // If a custom URL was just loaded, set the dropdown to reflect it
          if (url === inputs.dynamicRadioUrl.value && inputs.dynamicRadioUrl.value !== '') {
              if (!inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
                  inputs.radioSource.appendChild(customUrlOption);
              }
              customUrlOption.style.display = 'block';
              inputs.radioSource.value = 'custom-loaded';
              inputs.customUrlInputContainer.style.display = 'none'; // Hide custom input after successful load
          }
      }).catch((e)=>{
          console.warn('[Radio] Autoplay failed or stream error:', e);
          setRadioStatus('Error: Play failed/blocked (CORS?)');
          radioEnabled = false;
          state.radioUrl = 'off'; // Update state on failure
          // If custom URL failed, keep custom input visible for retry
          if (url === inputs.dynamicRadioUrl.value) {
              inputs.customUrlInputContainer.style.display = 'flex';
          }
          inputs.radioSource.value = 'off';
          inputs.radioNow.textContent = '—';
          // Disconnect modulator tap from radio if it's the source
          if(modulatorTapGain && radioPanner && radioPanner.numberOfOutputs > 0) radioPanner.disconnect(modulatorTapGain);
      });
  }

  function disconnectRadio(){
      try{ if (mediaEl){ mediaEl.pause(); mediaEl.src=''; } }catch{}
      try{ if (mediaNode){ mediaNode.disconnect(); } }catch{}
      try{ if(modulatorTapGain && radioPanner && radioPanner.numberOfOutputs > 0) radioPanner.disconnect(modulatorTapGain); }catch{} // Disconnect modulator tap
      mediaEl=null; mediaNode=null; radioEnabled=false;
      state.radioUrl = 'off'; // Update state
      if (inputs.radioSource.value === 'custom-loaded') {
          // If a custom stream was active, revert to "Add Custom Stream URL..." visually
          inputs.radioSource.value = 'custom-url';
          inputs.customUrlInputContainer.style.display = 'flex'; // Show input field for re-entry
      }
      setRadioStatus('Stopped');
      inputs.radioNow.textContent = '—';
  }

  inputs.radioSource.addEventListener('change', (e)=>{
      vibrate();
      initAudio(); // Ensure audio context is initialized
      const selectedValue = e.target.value;

      if (selectedValue === 'off'){
          disconnectRadio();
      } else if (selectedValue === 'custom-url'){
          // Show custom URL input field
          inputs.customUrlInputContainer.style.display = 'flex';
          inputs.dynamicRadioUrl.value = state.radioUrl === 'off' ? '' : state.radioUrl; // Pre-fill if custom URL was previously loaded
          inputs.dynamicRadioUrl.focus();
          setRadioStatus('Enter stream URL');
          // If custom-loaded option exists, remove it when user opts to add a new custom URL
          if (inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
              inputs.radioSource.removeChild(customUrlOption);
          }
          state.radioUrl = 'off'; // No specific URL active yet
          try{ if(localFileInput) localFileInput.value = ''; }catch{} // Clear local file input
      } else if (selectedValue === 'local-file'){ // New: Local file logic
        if(!localFileInput){ // Create the hidden input if it doesn't exist
            localFileInput=document.createElement('input'); localFileInput.type='file'; localFileInput.accept='audio/*'; localFileInput.style.display='none'; document.body.appendChild(localFileInput);
            localFileInput.addEventListener('change', ()=>{
                const f=localFileInput.files?.[0];
                if(!f) { disconnectRadio(); return; }
                const url=URL.createObjectURL(f);
                connectRadio(url);
                inputs.radioNow.textContent=`Local: ${f.name}`;
                inputs.customUrlInputContainer.style.display = 'none';
                state.radioUrl = url; // Update state with local URL
                // Add a "Local File (Loaded)" option dynamically
                if (!inputs.radioSource.querySelector(`option[value="local-file-loaded"]`)) {
                    const localLoadedOption = document.createElement('option');
                    localLoadedOption.value = 'local-file-loaded';
                    localLoadedOption.textContent = 'Local File (Loaded)';
                    inputs.radioSource.appendChild(localLoadedOption);
                }
                inputs.radioSource.value = 'local-file-loaded';
            });
        }
        localFileInput.click();
        inputs.customUrlInputContainer.style.display = 'none';
        state.radioUrl = 'off'; // Clear current radio state until file is chosen
      } else if (selectedValue === 'custom-loaded' || selectedValue === 'local-file-loaded') {
          // This option means a custom stream is currently playing/loaded.
          // If user selects it from dropdown, just ensure custom input is visible in case they want to modify/reload.
          // Or if local file, just ensure it's still playing/connected.
          inputs.customUrlInputContainer.style.display = 'flex';
          inputs.dynamicRadioUrl.value = state.radioUrl; // Should be pre-filled from state
          inputs.dynamicRadioUrl.focus();
          // The stream should already be connected. If not, connect again using the URL from state.
          if (!mediaEl || !mediaNode) {
              connectRadio(state.radioUrl);
          }
      } else {
          // A predefined stream is selected
          inputs.customUrlInputContainer.style.display = 'none';
          if (inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
              inputs.radioSource.removeChild(customUrlOption); // Remove "Custom Stream (Loaded)"
          }
          if (inputs.radioSource.querySelector(`option[value="local-file-loaded"]`)) {
              inputs.radioSource.querySelector(`option[value="local-file-loaded"]`).remove(); // Remove "Local File (Loaded)"
          }
          try{ if(localFileInput) localFileInput.value = ''; }catch{} // Clear local file input
          connectRadio(selectedValue);
      }
      updateAudioParameters(); // Ensure blend/volume applies immediately
      updateHash(false); // Update hash for radio source
  });

  inputs.loadCustomRadioBtn.addEventListener('click', () => {
      vibrate();
      const url = inputs.dynamicRadioUrl.value.trim();
      if (url) {
          console.log('[Radio] Loading custom URL:', url);
          connectRadio(url);
          // Set dropdown to custom-loaded after successful load
          if (!inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
              inputs.radioSource.appendChild(customUrlOption);
          }
          customUrlOption.style.display = 'block';
          inputs.radioSource.value = 'custom-loaded';
          inputs.customUrlInputContainer.style.display = 'none';
          updateHash(false);
      } else {
          setRadioStatus('Please enter a URL');
      }
  });

  // --- Mic Input Logic ---
  inputs.micInputToggle.addEventListener('click', async () => {
    vibrate();
    initAudio();
    state.micInputEnabled = !state.micInputEnabled;

    if (state.micInputEnabled) {
      try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        inputs.micInputToggle.classList.add('active');
        inputs.micInputToggle.textContent = 'Mic Input ON';

        micInputSource = audioCtx.createMediaStreamSource(micStream);
        micAnalyserNode = audioCtx.createAnalyser(); micAnalyserNode.fftSize = 2048;
        micGainNode = audioCtx.createGain(); micGainNode.gain.value = state.inputGain;

        micInputSource.connect(micGainNode); // Mic input -> Gain
        micGainNode.connect(modulatorTapGain); // Gain -> Modulator tap for puppet/vocoder
        micGainNode.connect(limiter); // Also directly connect to main output for monitoring (through limiter)
        console.log('Microphone input enabled.');
      } catch (err) {
        console.error('Error accessing microphone:', err);
        alert('Could not access microphone. Please ensure permissions are granted.');
        state.micInputEnabled = false;
        inputs.micInputToggle.textContent = 'Mic Input OFF';
        inputs.micInputToggle.classList.remove('active');
      }
    } else {
      if (micStream) {
        micStream.getTracks().forEach(track => track.stop());
        micInputSource.disconnect();
        micGainNode.disconnect();
        // micAnalyserNode?.disconnect(); // Disconnect if it exists and was connected
        micStream = null;
      }
      inputs.micInputToggle.textContent = 'Mic Input OFF';
      inputs.micInputToggle.classList.remove('active');
      console.log('Microphone input disabled.');
    }
    updateHash(false);
    updateModulatorSource(); // Update vocoder/puppet source
  });

  // --- Recording Logic ---
  inputs.recordToggle.addEventListener('click', () => {
    vibrate();
    initAudio();
    state.isRecording = !state.isRecording;

    if (state.isRecording) {
      recordedChunks = [];
      const options = { mimeType: 'audio/webm; codecs=opus' };
      try {
        mediaRecorder = new MediaRecorder(destinationStream.stream, options);
      } catch (e) {
        console.error('MediaRecorder creation failed:', e);
        alert('Recording is not supported in this browser or an error occurred.');
        state.isRecording = false;
        return;
      }

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) recordedChunks.push(event.data);
      };

      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        document.body.appendChild(a);
        a.style.display = 'none';
        a.href = url;
        a.download = `smith_chart_sonifier_${new Date().toISOString()}.webm`;
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        recordedChunks = [];
        console.log('Recording saved.');
      };

      mediaRecorder.start();
      inputs.recordToggle.textContent = 'Recording...';
      inputs.recordToggle.classList.add('recording');
      console.log('Recording started.');
    } else {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
      inputs.recordToggle.textContent = 'Record';
      inputs.recordToggle.classList.remove('recording');
      console.log('Recording stopped.');
    }
    updateHash(false);
  });

  // --- Auto Match / Follow Logic ---
  function getRadioPeakHz(){
    try {
      if (!radioAnalyser || !audioCtx) return null;
      const data = new Uint8Array(radioAnalyser.frequencyBinCount);
      radioAnalyser.getByteFrequencyData(data);
      let maxV=0,maxI=0; for(let i=0;i<data.length;i++){ if(data[i]>maxV){maxV=data[i];maxI=i;} }
      return (maxI/data.length)*(audioCtx.sampleRate/2);
    } catch { return null; }
  }
  function autoMatchOnce(){
    vibrate();
    if (!radioEnabled || !radioAnalyser) return; // Only if radio is playing
    const hz = getRadioPeakHz(); if(!hz || hz<50) return;
    const freq = Math.max(MIN_FREQ, Math.min(1000, Math.round(hz)));
    state.freqHz = freq; inputs.freqHz.value = freq; inputs.freqHzRead.textContent = `${formatValue(freq, inputs.freqHz.step, { padInt: 4 })} Hz`;
    const cutoff = Math.max(100, Math.min(8000, Math.round(hz*3)));
    state.filterCutoffOffset = cutoff - state.freqHz; // Adjust offset based on new base freq
    inputs.filterCutoffOffset.value = state.filterCutoffOffset; inputs.filterCutoffOffsetRead.textContent = `${formatValue(state.filterCutoffOffset, inputs.filterCutoffOffset.step, { signed: true, padInt: 4 })} Hz`;
    state.baseCutoff = cutoff; // Also adjust base cutoff
    inputs.baseCutoff.value = state.baseCutoff; inputs.baseCutoffRead.textContent = `${formatValue(state.baseCutoff, inputs.baseCutoff.step, { padInt: 4 })} Hz`;

    state.fromTap = false; // Parameters set by auto-match, not tap
    draw(); updateAudioParameters(); updateHash(false);
    inputs.autoMatch.classList.add('active'); // Temporarily highlight
    setTimeout(() => inputs.autoMatch.classList.remove('active'), 200);
  }
  function setFollow(on){
    if(followTimer){clearInterval(followTimer);followTimer=null;}
    if(on){
      followTimer=setInterval(autoMatchOnce, 2000);
      inputs.followToggleBtn.classList.add('active'); // Update toggle button
      inputs.followToggleBtn.setAttribute('aria-checked', true);
    } else {
      inputs.followToggleBtn.classList.remove('active'); // Update toggle button
      inputs.followToggleBtn.setAttribute('aria-checked', false);
    }
    state.autoMatchFollow = on;
    updateHash(false);
  }
  inputs.autoMatch.addEventListener('click', autoMatchOnce);
  // Event for checkbox inside the pill-btn
  inputs.followToggle.addEventListener('change', e => { vibrate(); setFollow(e.target.checked); });
  // Event for the pill-btn itself
  inputs.followToggleBtn.addEventListener('click', () => {
      inputs.followToggle.checked = !inputs.followToggle.checked;
      vibrate();
      setFollow(inputs.followToggle.checked);
  });

  // --- Puppet Mode (from Snippet B) ---
  function spectralFeatures(analyserNode){
    if(!analyserNode || !audioCtx) return {centroid:0, energy:0};
    const data = new Uint8Array(analyserNode.frequencyBinCount);
    analyserNode.getByteFrequencyData(data);
    let num=0, den=0, sum=0;
    for(let i=0; i<data.length; i++){
      const mag = data[i];
      const freq = (i / data.length) * (audioCtx.sampleRate / 2); // Frequency in Hz
      num += freq * mag;
      den += mag;
      sum += mag;
    }
    if (den < 1) return {centroid:0, energy:0};
    return {centroid:num/den, energy:sum/(255 * data.length)}; // Energy normalized 0-1
  }

  function featuresToGamma(feat){
    // Map spectral centroid to impedance X (imaginary part of gamma)
    const f = Math.max(50, Math.min(8000, feat.centroid || state.freqHz));
    // Normalize frequency to -1 to 1 range relative to baseCutoff, then apply tanh for smooth curve
    // Adjusted to use a more direct mapping to gamma, instead of impedance first
    const normX = Math.tanh((f - state.baseCutoff) / (state.baseCutoff * 0.6));

    // Map energy to impedance R (real part of gamma)
    const r = Math.min(0.95, 0.15 + 0.8 * (feat.energy || 0)); // Magnitude of gamma, 0.15-0.95

    // Map normX to angle
    const angle = (normX * 0.8 * Math.PI) + (0.12 * Math.sin(state.ringRadioTrim * 2 * Math.PI)); // Combine with radio ring for subtle movement

    return {re: r * Math.cos(angle), im: r * Math.sin(angle)};
  }

  function startPuppet(){
    if(puppetTimer) return;
    puppetAnalyser = audioCtx.createAnalyser();
    puppetAnalyser.fftSize = 512;
    // Disconnect any previous connections to modulatorTapGain
    try { modulatorTapGain.disconnect(puppetAnalyser); } catch (e) {}
    // Connect modulatorTapGain to puppetAnalyser.
    // The modulatorTapGain itself will be connected to mic/radio/mix based on current state.
    modulatorTapGain.connect(puppetAnalyser);

    puppetTimer = setInterval(()=>{
      if(!isAudioReady) return;
      if (!puppetAnalyser) return; // Should not happen after init

      const feat = spectralFeatures(puppetAnalyser);
      const g = featuresToGamma(feat);
      puppetGamma = g; // Update global puppetGamma for drawing

      if(!puppetVoice){
        puppetVoice = new Voice(g.re, g.im);
      } else {
        puppetVoice.updateParameters(g.re, g.im);
      }
    }, 33); // ~30 FPS
    console.log("Puppet Mode Started");
  }

  function stopPuppet(){
    if(puppetTimer){ clearInterval(puppetTimer); puppetTimer=null; }
    if(puppetVoice){ try{ puppetVoice.stop(); }catch{} puppetVoice=null; }
    if(puppetAnalyser){ try{ modulatorTapGain.disconnect(puppetAnalyser); }catch{} puppetAnalyser = null; }
    puppetGamma = {re:0, im:0}; // Reset puppet dot position
    console.log("Puppet Mode Stopped");
  }

  inputs.puppetToggle.addEventListener('click', ()=>{
    vibrate();
    initAudio(); // Ensure audio context is ready
    state.puppetOn = !state.puppetOn;
    inputs.puppetToggle.textContent = `Puppet Mode ${state.puppetOn?'ON':'OFF'}`;
    inputs.puppetToggle.classList.toggle('active', state.puppetOn);
    updateAudioParameters(); // This will call startPuppet/stopPuppet and update modulator source
    updateModulatorSource();
    updateHash(false);
  });


  // --- Vocoder (from Snippet B) ---
  function makeAbsCurve(len=1024){
    const c=new Float32Array(len);
    for(let i=0;i<len;i++){ const x = (i/(len-1))*2-1; c[i]=Math.abs(x); }
    return c;
  }

  function buildVocoder(bands=24){
    if(!isAudioReady) initAudio();
    destroyVocoder();

    const ctx=audioCtx, fmin=120, fmax=Math.min(6000, ctx.sampleRate/2-200);
    const edges=[]; for(let i=0;i<=bands;i++){ const t=i/bands; edges.push(fmin*Math.pow(fmax/fmin,t)); }

    // Carrier = Main Synth (modulated) + Saw + Noise -> LP (de-ess) -> per-band BP -> VCA -> sum
    const carrierBus = ctx.createGain(); carrierBus.gain.value=1;

    // Connect synthAmplitudeGain to carrierBus as part of the carrier source
    synthAmplitudeGain.connect(carrierBus);

    const saw=ctx.createOscillator(); saw.type='sawtooth'; saw.frequency.value=state.freqHz;
    const sawG=ctx.createGain(); sawG.gain.value=0.35; saw.connect(sawG).connect(carrierBus); saw.start();

    const noiseBuf=ctx.createBuffer(1, 2*ctx.sampleRate, ctx.sampleRate);
    const ch=noiseBuf.getChannelData(0); for(let i=0;i<noiseBuf.length;i++) ch[i]=Math.random()*2-1;
    const noise=ctx.createBufferSource(); noise.buffer=noiseBuf; noise.loop=true;
    const noiseBP=ctx.createBiquadFilter(); noiseBP.type='bandpass'; noiseBP.frequency.value=1200; noiseBP.Q.value=0.7;
    const noiseG=ctx.createGain(); noiseG.gain.value=0.65; noise.connect(noiseBP).connect(noiseG).connect(carrierBus); noise.start();

    const carrierLP=ctx.createBiquadFilter(); carrierLP.type='lowpass'; carrierLP.frequency.value=8000; carrierBus.connect(carrierLP);

    const absCurve=makeAbsCurve();
    const outGain=ctx.createGain(); outGain.gain.value=0.9;

    const bandNodes=[];
    for(let i=0;i<bands;i++){
      const f1=edges[i], f2=edges[i+1], fc=Math.sqrt(f1*f2), bw=f2-f1, q=Math.max(0.707, fc/bw);

      // Modulator envelope: bandpass -> |x| -> lowpass (envelope)
      const mBP=ctx.createBiquadFilter(); mBP.type='bandpass'; mBP.frequency.value=fc; mBP.Q.value=q;
      const rect=ctx.createWaveShaper(); rect.curve=absCurve;
      const envLP=ctx.createBiquadFilter(); envLP.type='lowpass'; envLP.frequency.value=35; envLP.Q.value=0.0001;
      const envScale=ctx.createGain(); envScale.gain.value=0.015; // scale envelope to musical range

      // Connect modulatorTapGain to the bandpass filter of the vocoder modulator
      modulatorTapGain.connect(mBP).connect(rect).connect(envLP).connect(envScale);

      // Carrier shaping
      const cBP=ctx.createBiquadFilter(); cBP.type='bandpass'; cBP.frequency.value=fc; cBP.Q.value=q;
      const vca=ctx.createGain(); vca.gain.value=0;

      carrierLP.connect(cBP).connect(vca).connect(outGain);

      // Baseline to avoid complete nulls & allow sum of multiple sources
      const base = ctx.createConstantSource(); base.offset.value=0.0008; base.connect(vca.gain); base.start();

      // Connect envelope (audio-rate) directly to AudioParam; sums with baseline
      envScale.connect(vca.gain);

      bandNodes.push({envLP, envScale, vca, cBP, mBP, base});
    }

    // Route vocoder output into your existing buses (main bus)
    outGain.connect(mainOutputBus);

    voc = {bands:bandNodes, carrierLP, saw, noise, out:outGain, modTap: modulatorTapGain, carrierBus};
    console.log("Vocoder Built");
    updateVocoder(); // Apply initial parameters
  }

  function destroyVocoder(){
    if(!voc) return;
    console.log("Destroying Vocoder");
    try{
      voc.out.disconnect(); voc.carrierLP.disconnect(); voc.carrierBus.disconnect();
      synthAmplitudeGain.disconnect(voc.carrierBus); // Disconnect synth from vocoder carrier
      voc.saw.stop(); voc.noise.stop();
      voc.bands.forEach(b=>{
        try{ b.base.stop(); }catch{}
        try{ modulatorTapGain.disconnect(b.mBP); }catch{} // Disconnect modulator tap
        [b.envLP,b.envScale,b.vca,b.cBP,b.mBP].forEach(n=>{try{n.disconnect();}catch{}});
      });
    }catch(e){ console.warn("Error destroying vocoder nodes:", e); }
    voc=null;
  }

  function updateVocoder(){
    if (!voc || !isAudioReady) return;
    // Update saw frequency if needed (tied to state.freqHz in buildVocoder)
    if(voc.saw) voc.saw.frequency.value = state.freqHz;
  }

  inputs.vocoderToggle.addEventListener('click', ()=>{
    vibrate();
    initAudio(); // Ensure audio context is ready
    state.vocoderOn = !state.vocoderOn;
    inputs.vocoderToggle.textContent = `Vocoder ${state.vocoderOn?'ON':'OFF'}`;
    inputs.vocoderToggle.classList.toggle('active', state.vocoderOn);
    updateAudioParameters(); // This will call buildVocoder/destroyVocoder and update modulator source
    updateModulatorSource();
    updateHash(false);
  });

  inputs.vocoderBands.addEventListener('change', ()=>{
    vibrate();
    state.vocoderBands = parseInt(inputs.vocoderBands.value,10);
    if(state.vocoderOn) buildVocoder(state.vocoderBands); // Rebuild vocoder with new bands
    updateHash(false);
  });

  // Determine and connect the primary modulator source for vocoder/puppet
  function updateModulatorSource() {
    if (!isAudioReady || !modulatorTapGain) return;

    // Disconnect all existing connections to modulatorTapGain first
    try { micGainNode?.disconnect(modulatorTapGain); } catch (e) {}
    try { radioPanner?.disconnect(modulatorTapGain); } catch (e) {}
    try { mainOutputBus?.disconnect(modulatorTapGain); } catch (e) {}

    // Now, connect the appropriate source
    if (state.micInputEnabled && micGainNode) {
      micGainNode.connect(modulatorTapGain);
      console.log("Modulator source: Mic");
    } else if (radioEnabled && radioPanner) {
      radioPanner.connect(modulatorTapGain);
      console.log("Modulator source: Radio");
    } else {
      mainOutputBus.connect(modulatorTapGain); // Fallback to main mix
      console.log("Modulator source: Main Mix (fallback)");
    }
  }


  // --- Learning Mode (from Snippet B) ---
  function clearLearningAnimation(){
    if(learningAnimation){ clearInterval(learningAnimation); learningAnimation=null; }
    learningActivePoints.forEach((pd)=>{ pd.voice.stop(); });
    learningActivePoints.clear();
    draw();
  }

  inputs.learningModeContent.addEventListener('click',(e)=>{
    if(e.target.tagName==='BUTTON'){
      vibrate();
      const p=e.target.dataset.path, s=e.target.dataset.sequence;
      if(p) runLearningPath(p);
      else if(s) runLearningSequence(s);
    }
  });

  function runLearningPath(type){
    clearLearningAnimation(); initAudio();
    let startGamma={re:0.8,im:0.5}; // Normalized gamma
    const voice=new Voice(startGamma.re,startGamma.im);
    learningActivePoints.set('learning',{voice:voice});
    let step=0, maxSteps=100;
    learningAnimation=setInterval(()=>{
      if(step>maxSteps){ clearLearningAnimation(); return; }
      let g;
      if(type==='lMatch'){ // Simplified L-Match (straight path to origin)
        const p=step/maxSteps;
        g={re:startGamma.re * (1-p), im:startGamma.im * (1-p)};
      } else { // Stub Tuner (circle sweep)
        const p=step/maxSteps;
        const ang = (Math.sin(p * Math.PI) * Math.PI * 0.5) + (p * 0.5 * Math.PI); // A more complex spiral/sweep
        const rad = 0.8 * (1 - p * 0.5); // Spiral inwards slightly
        g = {re: rad * Math.cos(ang), im: rad * Math.sin(ang)};
      }
      const a=learningActivePoints.get('learning');
      a.voice.updateParameters(g.re,g.im);
      draw(); step++;
    },50);
  }

  function runLearningSequence(type){
    clearLearningAnimation(); initAudio();
    let pts=[];
    if(type==='radialOut'){
      for(let i=0;i<=100;i++){ const r=i/100; pts.push({re:r*0.7, im:r*0.3}); }
    } else { // Circle Sweep
      for(let i=0;i<=100;i++){ const ang=(i/100)*2*Math.PI, r=0.7; pts.push({re:r*Math.cos(ang), im:r*Math.sin(ang)}); }
    }
    let k=0;
    const voice=new Voice(pts[0].re,pts[0].im);
    learningActivePoints.set('sequence',{voice:voice});
    learningAnimation=setInterval(()=>{
      if(k>=pts.length){ clearLearningAnimation(); return; }
      const g=pts[k];
      const a=learningActivePoints.get('sequence');
      a.voice.updateParameters(g.re,g.im);
      draw(); k++;
    }, 100);
  }

  inputs.learningModeToggle.addEventListener('click',()=>{
    vibrate();
    state.learningModeActive = !state.learningModeActive;
    inputs.learningModeToggle.textContent=`Learning Mode ${state.learningModeActive?'ON':'OFF'}`;
    inputs.learningModeToggle.classList.toggle('active',state.learningModeActive);
    inputs.learningModeOverlay.classList.toggle('active',state.learningModeActive);
    if (!state.learningModeActive) { clearLearningAnimation(); } // Clear animations when closing
    draw(); updateHash(false);
  });

  inputs.closeLearningMode.addEventListener('click',()=>{
    vibrate();
    state.learningModeActive=false;
    inputs.learningModeToggle.textContent='Learning Mode OFF';
    inputs.learningModeToggle.classList.remove('active');
    inputs.learningModeOverlay.classList.remove('active');
    clearLearningAnimation();
    draw(); updateHash(false);
  });


  // --- UI Event Handlers ---

  // Helper to format readout based on step
  const formatValue = (value, step, options = {}) => {
    const { signed = false, padInt = 0 } = options;
    if (value === null || value === undefined || isNaN(value)) {
        return signed ? ` ${'-'.repeat(padInt)}` : '-'.repeat(padInt);
    }

    // Determine precision from step
    let precision = 0;
    if (step !== undefined && step !== null && step.toString().includes('.')) {
        precision = step.toString().split('.')[1].length;
    }
    let formattedNum = parseFloat(value).toFixed(precision);

    // Handle sign and integer padding
    let signChar = '';
    let integerPart = formattedNum.split('.')[0];
    let decimalPart = formattedNum.split('.')[1] || '';

    if (integerPart.startsWith('-')) {
        signChar = '-';
        integerPart = integerPart.substring(1);
    } else if (signed && value > 0) {
        signChar = '+';
    } else if (signed) { // For 0 or negative values when `signed` is true, or just reserving space.
        signChar = ' '; // Pad with space if no sign needed but `signed` requests fixed sign width
    }

    // Pad integer part with leading zeros
    // padInt ensures minimum digits, not including the sign.
    integerPart = integerPart.padStart(padInt, '0');

    // Reconstruct the formatted string
    let finalFormatted = `${signChar}${integerPart}${decimalPart ? '.' + decimalPart : ''}`;

    return finalFormatted;
  };


  const sliderChangeHandler = (e, readout, unit = '', options = {}) => {
      vibrate(10); // Subtle haptic on slider movement
      const val = parseFloat(e.target.value) || 0;
      state[e.target.id] = val;
      if (readout) readout.textContent = `${formatValue(val, parseFloat(e.target.step), options)} ${unit}`.trim();
      state.fromTap = false;
      draw();
      updateAudioParameters();
      updateHash(false);
  };

  inputs.z0.addEventListener('input', (e) => sliderChangeHandler(e, inputs.z0Read, '', { padInt: 3 }));
  inputs.freqHz.addEventListener('input', (e) => sliderChangeHandler(e, inputs.freqHzRead, 'Hz', { padInt: 4 }));
  inputs.baseCutoff.addEventListener('input', (e) => sliderChangeHandler(e, inputs.baseCutoffRead, 'Hz', { padInt: 4 })); // New
  inputs.filterQ.addEventListener('input', (e) => sliderChangeHandler(e, inputs.filterQRead, '', { padInt: 2 }));
  inputs.filterCutoffOffset.addEventListener('input', (e) => sliderChangeHandler(e, inputs.filterCutoffOffsetRead, 'Hz', { signed: true, padInt: 4 }));
  inputs.lfoRate.addEventListener('input', (e) => sliderChangeHandler(e, inputs.lfoRateRead, 'Hz', { padInt: 1 }));
  inputs.lfoDepth.addEventListener('input', (e) => sliderChangeHandler(e, inputs.lfoDepthRead, '', { padInt: 1 }));
  inputs.delayTimeMs.addEventListener('input', (e) => sliderChangeHandler(e, inputs.delayTimeRead, 'ms', { padInt: 4 }));
  inputs.delayFeedback.addEventListener('input', (e) => sliderChangeHandler(e, inputs.delayFeedbackRead, '', { padInt: 1 }));
  inputs.blendAmount.addEventListener('input', (e) => sliderChangeHandler(e, inputs.blendAmountRead, '', { padInt: 1 }));
  inputs.inputGain.addEventListener('input', (e) => sliderChangeHandler(e, inputs.inputGainRead, '', { padInt: 1 })); // New


  inputs.blendMode.addEventListener('change', (e)=>{
      vibrate();
      state.blendMode = e.target.value;
      document.querySelectorAll('#dashboard [data-listen-preset]').forEach(btn => btn.classList.remove('active'));
      updateAudioParameters(); updateHash(false);
  });

  inputs.waveformRadios.forEach(radio => {
    radio.addEventListener('change', () => { vibrate(); state.waveform = radio.value; state.fromTap=false; draw(); updateAudioParameters(); updateHash(false); });
  });

  // Toggle button logic for checkboxes
  inputs.showAdmitToggle.addEventListener('click', () => {
    vibrate();
    inputs.showAdmit.checked = !inputs.showAdmit.checked;
    state.showAdmit = inputs.showAdmit.checked;
    inputs.showAdmitToggle.classList.toggle('active', state.showAdmit);
    inputs.showAdmitToggle.setAttribute('aria-checked', state.showAdmit);
    draw(); updateAudioParameters(); updateHash(false);
  });
  inputs.hiGridToggle.addEventListener('click', () => {
    vibrate();
    inputs.hiGrid.checked = !inputs.hiGrid.checked;
    state.hiGrid = inputs.hiGrid.checked;
    inputs.hiGridToggle.classList.toggle('active', state.hiGrid);
    inputs.hiGridToggle.setAttribute('aria-checked', state.hiGrid);
    draw(); updateHash(false);
  });


  // --- Listen Preset Buttons Logic ---
  document.querySelectorAll('#dashboard [data-listen-preset]').forEach(btn => {
    btn.addEventListener('click', () => {
      vibrate();
      initAudio();
      const preset = btn.dataset.listenPreset;
      let newBlendMode = state.blendMode;
      let newBlendAmount = state.blendAmount;

      document.querySelectorAll('#dashboard [data-listen-preset]').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      if (preset === 'mix') {
        newBlendMode = 'crossfade';
        newBlendAmount = 0.5;
      } else if (preset === 'radio') {
        newBlendMode = 'sum';
        newBlendAmount = 1.0;
        if (!radioEnabled && state.radioUrl === 'off') {
            connectRadio('https://ice4.somafm.com/groovesalad-128-mp3');
        } else if (!radioEnabled && state.radioUrl !== 'off') {
            connectRadio(state.radioUrl);
        }
      } else if (preset === 'synth') {
        newBlendMode = 'sum';
        newBlendAmount = 0.0;
      }

      state.blendMode = newBlendMode;
      state.blendAmount = newBlendAmount;
      inputs.blendMode.value = newBlendMode;
      inputs.blendAmount.value = newBlendAmount;
      inputs.blendAmountRead.textContent = formatValue(newBlendAmount, inputs.blendAmount.step);
      updateAudioParameters();
      updateHash(false);
    });
  });

  // --- Global Actions & Interface Controls ---
  inputs.reset.addEventListener('click', ()=>{
    vibrate();
    Object.assign(state,{
      z0:50, freqHz:440, baseCutoff:2000, filterQ:1, filterCutoffOffset:0, lfoRate:0, lfoDepth:0, delayTimeMs:0, delayFeedback:0.4,
      waveform:'sine', showAdmit:false, hiGrid:true, blendMode:'crossfade', blendAmount:0.5,
      micInputEnabled:false, inputGain:MIC_DEFAULT_GAIN, isRecording:false, autoMatchFollow:false,
      puppetOn:false, vocoderOn:false, vocoderBands:24, learningModeActive:false,
      ringSynthTrim: 1.0, ringRadioTrim: 1.0, // Reset ring trims
      radioUrl: 'off', // Reset radio URL
      gamma:{re:0,im:0}, fromTap:false,
      isDashboardHidden: false, // Reset dashboard visibility
      collapsedGroups: {} // Reset collapsed state for all groups
    });
    // Disconnect/stop all audio features
    disconnectRadio();
    if(state.micInputEnabled) inputs.micInputToggle.click(); // Toggle off mic
    if(isRecording) inputs.recordToggle.click(); // Stop recording
    setFollow(false); // Stop follow
    stopPuppet(); // Stop puppet mode
    destroyVocoder(); // Destroy vocoder
    clearLearningAnimation(); // Clear learning animations

    inputs.micInputToggle.classList.remove('active'); // Deactivate mic button
    inputs.recordToggle.classList.remove('recording'); // Deactivate record button
    inputs.puppetToggle.classList.remove('active');
    inputs.vocoderToggle.classList.remove('active');
    inputs.learningModeToggle.classList.remove('active');
    document.querySelectorAll('#dashboard [data-listen-preset]').forEach(b => b.classList.remove('active')); // Deactivate listen presets
    inputs.learningModeOverlay.classList.remove('active'); // Hide learning overlay

    // Clear localStorage for collapsed groups
    Object.keys(localStorage).forEach(key => {
        if (key.startsWith('pillGroup_')) localStorage.removeItem(key);
    });

    syncToUI(); draw(); updateAudioParameters(); updateHash(false);
  });

  inputs.share.addEventListener('click', ()=>{ vibrate(); const url = updateHash(true); navigator.clipboard?.writeText(url); flash('Copied shareable URL to clipboard'); });
  inputs.helpBtn.addEventListener('click', ()=>{ vibrate(); inputs.help.classList.toggle('show'); });

  inputs.fullscreenToggle.addEventListener('click', () => {
      vibrate();
      if (document.fullscreenElement) {
          document.exitFullscreen();
      } else {
          document.documentElement.requestFullscreen().catch(err => {
              console.error(`Error attempting to enable fullscreen: ${err.message} (${err.name})`);
              alert('Fullscreen not supported or allowed by your browser.');
          });
      }
  });

  inputs.hideMenuToggle.addEventListener('click', () => {
      vibrate();
      state.isDashboardHidden = !state.isDashboardHidden;
      $('#dashboard').classList.toggle('hidden', state.isDashboardHidden);
      inputs.hideMenuToggle.textContent = state.isDashboardHidden ? '▲' : '▼'; // Update glyph
      resize(); // Recalculate canvas size
      updateHash(false);
  });

  // --- Collapsible Group Logic ---
  const pillGroups = document.querySelectorAll('.pill-group');
  pillGroups.forEach(group => {
      const header = group.querySelector('.pill-group-header');
      const content = group.querySelector('.pill-group-content');
      const groupId = group.id;

      // Set initial ARIA attributes
      header.setAttribute('id', `${groupId}Header`);
      content.setAttribute('id', `${groupId}Content`);
      header.setAttribute('aria-controls', `${groupId}Content`);

      header.addEventListener('click', () => {
          vibrate();
          const isCollapsed = !group.classList.contains('collapsed'); // Determine new state
          group.classList.toggle('collapsed', isCollapsed);
          header.setAttribute('aria-expanded', !isCollapsed);
          state.collapsedGroups[groupId] = isCollapsed;
          localStorage.setItem(`pillGroup_${groupId}_collapsed`, isCollapsed);
          resize(); // Recalculate dashboard height after collapse/expand
      });
  });


  // --- Sync UI with State ---
  function syncToUI(){
    // Sliders & Number inputs (using formatValue with specific padInt/signed for stability)
    inputs.z0.value = state.z0; inputs.z0Read.textContent = formatValue(state.z0, inputs.z0.step, { padInt: 3 });
    inputs.freqHz.value = state.freqHz; inputs.freqHzRead.textContent = `${formatValue(state.freqHz, inputs.freqHz.step, { padInt: 4 })} Hz`;
    inputs.baseCutoff.value = state.baseCutoff; inputs.baseCutoffRead.textContent = `${formatValue(state.baseCutoff, inputs.baseCutoff.step, { padInt: 4 })} Hz`; // New
    inputs.filterQ.value = state.filterQ; inputs.filterQRead.textContent = formatValue(state.filterQ, inputs.filterQ.step, { padInt: 2 });
    inputs.filterCutoffOffset.value = state.filterCutoffOffset; inputs.filterCutoffOffsetRead.textContent = `${formatValue(state.filterCutoffOffset, inputs.filterCutoffOffset.step, { signed: true, padInt: 4 })} Hz`;
    inputs.lfoRate.value = state.lfoRate; inputs.lfoRateRead.textContent = `${formatValue(state.lfoRate, inputs.lfoRate.step, { padInt: 1 })} Hz`;
    inputs.lfoDepth.value = state.lfoDepth; inputs.lfoDepthRead.textContent = formatValue(state.lfoDepth, inputs.lfoDepth.step, { padInt: 1 });
    inputs.delayTimeMs.value = state.delayTimeMs; inputs.delayTimeRead.textContent = `${formatValue(state.delayTimeMs, inputs.delayTimeMs.step, { padInt: 4 })} ms`;
    inputs.delayFeedback.value = state.delayFeedback; inputs.delayFeedbackRead.textContent = formatValue(state.delayFeedback, inputs.delayFeedback.step, { padInt: 1 });
    inputs.blendAmount.value = state.blendAmount; inputs.blendAmountRead.textContent = formatValue(state.blendAmount, inputs.blendAmount.step, { padInt: 1 });
    inputs.inputGain.value = state.inputGain; inputs.inputGainRead.textContent = formatValue(state.inputGain, inputs.inputGain.step, { padInt: 1 }); // New

    inputs.blendMode.value = state.blendMode;
    document.querySelector(`input[name="waveform"][value="${state.waveform}"]`).checked = true;

    // Checkbox toggles
    inputs.showAdmit.checked = state.showAdmit; inputs.showAdmitToggle.classList.toggle('active', state.showAdmit); inputs.showAdmitToggle.setAttribute('aria-checked', state.showAdmit);
    inputs.hiGrid.checked = state.hiGrid; inputs.hiGridToggle.classList.toggle('active', state.hiGrid); inputs.hiGridToggle.setAttribute('aria-checked', state.hiGrid);

    // Sync state for Mic/Record/Follow buttons
    inputs.micInputToggle.classList.toggle('active', state.micInputEnabled);
    inputs.micInputToggle.textContent = `Mic Input ${state.micInputEnabled ? 'ON' : 'OFF'}`;
    inputs.recordToggle.classList.toggle('recording', state.isRecording);
    inputs.recordToggle.textContent = `${state.isRecording ? 'Recording...' : 'Record'}`;
    inputs.followToggle.checked = state.autoMatchFollow;
    inputs.followToggleBtn.classList.toggle('active', state.autoMatchFollow);
    inputs.followToggleBtn.setAttribute('aria-checked', state.autoMatchFollow);

    // NEW: Puppet/Vocoder/Learning
    inputs.puppetToggle.classList.toggle('active', state.puppetOn);
    inputs.puppetToggle.textContent = `Puppet Mode ${state.puppetOn ? 'ON' : 'OFF'}`;
    inputs.vocoderToggle.classList.toggle('active', state.vocoderOn);
    inputs.vocoderToggle.textContent = `Vocoder ${state.vocoderOn ? 'ON' : 'OFF'}`;
    inputs.vocoderBands.value = state.vocoderBands;
    inputs.learningModeToggle.classList.toggle('active', state.learningModeActive);
    inputs.learningModeToggle.textContent = `Learning Mode ${state.learningModeActive ? 'ON' : 'OFF'}`;
    inputs.learningModeOverlay.classList.toggle('active', state.learningModeActive);


    // Sync listen presets based on current blend mode/amount
    document.querySelectorAll('#dashboard [data-listen-preset]').forEach(btn => btn.classList.remove('active'));
    if (state.blendMode === 'crossfade' && state.blendAmount === 0.5) inputs.listenMix.classList.add('active');
    else if (state.blendMode === 'sum' && state.blendAmount === 1.0) inputs.listenRadio.classList.add('active');
    else if (state.blendMode === 'sum' && state.blendAmount === 0.0) inputs.listenSynth.classList.add('active');

    // Sync ring visuals from state
    syncRingAnglesFromTrims();

    // Sync radio UI state from state.radioUrl
    // First, clear any dynamic options
    if (inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
        inputs.radioSource.removeChild(customUrlOption);
    }
    const localLoadedOption = inputs.radioSource.querySelector(`option[value="local-file-loaded"]`);
    if (localLoadedOption) localLoadedOption.remove();

    if (state.radioUrl === 'off') {
        inputs.radioSource.value = 'off';
        inputs.customUrlInputContainer.style.display = 'none';
        inputs.dynamicRadioUrl.value = '';
    } else if (Array.from(inputs.radioSource.options).some(opt => opt.value === state.radioUrl)) {
        // Predefined URL
        inputs.radioSource.value = state.radioUrl;
        inputs.customUrlInputContainer.style.display = 'none';
        inputs.dynamicRadioUrl.value = '';
    } else if (state.radioUrl.startsWith('blob:')) { // Local file URL
        const newLocalLoadedOption = document.createElement('option');
        newLocalLoadedOption.value = 'local-file-loaded';
        newLocalLoadedOption.textContent = 'Local File (Loaded)';
        inputs.radioSource.appendChild(newLocalLoadedOption);
        inputs.radioSource.value = 'local-file-loaded';
        inputs.radioNow.textContent = `Local: ${state.radioUrl.substring(state.radioUrl.lastIndexOf('/') + 1)}`; // Show a generic name
        inputs.customUrlInputContainer.style.display = 'none'; // Keep custom URL input hidden
    }
    else { // Custom URL
        inputs.dynamicRadioUrl.value = state.radioUrl;
        inputs.radioSource.appendChild(customUrlOption); // Add custom-loaded option back
        customUrlOption.style.display = 'block';
        inputs.radioSource.value = 'custom-loaded';
        inputs.customUrlInputContainer.style.display = 'flex';
    }


    // Sync dashboard hidden state
    $('#dashboard').classList.toggle('hidden', state.isDashboardHidden);
    inputs.hideMenuToggle.textContent = state.isDashboardHidden ? '▲' : '▼'; // Update glyph

    // Sync collapsible groups state
    pillGroups.forEach(group => {
        const header = group.querySelector('.pill-group-header');
        const groupId = group.id;
        const isCollapsed = state.collapsedGroups[groupId] || localStorage.getItem(`pillGroup_${groupId}_collapsed`) === 'true';
        group.classList.toggle('collapsed', isCollapsed);
        header.setAttribute('aria-expanded', !isCollapsed);
        state.collapsedGroups[groupId] = isCollapsed; // Ensure state reflects local storage
    });

  }

  // Tap/drag to set gamma
  let dragging=false;
  let activePointerID = null; // To track specific pointer for chart interaction

  canvas.addEventListener('pointerdown', (e)=>{
    vibrate(20); // Subtle haptic on pointer down
    initAudio(); // Ensure audio context starts on first interaction
    e.preventDefault(); // Prevent scrolling/zooming on touch
    dragging = true;
    activePointerID = e.pointerId; // Store active pointer ID
    setFromEvent(e, true);
  });
  canvas.addEventListener('pointermove', (e)=>{
    if(dragging && e.pointerId === activePointerID){
      e.preventDefault();
      setFromEvent(e, false);
    }
  });
  window.addEventListener('pointerup', (e)=> {
    if(e.pointerId === activePointerID){
      dragging = false;
      activePointerID = null;
      activeRing = null;
      // Stop the voice associated with this pointer if it's a chart interaction
      if (activePoints.has('mouse')) { // 'mouse' is the ID for non-touch pointer events
          activePoints.get('mouse').voice.stop();
          activePoints.delete('mouse');
      }
      draw();
    }
  });
  canvas.addEventListener('pointerleave', (e) => { // Handles pointer leaving canvas area
    if(e.pointerId === activePointerID){
      dragging = false;
      activePointerID = null;
      activeRing = null;
      if (activePoints.has('mouse')) {
          activePoints.get('mouse').voice.stop();
          activePoints.delete('mouse');
      }
      draw();
    }
  });
  canvas.addEventListener('pointercancel', (e) => { // Handles browser cancelling pointer event (e.g. multi-touch gesture)
    if(e.pointerId === activePointerID){
      dragging = false;
      activePointerID = null;
      activeRing = null;
      if (activePoints.has('mouse')) {
          activePoints.get('mouse').voice.stop();
          activePoints.delete('mouse');
      }
      draw();
    }
  });


  // Store active chart point voices (for dragging multiple points with touch or learning mode)
  const activePoints = new Map();

  function setFromEvent(e, isDown){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left); const y = (e.clientY - rect.top);
    // Update ring snap mode from modifiers (desktop)
    ringSnapMode = e.altKey ? 'free' : (e.shiftKey ? 'fine' : 'coarse');

    // Check ring hits first on pointerdown
    const smithChartRadius = R;
    const ringInnerOffset = smithChartRadius * 0.08;
    const ringBandWidth = 14;
    const ringSpacing = 10;
    const rSynthMid = smithChartRadius + ringInnerOffset + ringBandWidth/2;
    const rRadioMid = rSynthMid + ringBandWidth + ringSpacing + ringBandWidth/2;
    const hitTolerance = ringBandWidth/2 + 5;

    const dx = x - CX, dy = y - CY; const dist = Math.hypot(dx, dy);

    if (isDown){
      if (Math.abs(dist - rRadioMid) <= hitTolerance){
        activeRing='radio';
        vibrate(30); // Haptic for ring engagement
        // Auto-load a default radio if off and no URL loaded, or reconnect if URL is present but not playing
        if (!radioEnabled && state.radioUrl === 'off') {
            connectRadio('https://ice4.somafm.com/groovesalad-128-mp3');
        } else if (!radioEnabled && state.radioUrl !== 'off') {
            connectRadio(state.radioUrl);
        }
        updateRingFromPoint('radio', dx, dy); draw(); updateAudioParameters(); updateHash(false); return;
      }
      if (Math.abs(dist - rSynthMid) <= hitTolerance){
        activeRing='synth';
        vibrate(30); // Haptic for ring engagement
        updateRingFromPoint('synth', dx, dy); draw(); updateAudioParameters(); updateHash(false); return;
      }
    } else if (activeRing){ // dragging an active ring
      updateRingFromPoint(activeRing, dx, dy); draw(); updateAudioParameters(); updateHash(false); return;
    }

    // If not dragging a ring, treat as chart interaction
    const g = fromPX(x,y);
    const m = C.mag(g);
    if (m<=1){
      state.gamma = g; state.fromTap = true; // derive R/X and set fields

      // If this is a new pointerdown (or mouse click), create a new voice for it
      if (isDown && !activePoints.has('mouse')) { // 'mouse' is a generic ID for mouse/single touch on chart
        activePoints.set('mouse', {x:x, y:y, voice: new Voice(g.re, g.im)});
      } else if (!isDown && activePoints.has('mouse')) { // On move, update the existing voice
        const p = activePoints.get('mouse');
        p.x = x; p.y = y;
        p.voice.updateParameters(g.re, g.im);
      } else if (!isDown && !activePoints.has('mouse')) { // Handle cases where a pointermove starts without a pointerdown on chart
        return; // Ignore, as no active chart point for mouse
      }

      const z = g2z(g); // normalized impedance

      // Map normalized z.re and z.im back to filter Q and cutoff offset
      state.filterQ = Math.max(MIN_Q, Math.min(MAX_Q, z.re * state.z0)); // Assuming filterQ maps directly to R
      state.filterCutoffOffset = z.im * (MAX_CUTOFF_OFFSET_RANGE_HZ / 2); // Map z.im (-1 to 1) to (-MAX_CUTOFF_OFFSET_RANGE_HZ/2 to +MAX_CUTOFF_OFFSET_RANGE_HZ/2)

      syncToUI(); draw(); updateAudioParameters(); updateHash(false);
    }
  }

  // Share via URL hash
  function updateHash(write){
    const obj = {
      z0:state.z0, freqHz:state.freqHz, baseCutoff:state.baseCutoff, filterQ:state.filterQ, filterCutoffOffset:state.filterCutoffOffset,
      lfoRate:state.lfoRate, lfoDepth:state.lfoDepth, delayTimeMs:state.delayTimeMs, delayFeedback:state.delayFeedback,
      waveform:state.waveform, showAdmit:state.showAdmit?1:0, hiGrid:state.hiGrid?1:0,
      blendMode:state.blendMode, blendAmount:state.blendAmount, mic:state.micInputEnabled?1:0, inputGain:state.inputGain, rec:state.isRecording?1:0, follow:state.autoMatchFollow?1:0,
      puppet:state.puppetOn?1:0, vocoder:state.vocoderOn?1:0, vocoderBands:state.vocoderBands, learning:state.learningModeActive?1:0,
      ringSynthTrim: state.ringSynthTrim, ringRadioTrim: state.ringRadioTrim, // Store ring trims
      radioUrl: state.radioUrl, // Store current radio URL from state
      isDashboardHidden: state.isDashboardHidden?1:0, // Store dashboard visibility
      collapsedGroups: state.collapsedGroups, // Store collapsed state of groups
      g:[+state.gamma.re.toFixed(6), +state.gamma.im.toFixed(6)], t: state.fromTap?1:0
    };
    const hash = btoa(encodeURIComponent(JSON.stringify(obj)));
    if (write){ location.hash = hash; return location.href; }
    else { history.replaceState(null,'', location.pathname + '#' + hash); return location.href; }
  }
  function restoreFromHash(){
    const h = location.hash.slice(1); if(!h) return;
    try{
      const obj = JSON.parse(decodeURIComponent(atob(h)));
      Object.assign(state, {
        z0:obj.z0, freqHz:obj.freqHz, baseCutoff:obj.baseCutoff ?? 2000, filterQ:obj.filterQ, filterCutoffOffset:obj.filterCutoffOffset,
        lfoRate:obj.lfoRate, lfoDepth:obj.lfoDepth, delayTimeMs:obj.delayTimeMs, delayFeedback:obj.delayFeedback,
        waveform:obj.waveform || 'sine', showAdmit:!!obj.showAdmit, hiGrid:!!obj.hiGrid,
        blendMode:obj.blendMode ?? 'crossfade',
        blendAmount:obj.blendAmount ?? 0.5,
        micInputEnabled:obj.mic ?? false,
        inputGain:obj.inputGain ?? MIC_DEFAULT_GAIN,
        isRecording:obj.rec ?? false,
        autoMatchFollow:obj.follow ?? false,
        puppetOn:!!obj.puppet,
        vocoderOn:!!obj.vocoder,
        vocoderBands:obj.vocoderBands ?? 24,
        learningModeActive:!!obj.learning,
        ringSynthTrim: obj.ringSynthTrim ?? 1.0, // Restore ring trims
        ringRadioTrim: obj.ringRadioTrim ?? 1.0, // Restore ring trims
        radioUrl: obj.radioUrl ?? 'off', // Restore radio URL
        isDashboardHidden: !!obj.isDashboardHidden, // Restore dashboard visibility
        collapsedGroups: obj.collapsedGroups || {}, // Restore collapsed groups state
        gamma:{re:obj.g?.[0]||0, im:obj.g?.[1]||0}, fromTap: !!obj.t
      });
      // Handle the initial state.micInputEnabled if it's true, as it needs to run micInputToggle.click()
      if (state.micInputEnabled) {
          // Temporarily set to false, so the click event will correctly toggle it ON
          state.micInputEnabled = false;
      }
    }catch(e){ console.warn('Bad hash', e); }
  }

  function flash(msg){
    const pill = document.createElement('div'); pill.className='pill'; pill.textContent = msg; pill.style.position='absolute'; pill.style.left='12px'; pill.style.bottom='110px'; pill.style.zIndex='10';
    document.body.appendChild(pill); setTimeout(()=>pill.remove(), 1600);
  }

  // Init
  restoreFromHash();
  syncToUI();
  window.addEventListener('resize', resize, {passive:true});
  resize(); // Initial draw

  // After syncToUI has set the radio state from hash, if audio is ready, connect the radio.
  const delayedAudioConnectAndSetup = () => {
    initAudio(); // This will set isAudioReady = true
    if (state.radioUrl !== 'off' && mediaEl?.src !== state.radioUrl) {
      connectRadio(state.radioUrl);
    }
    // Also, if mic was enabled by hash, activate it now
    if (state.micInputEnabled) {
        inputs.micInputToggle.click();
    }
    // If puppet mode or vocoder were enabled by hash, start them
    if (state.puppetOn) { inputs.puppetToggle.click(); }
    if (state.vocoderOn) { inputs.vocoderToggle.click(); }
    if (state.autoMatchFollow) { inputs.followToggle.checked = true; setFollow(true); } // Re-enable follow
    updateModulatorSource(); // Ensure mod sources are connected
    document.body.removeEventListener('pointerdown', delayedAudioConnectAndSetup);
    document.body.removeEventListener('keydown', delayedAudioConnectAndSetup);
  };

  // Attach a listener to the first interaction that initializes audio
  document.body.addEventListener('pointerdown', delayedAudioConnectAndSetup, { once: true });
  document.body.addEventListener('keydown', delayedAudioConnectAndSetup, { once: true });

  // Main animation loop
  function animate(){
    requestAnimationFrame(animate);
    draw();
  }
  animate();

})();
</script>
</body>
</html>