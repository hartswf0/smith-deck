<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Smith Chart â€” Musical Interface</title>
<style>
  :root{
    --bg:#0b0c0f; --panel:#0f1115; --ink:#e6e6e6; --muted:#9aa4ad; --accent:#6ee7ff; --accent2:#a7f3d0; --grid:#263241; --grid2:#334155; --good:#34d399; --bad:#f87171; --warn:#fbbf24;
    --neon-blue: #00e5ff; /* Equivalent to --accent */
    --neon-green: #00ff99; /* Equivalent to --accent2 */
    --neon-red: #ff3366;
    --neon-purple: #cc33ff;

    --shadow:0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";}
  #app{position:fixed; inset:0; display:grid; grid-template-rows: 1fr auto;}
  canvas{display:block; width:100%; height:100%; touch-action:none;}

  /* --- Top HUD (minimal stats, corner placement) --- */
  #topHud{
    position:absolute;
    top:12px; left:12px; right:12px;
    display:flex;
    justify-content: space-between; /* Pushes content to corners */
    gap:8px;
    flex-wrap:nowrap; /* Keep corner groups together */
    pointer-events:none; /* Allow clicks to pass through to canvas */
    z-index: 50; /* Above canvas, below help box */
  }
  #topLeftHud, #topRightHud {
    display: flex;
    gap: 8px;
    flex-wrap: nowrap; /* Prevent pills from wrapping */
    pointer-events: auto; /* Re-enable for the pills themselves */
  }
  #topHud .pill{
    background:rgba(15,17,21,.75);
    backdrop-filter: blur(8px);
    border:1px solid rgba(255,255,255,.06);
    border-radius:999px;
    padding:6px 10px; /* Smaller padding */
    display:flex;
    align-items:center;
    gap:8px; /* Smaller gap */
    box-shadow:var(--shadow);
    color:var(--ink);
    font-size: 13px; /* Smaller font */
    line-height: 1;
    min-width: 0;
    flex-shrink: 0; /* CRITICAL: Prevent pills from shrinking or growing */
    white-space: nowrap; /* CRITICAL: Prevent text from wrapping */
  }
  #topHud .badge{font-variant-numeric: tabular-nums; font-size:11px; color:var(--muted); white-space: nowrap;} /* Smaller badge font */
  #topHud .dot{width:8px; height:8px; border-radius:50%} /* Smaller dot */
  #topHud b { font-weight: 500; white-space: nowrap; /* CRITICAL */ flex-shrink: 0; font-feature-settings: "tnum"; /* Ensure tabular numbers */ }
  /* Fixed widths for HUD values to prevent jitter */
  #topHud #mag { min-width: 2.7em; text-align: right; } /* e.g., 0.XXX */
  #topHud #ang { min-width: 4.5em; text-align: right; } /* e.g., -XXX.XÂ° */
  #topHud #zread { min-width: 10em; text-align: right; } /* e.g., Q:XX.X/CO:Â±XXXXHz */
  #topHud #vswr { min-width: 3em; text-align: right; } /* e.g., XX.XX */
  #topHud #rl { min-width: 5em; text-align: right; } /* e.g., Â±XX.XX dB */
  #topHud #yread { min-width: 8em; text-align: right; } /* e.g., R:X.X/D:X.XX */


  /* --- Dashboard (main control panel) --- */
  #dashboard{
    position:absolute;
    bottom:0; left:0; right:0;
    display:flex;
    flex-wrap: wrap;
    gap: 8px; /* Space between pill groups */
    padding: 12px;
    pointer-events: auto;
    background:linear-gradient(180deg, rgba(16,18,23,.9), rgba(16,18,23,.9));
    border-top:1px solid rgba(255,255,255,.06);
    box-shadow: var(--shadow);
    max-height: 50%; /* Prevent dashboard from taking up too much screen */
    overflow-y: auto; /* Scroll if content exceeds max-height */
    align-items: flex-start;
    justify-content: center;
    align-content: flex-start;
    transition: transform 0.3s ease-in-out, max-height 0.3s ease-in-out, padding 0.3s ease-in-out, border-top 0.3s ease-in-out;
    transform: translateY(0);
  }
  #dashboard.hidden {
    transform: translateY(100%);
    pointer-events: none;
    max-height: 0;
    padding: 0;
    border-top: none;
  }
  .pill{
    pointer-events:auto;
    background:rgba(15,17,21,.75);
    backdrop-filter: blur(8px);
    border:1px solid rgba(255,255,255,.06);
    border-radius:999px;
    padding:8px 12px;
    display:flex;
    align-items:center;
    gap:10px;
    box-shadow:var(--shadow);
    color:var(--ink);
    font-size: 14px;
    line-height: 1;
    min-width: 0;
  }
  .badge{font-variant-numeric: tabular-nums; font-size:12px; color:var(--muted); white-space: nowrap; flex-shrink: 0;}
  b { font-weight: 500; white-space: nowrap; /* CRITICAL */ flex-shrink: 0; font-feature-settings: "tnum"; text-align: right; min-width: 3em; /* Default min-width for range readouts */ }
  /* Specific min-widths for range readouts to prevent jitter */
  #z0Read { min-width: 3em; } /* 000 */
  #freqHzRead { min-width: 4.5em; } /* 0000 Hz */
  #filterQRead { min-width: 3em; } /* 00.0 */
  #filterCutoffOffsetRead { min-width: 5.5em; } /* Â±0000 Hz */
  #lfoRateRead { min-width: 3.5em; } /* 00.0 Hz */
  #lfoDepthRead { min-width: 2.7em; } /* 0.00 */
  #delayTimeRead { min-width: 4.5em; } /* 0000 ms */
  #delayFeedbackRead { min-width: 2.7em; } /* 0.00 */
  #blendAmountRead { min-width: 2.7em; } /* 0.00 */


  /* Pill-specific styling for inputs */
  .pill input[type="number"],
  .pill input[type="text"],
  .pill select {
      background: none;
      border: none;
      color: var(--ink);
      padding: 0;
      flex-grow: 1;
      min-width: 50px;
      text-align: left;
      font-size: 14px;
      font-family: inherit;
      -moz-appearance: textfield;
      font-feature-settings: "tnum"; /* Tabular numbers for input fields too */
  }
  .pill input[type="number"]::-webkit-outer-spin-button,
  .pill input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
  }
  .pill select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%239aa4ad'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 4px center;
      background-size: 16px;
      padding-right: 20px;
      cursor: pointer;
  }
  .pill input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100px;
      height: 6px;
      background: var(--grid);
      outline: none;
      opacity: 0.9;
      transition: opacity .2s;
      border-radius: 999px;
      flex-grow: 1;
      margin: 0 4px;
  }
  .pill input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--accent);
      cursor: grab;
      box-shadow: 0 0 8px var(--accent);
      margin-top: -9px;
  }
  .pill input[type="range"]::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--accent);
      cursor: grab;
      box-shadow: 0 0 8px var(--accent);
  }
  .pill input[type="range"]:hover {
    opacity: 1;
  }

  /* Pill Buttons - general style */
  .pill-btn {
    cursor: pointer;
    user-select: none;
    background: #0c0e13;
    color: var(--ink);
    border: 1px solid #1f2937;
    border-radius: 999px;
    padding: 8px 12px;
    display: flex;
    align-items:center;
    justify-content:center;
    transition: background .15s ease, box-shadow .15s ease, transform .05s ease, color .15s ease, border-color .15s ease;
    font-size: 14px;
    line-height: 1;
    white-space: nowrap;
    min-width: 0;
  }
  .pill-btn:hover {
    box-shadow: 0 0 8px rgba(110, 231, 255, 0.3);
  }
  .pill-btn:active {
    transform: translateY(1px);
  }

  /* Specific active states for pill buttons */
  #listenMix.active {
      background: var(--neon-blue); color: var(--bg); border-color: var(--neon-blue); box-shadow: 0 0 15px var(--neon-blue);
  }
  #listenRadio.active, #autoMatch.active {
      background: var(--neon-green); color: var(--bg); border-color: var(--neon-green); box-shadow: 0 0 15px var(--neon-green);
  }
  #listenSynth.active {
      background: var(--neon-purple); color: var(--bg); border-color: var(--neon-purple); box-shadow: 0 0 15px var(--neon-purple);
  }
  #micInputToggle.active {
      background: var(--neon-red); color: var(--bg); border-color: var(--neon-red); box-shadow: 0 0 15px var(--neon-red);
  }
  #recordToggle.recording {
      background: var(--neon-red); color: var(--bg); border-color: var(--neon-red); box-shadow: 0 0 15px var(--neon-red);
  }
  
  /* Custom checkbox pill-btn styles */
  .pill-btn.checkbox-pill.active {
    background: var(--neon-green);
    color: var(--bg);
    border-color: var(--neon-green);
    box-shadow: 0 0 8px var(--neon-green);
  }
  .pill-btn.checkbox-pill input[type="checkbox"] {
    display: none;
  }
  
  /* Waveform radios in a pill */
  .waveform-pill {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    flex-grow: 1;
  }
  .waveform-pill label {
    display: flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
    font-size: 14px;
    color: var(--ink);
    padding: 4px 0;
    border-radius: 999px;
  }
  .waveform-pill input[type="radio"] {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border: 1px solid var(--muted);
    border-radius: 50%;
    outline: none;
    cursor: pointer;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }
  .waveform-pill input[type="radio"]:checked {
    border-color: var(--accent);
  }
  .waveform-pill input[type="radio"]:checked::before {
    content: '';
    width: 10px;
    height: 10px;
    background-color: var(--accent);
    border-radius: 50%;
    display: block;
  }
  .waveform-pill label:hover {
    color: var(--accent);
  }

  /* Pill Groups (Collapsible Areas) */
  .pill-group {
    display: flex;
    flex-direction: column;
    gap: 0;
    background: rgba(15,17,21,.5);
    border: 1px solid rgba(255,255,255,.04);
    border-radius: 16px;
    padding: 0;
    flex-grow: 1;
    min-width: min(300px, 100%);
    overflow: hidden;
  }
  .pill-group-header {
    width: 100%;
    background: rgba(15,17,21,.1);
    border: none;
    color: var(--muted);
    padding: 8px 15px;
    font-size: 14px;
    font-weight: 500;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    border-bottom: 1px solid rgba(255,255,255,.01);
    border-radius: 16px 16px 0 0;
    text-align: left;
    white-space: nowrap;
  }
  .pill-group-header h3 {
      margin: 0;
      font-size: 1em;
      color: inherit;
      font-weight: inherit;
  }
  .pill-group-header .icon {
    transition: transform 0.2s ease-in-out;
    margin-left: 10px;
    font-size: 1.2em; /* Use simple > char, make it slightly larger for visibility */
    line-height: 1;
    flex-shrink: 0;
  }
  .pill-group.collapsed .pill-group-header .icon {
    transform: rotate(0deg); /* Points right when collapsed */
  }
  .pill-group-header[aria-expanded="true"] .icon {
      transform: rotate(90deg); /* Points down when expanded */
  }


  .pill-group-header:hover {
    background: rgba(20,22,28,.15);
  }

  .pill-group-content {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    padding: 10px;
    max-height: 500px; /* Max height to allow animation */
    transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out;
  }
  .pill-group.collapsed .pill-group-content {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
    overflow: hidden;
  }
  
  /* Styling for pills/buttons within content */
  .pill-group-content > .pill,
  .pill-group-content > .pill-btn {
    flex-grow: 1;
    min-width: unset;
  }

  /* Specific styling for nested radio group */
  .radio-pill-group {
      flex-direction: column;
      flex-grow: 1;
      padding: 0px; /* Managed by parent .pill-group-content */
      min-width: unset;
      gap: 6px;
      border: none;
      background: none;
      box-shadow: none;
  }
  .radio-pill-group > .pill,
  .radio-pill-group > .pill-btn {
      width: 100%;
      flex-grow: 1;
  }

  #radioNow {
      font-size: 0.9em;
      color: var(--accent);
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
      flex-shrink: 1;
  }

  /* Custom URL input styling within a pill */
  #customUrlInputContainer.pill {
      flex-wrap: nowrap;
      width: 100%;
      flex-grow: 1;
  }
  #customUrlInputContainer input[type="text"] {
      padding: 0;
  }
  #customUrlInputContainer #loadCustomRadioBtn {
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.9em;
      flex-shrink: 0;
  }
  
  /* Help Box */
  .help{
      position: absolute;
      right: 12px;
      bottom: 12px; /* Adjusted by JS to sit above dashboard/footer */
      background:rgba(15,17,23,.9);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:12px;
      width:min(420px, calc(100vw - 24px));
      box-shadow: var(--shadow);
      font-size:13px;
      line-height:1.35;
      display:none;
      z-index: 100;
  }
  .help.show{display:block}

  /* --- Global Actions Bar (Always Visible, between canvas and dashboard) --- */
  #globalActionsBar {
      position: absolute; /* Changed from fixed to absolute to position relative to app grid */
      bottom: 0; /* Will be adjusted by JS to sit just above dashboard */
      left: 0;
      right: 0;
      padding: 8px 12px;
      display: flex;
      gap: 8px;
      justify-content: center;
      z-index: 90; /* Below help box, above dashboard */
      pointer-events: auto;
      background: linear-gradient(0deg, rgba(16,18,23,.9), rgba(16,18,23,.0)); /* Subtle gradient from bottom */
      border-top:1px solid rgba(255,255,255,.03);
      box-shadow: var(--shadow);
      transition: transform 0.3s ease-in-out, background 0.3s ease-in-out, bottom 0.3s ease-in-out;
  }
  /* When dashboard is hidden, global actions bar should shift to the bottom of the viewport */
  #dashboard.hidden + #globalActionsBar {
      bottom: 0 !important; /* Override JS setting for bottom when dashboard is hidden */
      background: linear-gradient(180deg, rgba(16,18,23,.0), rgba(16,18,23,.9));
      border-top: 1px solid rgba(255,255,255,.06);
      padding-top: 12px;
  }
  #globalActionsBar .pill-btn { /* Style for buttons within the global actions bar */
      font-size: 18px; /* Larger icons/glyphs */
      padding: 6px 12px;
      min-width: unset; /* Allow them to shrink to content */
      flex-shrink: 0; /* Prevent from shrinking */
  }


  @media (max-width: 860px) {
      #topHud .pill{
          padding:5px 8px; /* Even smaller for mobile */
          font-size: 12px;
          gap:6px;
      }
      #topHud .badge{font-size:10px;}
      /* Fixed widths for HUD values to prevent jitter on mobile */
      #topHud #mag { min-width: 2.7em; } /* e.g., 0.XXX */
      #topHud #ang { min-width: 4.5em; } /* e.g., -XXX.XÂ° */
      #topHud #zread { min-width: 10em; } /* e.g., Q:XX.X/CO:Â±XXXXHz */
      #topHud #vswr { min-width: 3em; } /* e.g., XX.XX */
      #topHud #rl { min-width: 5em; } /* e.g., Â±XX.XX dB */
      #topHud #yread { min-width: 8em; } /* e.g., R:X.X/D:X.XX */


      #dashboard {
          padding: 8px;
          gap: 6px;
          max-height: 60%;
      }
      .pill-group {
          padding: 0;
          min-width: 100%;
      }
      .pill-group-header {
        font-size: 14px;
        padding: 8px 12px;
      }
      .pill-group-content {
          padding: 8px;
          gap: 6px;
      }
      .pill {
          padding: 6px 10px;
          font-size: 13px;
      }
      .pill input[type="number"],
      .pill input[type="text"],
      .pill select,
      .pill input[type="range"] {
          font-size: 13px;
      }
      .pill input[type="range"] {
          height: 5px;
      }
      .pill input[type="range"]::-webkit-slider-thumb,
      .pill input[type="range"]::-moz-range-thumb {
          width: 20px;
          height: 20px;
          margin-top: -8px;
      }
      .pill-btn {
          padding: 6px 10px;
          font-size: 13px;
      }
      .waveform-pill label {
        font-size: 13px;
      }
      .waveform-pill input[type="radio"] {
          width: 14px;
          height: 14px;
      }
      .waveform-pill input[type="radio"]:checked::before {
          width: 9px;
          height: 9px;
      }
      #globalActionsBar {
          padding: 8px 6px;
          flex-wrap: nowrap; /* Keep global buttons on one line */
      }
      #globalActionsBar .pill-btn { /* Smaller font for global buttons on mobile */
          font-size: 16px;
          padding: 5px 8px;
      }
  }
</style>
</head>
<body>
  <div id="app">
    <canvas id="chart" aria-label="Interactive Smith Chart Musical Interface" role="img"></canvas>

    <!-- Top HUD: Minimal Stats -->
    <div id="topHud">
      <div id="topLeftHud">
        <div class="pill" title="Reflection Coefficient Magnitude (0-1)"><div class="dot" style="background:var(--accent)"></div><span class="badge">Vol</span><b id="mag">0.000</b></div>
        <div class="pill" title="Phase Angle in degrees (-180Â° to 180Â°)"><div class="dot" style="background:var(--accent2)"></div><span class="badge">Phase</span><b id="ang">0.0Â°</b></div>
        <div class="pill" title="Filter Settings (Q / Cutoff Offset)"><span class="badge">Timbre</span><b id="zread">Q:00.0/CO:0000Hz</b></div>
      </div>
      <div id="topRightHud">
        <div class="pill" title="Standing Wave Ratio (1=pure tone, higher=more harmonics)"><div class="dot" style="background:var(--warn)"></div><span class="badge">Harm</span><b id="vswr">00.00</b></div>
        <div class="pill" title="Return Loss in dB (Sound Clarity / Damping)"><div class="dot" style="background:var(--bad)"></div><span class="badge">Clarity</span><b id="rl">Â±00.00 dB</b></div>
        <div class="pill" title="LFO Rate (Hz) / Depth (0-1)"><span class="badge">LFO</span><b id="yread">R:0.0/D:0.00</b></div>
      </div>
    </div>

    <div class="help" id="helpBox">
      <b>Smith Chart Musical Interface Quick Guide</b><br/>
      â€¢ Tap or click inside the circle to set the main sound's timbre. Drag to refine.<br/>
      â€¢ The 'L' dot indicates the primary sound (derived from Freq, Filter Q/Cutoff).<br/>
      â€¢ The 'S' dot shows the sound after Delay effect.<br/>
      â€¢ Toggle <i>Comp. Timbre</i> to add a second voice.<br/>
      â€¢ The outer rings control the final volume trim for Synth (purple) and Radio (green).<br/>
      â€¢ <b>Share</b> copies a URL with your current sound settings.<br/>
      <div style="height:6px"></div>
      <span class="muted">Acoustic impedance matching is essential in musical instruments. The Smith Chart visualizes resonance (volume), harmonics (VSWR), and timbre (filter settings) based on your interactions.</span>
    </div>

    <!-- Dashboard (main control panel) -->
    <div id="dashboard">
      <!-- Group: Radio & Global Actions -->
      <div class="pill-group" id="radioGlobalGroup">
        <button class="pill-group-header" aria-expanded="true" aria-controls="radioGlobalContent"><h3>Radio & Global</h3><span class="icon">â€º</span></button>
        <div class="pill-group-content" id="radioGlobalContent">
          <div class="pill"><span class="badge">Radio â€¢ <span id="radioStatus">Stopped</span></span>
              <select id="radioSource">
                  <option value="off">Off</option>
                  <option value="https://ice4.somafm.com/groovesalad-128-mp3">SomaFM Groove Salad</option>
                  <option value="https://streams.ilovemusic.de/iloveradio1.mp3">I Love Radio</option>
                  <option value="https://stream.live.vc.bbcmedia.co.uk/bbc_radio_one">BBC R1</option>
                  <option value="custom-url">Custom URL...</option>
                  <option value="local-file">Local Fileâ€¦</option>
              </select>
          </div>
          <div id="customUrlInputContainer" class="pill" style="display:none;">
              <input type="text" id="dynamicRadioUrl" placeholder="Enter stream URL">
              <button class="pill-btn" id="loadCustomRadioBtn">Load</button>
          </div>
          <div class="pill"><span class="badge">Now Playing</span><b id="radioNow">â€”</b></div>
          <button class="pill-btn" id="micInputToggle">Mic Input OFF</button>
          <button class="pill-btn" id="recordToggle">Record</button>
          <button class="pill-btn" id="reset">Reset</button>
          <button class="pill-btn primary" id="share">Share</button>
        </div>
      </div>
      
      <!-- Group: Core Synth & FX -->
      <div class="pill-group" id="synthFXGroup">
        <button class="pill-group-header" aria-expanded="true" aria-controls="synthFXContent"><h3>Synth & FX</h3><span class="icon">â€º</span></button>
        <div class="pill-group-content" id="synthFXContent">
          <div class="pill"><span class="badge">Zâ‚€ (Ref)</span><input id="z0" type="range" min="1" max="500" step="1" value="50"><b class="badge" id="z0Read">050</b></div>
          <div class="pill"><span class="badge">Freq</span><input id="freqHz" type="range" min="20" max="2000" step="1" value="440"><b class="badge" id="freqHzRead">0440 Hz</b></div>
          <div class="pill"><span class="badge">Filter Q</span><input id="filterQ" type="range" min="0" max="100" step="0.1" value="1"><b class="badge" id="filterQRead">01.0</b></div>
          <div class="pill"><span class="badge">Cutoff Offset</span><input id="filterCutoffOffset" type="range" min="-2000" max="2000" step="1" value="0"><b class="badge" id="filterCutoffOffsetRead">Â±0000 Hz</b></div>
          <div class="pill"><span class="badge">LFO Rate</span><input id="lfoRate" type="range" min="0" max="20" step="0.1" value="0"><b class="badge" id="lfoRateRead">00.0 Hz</b></div>
          <div class="pill"><span class="badge">LFO Depth</span><input id="lfoDepth" type="range" step="0.01" min="0" max="1" value="0"><b class="badge" id="lfoDepthRead">0.00</b></div>
          <div class="pill"><span class="badge">Delay Time</span><input id="delayTimeMs" type="range" min="0" max="1000" step="1" value="0"><b class="badge" id="delayTimeRead">0000 ms</b></div>
          <div class="pill"><span class="badge">Delay Feedback</span><input id="delayFeedback" type="range" min="0" max="0.99" step="0.01" value="0.4"><b class="badge" id="delayFeedbackRead">0.40</b></div>
          <div class="pill waveform-pill">
              <span class="badge">Wave:</span>
              <label><input id="waveformSine" type="radio" name="waveform" value="sine" checked>Sine</label>
              <label><input id="waveformSquare" type="radio" name="waveform" value="square">Square</label>
              <label><input id="waveformSawtooth" type="radio" name="waveform" value="sawtooth">Saw</label>
              <label><input id="waveformTriangle" type="radio" name="waveform" value="triangle">Tri</label>
          </div>
          <button class="pill-btn checkbox-pill" id="showAdmitToggle" role="switch" aria-checked="false"><input id="showAdmit" type="checkbox">Comp. Timbre</button>
          <button class="pill-btn checkbox-pill" id="hiGridToggle" role="switch" aria-checked="true"><input id="hiGrid" type="checkbox" checked>Hi-detail Grid</button>
        </div>
      </div>
      
      <!-- Group: Blending & Listen -->
      <div class="pill-group" id="blendListenGroup">
        <button class="pill-group-header" aria-expanded="true" aria-controls="blendListenContent"><h3>Blending & Listen</h3><span class="icon">â€º</span></button>
        <div class="pill-group-content" id="blendListenContent">
          <div class="pill"><span class="badge">Blend Mode</span>
              <select id="blendMode">
                  <option value="crossfade">X-fade</option>
                  <option value="sum">Sum</option>
                  <option value="multiply">Mult</option>
                  <option value="difference">Diff</option>
              </select>
          </div>
          <div class="pill"><span class="badge">Blend Amount</span><input id="blendAmount" type="range" step="0.01" min="0" max="1" value="0.5"><b class="badge" id="blendAmountRead">0.50</b></div>
          <button class="pill-btn" data-listen-preset="mix" id="listenMix">Mix</button>
          <button class="pill-btn" data-listen-preset="radio" id="listenRadio">Radio</button>
          <button class="pill-btn" data-listen-preset="synth" id="listenSynth">Synth</button>
          <button class="pill-btn" id="autoMatch">Auto Match</button>
          <button class="pill-btn checkbox-pill" id="followToggleBtn" role="switch" aria-checked="false"><input type="checkbox" id="followToggle">Follow</button>
        </div>
      </div>
    </div>

    <!-- Global Actions Bar (Always Visible, below canvas) -->
    <div id="globalActionsBar">
        <button class="pill-btn" id="helpBtn" title="Show Help">ðŸ›ˆ</button>
        <button class="pill-btn" id="fullscreenToggle" title="Toggle Fullscreen">â›¶</button>
        <button class="pill-btn" id="hideMenuToggle" title="Hide/Show UI">â–¼</button>
    </div>
  </div>

<script>
(function(){
  const $ = sel=>document.querySelector(sel);
  const canvas = $('#chart');
  const ctx = canvas.getContext('2d');
  let DPR = Math.min(2, window.devicePixelRatio || 1);
  let W=0,H=0,CX=0,CY=0,R=0; // canvas sizing

  // Audio Context and Nodes
  let audioCtx;
  let osc, filter, masterGain, monitorGain;
  let synthAmplitudeGain; // Controls synth base volume by |Gamma| BEFORE LFO
  let lfo, lfoModulatorGain; // LFO and its depth modulator
  let synthChannelGain, radioChannelGain; // For blending amounts
  let dryMixer, delaySendGain, delayReturnGain; // For global dry/wet delay mix
  let mainOutputBus; // The bus where blended signals meet, before final masterGain and dry/wet delay

  let oscY, filterY; // for complementary timbre
  let delay, delayFeedbackGain;
  let isAudioReady = false;

  // Radio specific audio nodes
  let mediaEl = null, mediaNode = null;
  let radioFilter = null, radioPreGain = null, radioPanner = null;
  let radioEnabled = false;

  // Mic Input
  let micInputEnabled = false;
  let micStream = null;
  let micInputSource, micAnalyserNode, micGainNode; // For mic input processing

  // Recording
  let isRecording = false;
  let mediaRecorder;
  let recordedChunks = [];
  let destinationStream;

  // Analysers for Blend Modes (Multiply) and Auto-Match
  let synthAnalyser, synthEnvelopeFollowerGain, synthEnvelopePrev = 0;
  let radioAnalyser;
  let phaseFlipperGain; // For Difference Blend Mode

  // Auto-Match/Follow
  let followTimer = null;

  // Constants
  const MAX_DELAY_MS = 1000;
  const LFO_MODULATION_SCALE = 0.5; // LFO goes -1 to 1, so depth * 0.5 gives +/- depth/2
  const SYNTH_ENV_SCALE = 2.0;
  const SYNTH_ENV_POWER = 0.6;
  const MIC_DEFAULT_GAIN = 1.0;
  const MAX_CUTOFF_OFFSET_RANGE_HZ = 4000; // Total range for cutoff offset (e.g., -2000 to +2000)
  const MIN_FREQ = 20;
  const MAX_FREQ = 20000;
  const MIN_Q = 0;
  const MAX_Q = 100;
  const AUDIO_MASTER_GAIN = 0.5;

  // State
  const state = {
    z0: 50, // Acoustic reference (analogous to characteristic impedance)
    freqHz: 440, // Base frequency in Hz
    filterQ: 1, // Filter Q factor
    filterCutoffOffset: 0, // Filter cutoff offset from base freq
    lfoRate: 0, // LFO frequency in Hz
    lfoDepth: 0, // LFO gain modulation depth (0-1)
    delayTimeMs: 0, // Delay time in milliseconds
    delayFeedback: 0.4, // Delay feedback (0-1)
    waveform: 'sine', // Oscillator waveform
    showAdmit: false, // Show complementary timbre
    hiGrid: true,
    blendMode: 'crossfade', // New: Blend mode (crossfade, sum, multiply, difference)
    blendAmount: 0.5, // New: Blend amount (0-1)
    micInputEnabled: false,
    isRecording: false,
    autoMatchFollow: false,
    ringSynthTrim: 1.0, // 0..1, acts as a master trim for synth volume
    ringRadioTrim: 1.0, // 0..1, acts as a master trim for radio volume
    radioUrl: 'off', // Stores the last selected/custom radio URL
    // user marker in Gamma plane (complex) â€” set by inputs or tapping
    gamma: {re: 0, im: 0},
    fromTap: false, // if the current state.gamma comes from user tapping (disables R/X input parsing)
    // UI state
    isDashboardHidden: false,
    collapsedGroups: {} // Store collapsed state for each pill group
  };

  // --- Rotary volume rings visual state ---
  let activeRing = null; // 'synth' | 'radio' | null
  let ringSynthAngle = 0; // 0..2Ï€
  let ringRadioAngle = 0; // 0..2Ï€
  const RING_DETENTS_COARSE = 36; // 10Â° steps
  const RING_DETENTS_FINE = 180; // 2Â° steps
  let ringSnapMode = 'coarse'; // 'coarse' | 'fine' | 'free'
  
  function syncRingAnglesFromTrims(){
    ringSynthAngle = 2*Math.PI * Math.max(0, Math.min(1, state.ringSynthTrim));
    ringRadioAngle = 2*Math.PI * Math.max(0, Math.min(1, state.ringRadioTrim));
  }
  // Initialize ring angles based on state (will be updated from hash/reset)
  syncRingAnglesFromTrims();

  // UI Elements
  const inputs = {
    z0: $('#z0'), z0Read: $('#z0Read'),
    freqHz: $('#freqHz'), freqHzRead: $('#freqHzRead'),
    filterQ: $('#filterQ'), filterQRead: $('#filterQRead'),
    filterCutoffOffset: $('#filterCutoffOffset'), filterCutoffOffsetRead: $('#filterCutoffOffsetRead'),
    lfoRate: $('#lfoRate'), lfoRateRead: $('#lfoRateRead'),
    lfoDepth: $('#lfoDepth'), lfoDepthRead: $('#lfoDepthRead'),
    delayTimeMs: $('#delayTimeMs'), delayFeedback: $('#delayFeedback'),
    delayTimeRead: $('#delayTimeRead'), delayFeedbackRead: $('#delayFeedbackRead'),
    blendMode: $('#blendMode'), blendAmount: $('#blendAmount'), blendAmountRead: $('#blendAmountRead'),
    mag: $('#mag'), ang: $('#ang'), vswr: $('#vswr'), rl: $('#rl'), 
    zread: $('#zread'), yread: $('#yread'), // Re-added to top HUD
    waveformRadios: document.querySelectorAll('input[name="waveform"]'),
    showAdmit: $('#showAdmit'), showAdmitToggle: $('#showAdmitToggle'), 
    hiGrid: $('#hiGrid'), hiGridToggle: $('#hiGridToggle'), 
    reset: $('#reset'), share: $('#share'), help: $('#helpBox'), helpBtn: $('#helpBtn'),
    // Radio UI
    radioSource: $('#radioSource'),
    dynamicRadioUrl: $('#dynamicRadioUrl'),
    loadCustomRadioBtn: $('#loadCustomRadioBtn'),
    customUrlInputContainer: $('#customUrlInputContainer'),
    radioStatus: $('#radioStatus'),
    radioNow: $('#radioNow'),
    // Listen Presets & Auto Match
    listenMix: $('#listenMix'), listenRadio: $('#listenRadio'), listenSynth: $('#listenSynth'),
    autoMatch: $('#autoMatch'), followToggle: $('#followToggle'), followToggleBtn: $('#followToggleBtn'), 
    // Action Buttons
    micInputToggle: $('#micInputToggle'), recordToggle: $('#recordToggle'),
    // New Interface Buttons
    fullscreenToggle: $('#fullscreenToggle'), hideMenuToggle: $('#hideMenuToggle'),
    // Collapsible group headers (now fewer)
    radioGlobalGroupHeader: $('#radioGlobalGroup button.pill-group-header'),
    synthFXGroupHeader: $('#synthFXGroup button.pill-group-header'),
    blendListenGroupHeader: $('#blendListenGroup button.pill-group-header'),
  };

  // --- Haptic Feedback ---
  function vibrate(pattern = 50) { // Default to a short, sharp vibration
    if (navigator.vibrate) {
      navigator.vibrate(pattern);
    }
  }

  // Complex helpers
  const C = {
    add: (a,b)=>({re:a.re+b.re, im:a.im+b.im}),
    sub: (a,b)=>({re:a.re-b.re, im:a.im-b.im}),
    mul: (a,b)=>({re:a.re*b.re - a.im*b.im, im:a.re*b.re + a.im*b.re}),
    div: (a,b)=>{ const d=b.re*b.re + b.im*b.im || 1e-18; return {re:(a.re*b.re + a.im*b.im)/d, im:(a.im*b.re - a.re*b.im)/d}; },
    conj:(a)=>({re:a.re, im:-a.im}),
    mag:(a)=>Math.hypot(a.re, a.im),
    ang:(a)=>Math.atan2(a.im, a.re),
    expj:(phi)=>({re:Math.cos(phi), im:Math.sin(phi)}),
  };

  // Mapping between normalized z and reflection coefficient gamma
  function z2g(z){ // z is {re, im}
    const num = C.sub(z, {re:1, im:0});
    const den = C.add(z, {re:1, im:0});
    return C.div(num, den);
  }
  function g2z(g){
    const num = C.add({re:1, im:0}, g);
    const den = C.sub({re:1, im:0}, g);
    return C.div(num, den);
  }

  function yFromZ(z){ // y = 1/z
    const den = z.re*z.re + z.im*z.im || 1e-18; return {re: z.re/den, im: -z.im/den};
  }

  // Coordinates
  function toPX(pt){ return {x: CX + R*pt.re, y: CY - R*pt.im}; }
  function fromPX(x,y){ return {re:(x-CX)/R, im:-(y-CY)/R}; }

  function resize(){
    const rect = canvas.getBoundingClientRect();
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.round(rect.width * DPR); H = Math.round(rect.height * DPR);
    canvas.width = W; canvas.height = H;
    canvas.style.width = rect.width + 'px'; canvas.style.height = rect.height + 'px';
    ctx.setTransform(1,0,0,1,0,0); ctx.scale(DPR,DPR);
    
    const dashboardElement = $('#dashboard');
    const globalActionsBar = $('#globalActionsBar');
    const topHudElement = $('#topHud');

    let dashboardHeight = 0;
    // Calculate dashboard height *only if it's visible*
    if (!dashboardElement.classList.contains('hidden')) {
      // Temporarily unset max-height to get natural height, then restore
      const originalMaxHeight = dashboardElement.style.maxHeight;
      dashboardElement.style.maxHeight = 'none';
      dashboardHeight = dashboardElement.offsetHeight;
      dashboardElement.style.maxHeight = originalMaxHeight; // Restore max-height
    }
    
    const globalActionsBarHeight = globalActionsBar.offsetHeight;
    const topHudHeight = topHudElement.offsetHeight + 12; // + top/bottom padding for spacing to chart

    // Adjust globalActionsBar position dynamically relative to dashboard
    globalActionsBar.style.bottom = `${dashboardHeight}px`;

    // Calculate available canvas height
    const availableCanvasHeight = rect.height - dashboardHeight - globalActionsBarHeight - topHudHeight;
    const availableCanvasWidth = rect.width;

    // Determine chart radius based on available space
    const padding = 16;
    const chartSize = Math.min(availableCanvasWidth, availableCanvasHeight) - padding * 2;
    R = chartSize / 2;
    
    // Position chart center within the available space
    CX = availableCanvasWidth / 2;
    CY = topHudHeight + (availableCanvasHeight / 2);

    // Adjust help box position
    const helpBox = inputs.help;
    if (helpBox) {
        helpBox.style.bottom = `${(state.isDashboardHidden ? globalActionsBarHeight : dashboardHeight + globalActionsBarHeight) + 12}px`;
    }

    draw();
  }

  // Grid drawing
  function drawGrid(){
    ctx.save();
    // Background gradient subtle
    const grad = ctx.createRadialGradient(CX, CY, R*0.1, CX, CY, R*1.2);
    grad.addColorStop(0, '#0b0c0f');
    grad.addColorStop(1, '#0a0c10');
    ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);

    // Clip to unit circle
    ctx.beginPath();
    ctx.arc(CX, CY, R, 0, Math.PI*2);
    ctx.clip();

    // minor grid
    const rMaj = [0,0.2,0.5,1,2,5];
    const xMaj = [0.2,0.5,1,2,5];
    const rMin = state.hiGrid ? [0.1,0.3,0.7,1.5,3,7] : [];
    const xMin = state.hiGrid ? [0.1,0.3,0.7,1.5,3,7] : [];

    // helper to draw circle in Gamma plane (center, radius) masked
    function circle(cx, cy, rr, lw, col){
      ctx.beginPath(); ctx.lineWidth = lw; ctx.strokeStyle = col; ctx.arc(CX + R*cx, CY - R*cy, R*rr, 0, Math.PI*2); ctx.stroke();
    }

    // constant resistance circles: center (r/(r+1),0), radius 1/(r+1)
    const colMin = getCSS('--grid');
    const colMaj = getCSS('--grid2');

    // draw minor first
    ctx.globalAlpha=.7;
    rMin.forEach(r=>{ circle(r/(r+1), 0, 1/(r+1), 1, colMin); });
    xMin.forEach(x=>{
      const rad = 1/Math.abs(x); const cy = 1/x; // centers at (1, 1/x)
      circle(1, cy, rad, 1, colMin);
      circle(1, -cy, rad, 1, colMin);
    });

  // Initialize local file UI and drag/drop on boot
  ensureLocalFileUI();
  setupDragDrop();

    // major
    ctx.globalAlpha=1;
    rMaj.forEach((r,i)=>{ circle(r/(r+1), 0, 1/(r+1), 1.5, colMaj); });
    xMaj.forEach(x=>{
      const rad = 1/Math.abs(x); const cy = 1/x;
      circle(1, cy, rad, 1.5, colMaj);
      circle(1, -cy, rad, 1.5, colMaj);
    });

    // boundary
    ctx.globalAlpha=1; ctx.lineWidth=2; ctx.strokeStyle = 'rgba(255,255,255,.15)';
    ctx.beginPath(); ctx.arc(CX, CY, R, 0, Math.PI*2); ctx.stroke();

    // real axis
    ctx.lineWidth=1.5; ctx.strokeStyle='rgba(255,255,255,.18)';
    ctx.beginPath(); ctx.moveTo(CX - R, CY); ctx.lineTo(CX + R, CY); ctx.stroke();

    // labels (r, x)
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto'; ctx.fillStyle='rgba(255,255,255,.6)'; ctx.textAlign='center'; ctx.textBaseline='top';
    rMaj.forEach(r=>{
      const p = toPX({re: (r-1)/(r+1), im: 0}); // leftmost point on each r circle crosses real axis at ( (r-1)/(r+1), 0 )
      ctx.fillText('r='+r, p.x, CY+4);
    });
    ctx.textBaseline='bottom';
    xMaj.forEach(x=>{
      // Adjust label placement for better visibility
      const labelX = CX + R * 0.78; // Offset slightly from edge
      const labelYPos = CY - R * (1 / Math.abs(x)); // Position relative to current x arc
      const labelYNeg = CY + R * (1 / Math.abs(x));

      // Small adjustment for text baseline
      if (x > 0) { // Top arcs
        ctx.fillText('+j'+x, labelX, labelYPos - 4);
      } else { // Bottom arcs
        ctx.fillText('âˆ’j'+x, labelX, labelYNeg + 16);
      }
    });

    ctx.restore();
  }

  function getCSS(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }

  // Helper to convert CSS color var to rgba string for canvas
  function varToRgba(varName, alpha = 1){
    const color = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    const r = parseInt(color.slice(1,3),16), g = parseInt(color.slice(3,5),16), b = parseInt(color.slice(5,7),16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }

  // Calculate load gamma from inputs or tap
  function computeGammaFromInputs(){
    const z0 = state.z0;
    const filterQ = state.filterQ; // R equivalent
    const filterCutoffOffset = state.filterCutoffOffset; // X equivalent
    const z = {re: Math.max(0, filterQ/z0), im: filterCutoffOffset/z0}; // Normalize
    const g = z2g(z);
    return g;
  }

  function vswrFromMag(m){ return m>=0.999999 ? Infinity : (1+m)/(1-m); }
  function rlFromMag(m){ return m<=0 ? Infinity : -20*Math.log10(m); }

  function rotateGamma(g, delayTimeMs){ // Simulating delay by rotation. Angle is not direct Î» here.
    const rotationFactor = delayTimeMs / MAX_DELAY_MS; // Normalize 0-1
    const phi = -2 * Math.PI * rotationFactor; // Rotate from 0 to -360 degrees
    const ej = C.expj(phi);
    return C.mul(g, ej);
  }

  // Draw points and guides
  function drawData(){
    // Determine gamma from either tap state or inputs
    const baseGamma = state.fromTap ? state.gamma : computeGammaFromInputs();
    // Save computed gamma back so stats reflect it if not from tap
    if (!state.fromTap) state.gamma = baseGamma;

    // Rotated gamma after delay effect
    const gSrc = rotateGamma(baseGamma, state.delayTimeMs);

    // Draw SWR circle
    const mag = C.mag(baseGamma);
    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = 1.5; ctx.setLineDash([6,6]); ctx.strokeStyle = `rgba(255,255,255,${0.25 * Math.max(0.2, mag)})`; // Opacity depends on mag
    const rSWR = R*mag; ctx.arc(CX, CY, rSWR, 0, Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);

    // Load point (Primary Sound)
    plotMarker(baseGamma, getCSS('--accent'), 4 + mag*4, 'L'); // Marker size scales with amplitude
    // Source point after delay
    if (state.delayTimeMs > 0) {
      plotMarker(gSrc, getCSS('--accent2'), 3 + mag*3, 'S');
    }

    // Admittance point (Complementary Timbre)
    if (state.showAdmit){
      const gY = {re: -baseGamma.re, im: -baseGamma.im};
      plotMarker(gY, '#fde68a', 3 + mag*3, 'Y');
    }

    ctx.restore();

    // Stats for Top HUD - CRITICAL: FORMATTED FOR STABILITY
    const m = mag;
    const vs = vswrFromMag(m);
    const rl = rlFromMag(m);

    // Using formatValue for all HUD metrics to ensure fixed width and no jitter
    inputs.mag.textContent = formatValue(m, 0.001, { padInt: 1 }); // 0.XXX
    inputs.ang.textContent = `${formatValue(C.ang(baseGamma)*180/Math.PI, 0.1, { signed: true, padInt: 3 })}Â°`; // Â±XXX.XÂ°
    inputs.vswr.textContent = vs === Infinity ? '  âˆž' : formatValue(vs, 0.01, { padInt: 2 }); // XX.XX (space for sign to align, but no sign)
    inputs.rl.textContent = rl === Infinity ? '  âˆž dB' : `${formatValue(rl, 0.01, { signed: true, padInt: 2 })} dB`; // Â±XX.XX dB
    
    // Timbre & LFO for HUD
    const formattedQ = formatValue(state.filterQ, 0.1, { padInt: 2 }); // 00.0
    const formattedCO = formatValue(state.filterCutoffOffset, 1, { signed: true, padInt: 4 }); // Â±0000
    inputs.zread.textContent = `Q:${formattedQ}/CO:${formattedCO}Hz`;

    const formattedLFORate = formatValue(state.lfoRate, 0.1, { padInt: 1 }); // 0.0
    const formattedLFODepth = formatValue(state.lfoDepth, 0.01, { padInt: 1 }); // 0.00
    inputs.yread.textContent = `R:${formattedLFORate}/D:${formattedLFODepth}`;
  }

  function plotMarker(g, color, r=3, label){
    const p = toPX(g);
    // guard: only plot inside unit circle
    if (C.mag(g) > 1.0001) return;
    ctx.beginPath(); ctx.fillStyle=color; ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
    // label
    ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto'; ctx.textAlign='left'; ctx.textBaseline='middle';
    ctx.fillStyle='rgba(255,255,255,.8)';
    ctx.fillText(label, p.x+r+2, p.y);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();
    drawData();
    drawRings();
  }

  function drawRings(){
    // Draw rotary trim rings just outside the Smith chart
    const center = { x: CX, y: CY };
    const smithChartRadius = R;
    const ringInnerOffset = smithChartRadius * 0.08; // Gap between chart and first ring
    const ringBandWidth = 14;
    const ringSpacing = 10; // Space between rings

    const rSynthMid = smithChartRadius + ringInnerOffset + ringBandWidth/2;
    const rRadioMid = rSynthMid + ringBandWidth + ringSpacing + ringBandWidth/2;

    // Background bands
    ctx.beginPath(); ctx.arc(center.x, center.y, rSynthMid, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-purple', 0.2); ctx.lineWidth = ringBandWidth; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rRadioMid, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-green', 0.2); ctx.lineWidth = ringBandWidth; ctx.stroke();

    // Filled arcs indicating current trims
    ctx.beginPath(); ctx.arc(center.x, center.y, rSynthMid, 0, ringSynthAngle); ctx.strokeStyle = varToRgba('--neon-purple', 0.8); ctx.lineWidth = ringBandWidth; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rRadioMid, 0, ringRadioAngle); ctx.strokeStyle = varToRgba('--neon-green', 0.8); ctx.lineWidth = ringBandWidth; ctx.stroke();

    // Outer/inner outlines
    const rSynthInner = rSynthMid - ringBandWidth/2;
    const rSynthOuter = rSynthMid + ringBandWidth/2;
    const rRadioInner = rRadioMid - ringBandWidth/2;
    const rRadioOuter = rRadioMid + ringBandWidth/2;
    ctx.beginPath(); ctx.arc(center.x, center.y, rSynthInner, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-purple', 0.4); ctx.lineWidth = 2; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rSynthOuter, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-purple', 0.4); ctx.lineWidth = 2; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rRadioInner, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-green', 0.4); ctx.lineWidth = 2; ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, rRadioOuter, 0, Math.PI*2); ctx.strokeStyle = varToRgba('--neon-green', 0.4); ctx.lineWidth = 2; ctx.stroke();


    // Ticks and 10% labels
    const tickCount = 100, tickLen = 6;
    ctx.lineWidth = 2; ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto'; ctx.textAlign='center'; ctx.textBaseline='middle';
    for(let i=0;i<tickCount;i++){
      const a = i * (2*Math.PI/tickCount);
      const major10 = (i % 10 === 0);
      
      // Synth ticks (inward from outer edge of ring band)
      let x1s = center.x + (rSynthOuter - (major10?14:tickLen)) * Math.cos(a), y1s = center.y + (rSynthOuter - (major10?14:tickLen)) * Math.sin(a);
      let x2s = center.x + rSynthOuter * Math.cos(a), y2s = center.y + rSynthOuter * Math.sin(a);
      ctx.beginPath(); ctx.moveTo(x1s,y1s); ctx.lineTo(x2s,y2s); ctx.strokeStyle = varToRgba('--neon-purple', major10?0.5:0.25); ctx.stroke();
      
      // Radio ticks (outward from inner edge of ring band)
      let x1r = center.x + (rRadioInner + (major10?14:tickLen)) * Math.cos(a), y1r = center.y + (rRadioInner + (major10?14:tickLen)) * Math.sin(a);
      let x2r = center.x + rRadioInner * Math.cos(a), y2r = center.y + rRadioInner * Math.sin(a);
      ctx.beginPath(); ctx.moveTo(x1r,y1r); ctx.lineTo(x2r,y2r); ctx.strokeStyle = varToRgba('--neon-green', major10?0.5:0.25); ctx.stroke();
      
      if (major10){
        const label = `${i}%`;
        // Synth labels (inward from ring band)
        const lx1 = center.x + (rSynthOuter - 24) * Math.cos(a), ly1 = center.y + (rSynthOuter - 24) * Math.sin(a);
        ctx.fillStyle = varToRgba('--neon-purple', 0.8); ctx.fillText(label, lx1, ly1);
        
        // Radio labels (outward from ring band)
        const lx2 = center.x + (rRadioInner + 24) * Math.cos(a), ly2 = center.y + (rRadioInner + 24) * Math.sin(a);
        ctx.fillStyle = varToRgba('--neon-green', 0.8); ctx.fillText(label, lx2, ly2);
      }
    }

    // Handles
    const hsx = center.x + rSynthMid * Math.cos(ringSynthAngle);
    const hsy = center.y + rSynthMid * Math.sin(ringSynthAngle);
    const hrx = center.x + rRadioMid * Math.cos(ringRadioAngle);
    const hry = center.y + rRadioMid * Math.sin(ringRadioAngle);
    ctx.beginPath(); ctx.arc(hsx, hsy, 6, 0, Math.PI*2); ctx.fillStyle = varToRgba('--neon-purple', 0.9); ctx.shadowColor = varToRgba('--neon-purple',1); ctx.shadowBlur=12; ctx.fill(); ctx.shadowBlur=0;
    ctx.beginPath(); ctx.arc(hrx, hry, 6, 0, Math.PI*2); ctx.fillStyle = varToRgba('--neon-green', 0.9); ctx.shadowColor = varToRgba('--neon-green',1); ctx.shadowBlur=12; ctx.fill(); ctx.shadowBlur=0;

    // Numeric values
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
    ctx.fillStyle = varToRgba('--neon-purple', 1); ctx.fillText(`${Math.round(state.ringSynthTrim*100)}%`, hsx + 15*Math.cos(ringSynthAngle), hsy + 15*Math.sin(ringSynthAngle));
    ctx.fillStyle = varToRgba('--neon-green', 1); ctx.fillText(`${Math.round(state.ringRadioTrim*100)}%`, hrx + 15*Math.cos(ringRadioAngle), hry + 15*Math.sin(ringRadioAngle));
  }

  function updateRingFromPoint(which, dx, dy){
    const ang = Math.atan2(dy, dx); // -Ï€..Ï€
    let a = (ang>=0? ang : (2*Math.PI+ang)); // 0..2Ï€
    let detCount = (ringSnapMode==='fine') ? RING_DETENTS_FINE : (ringSnapMode==='coarse' ? RING_DETENTS_COARSE : 0);
    let det = -1, snapped = a;
    if (detCount>0){ det = Math.round(a / (2*Math.PI/detCount)); snapped = det * (2*Math.PI/detCount); }

    if (which==='synth'){
      ringSynthAngle = snapped;
      state.ringSynthTrim = Math.max(0, Math.min(1, snapped/(2*Math.PI)));
    } else { // 'radio'
      ringRadioAngle = snapped;
      state.ringRadioTrim = Math.max(0, Math.min(1, snapped/(2*Math.PI)));
    }
  }

  // --- Web Audio API Integration ---
  // Envelope Follower for Multiply Blend Mode
  function getSynthEnv(){
    if (!synthAnalyser) return 0;
    const buffer = new Uint8Array(synthAnalyser.frequencyBinCount);
    synthAnalyser.getByteTimeDomainData(buffer);
    // RMS of centered signal
    let sum=0; for(let i=0;i<buffer.length;i++){ const v=(buffer[i]-128)/128; sum+=v*v; }
    let rms = Math.sqrt(sum/buffer.length); // 0..~1
    // scale up a bit and apply attack/release smoothing
    const raw = Math.min(1, rms * SYNTH_ENV_SCALE);
    const atk = 0.3;  // faster rise
    const rel = 0.08; // slower fall
    const a = raw > synthEnvelopePrev ? atk : rel;
    synthEnvelopePrev = synthEnvelopePrev + a*(raw - synthEnvelopePrev);
    return synthEnvelopePrev;
  }

  function initAudio() {
    if (isAudioReady) return;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      // Master gain (final output to speakers)
      masterGain = audioCtx.createGain();
      masterGain.gain.value = AUDIO_MASTER_GAIN; // Overall default output level
      // Monitor path that can be toggled by parent mixer
      monitorGain = audioCtx.createGain();
      monitorGain.gain.value = 1.0; // monitor ON by default
      masterGain.connect(monitorGain);
      monitorGain.connect(audioCtx.destination);

      // For Recording
      destinationStream = audioCtx.createMediaStreamDestination();
      masterGain.connect(destinationStream);

      // Main Oscillator path
      osc = audioCtx.createOscillator();
      osc.type = state.waveform;
      osc.frequency.value = state.freqHz;
      osc.start();

      filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = state.freqHz;
      filter.Q.value = state.filterQ;
      osc.connect(filter);

      synthAmplitudeGain = audioCtx.createGain(); // Controls synth base volume by |Gamma| and LFO
      synthAmplitudeGain.gain.value = 0; // Will be set by updateAudioParameters
      filter.connect(synthAmplitudeGain); 

      // --- LFO setup for additive tremolo ---
      lfo = audioCtx.createOscillator();
      lfo.type = 'sine'; // LFO typically sine for tremolo
      lfo.frequency.value = state.lfoRate;
      lfo.start();

      lfoModulatorGain = audioCtx.createGain(); // Scales LFO output by depth
      lfoModulatorGain.gain.value = state.lfoDepth * LFO_MODULATION_SCALE; // Initial value, will be updated
      lfo.connect(lfoModulatorGain); // LFO output goes to this gain node

      // Connect the LFO modulator output to *add* to synthAmplitudeGain's gain parameter
      lfoModulatorGain.connect(synthAmplitudeGain.gain);

      // Synth Analyser for Multiply Blend Mode
      synthAnalyser = audioCtx.createAnalyser();
      synthAnalyser.fftSize = 512;
      synthEnvelopeFollowerGain = audioCtx.createGain(); // For tap-off for envelope follower
      synthAmplitudeGain.connect(synthEnvelopeFollowerGain); // Tap from after LFO and Chart Amp
      synthEnvelopeFollowerGain.connect(synthAnalyser);

      synthChannelGain = audioCtx.createGain(); // Gain for blend control
      synthAmplitudeGain.connect(synthChannelGain); // Connect amplitude gain to blend channel

      // --- Radio specific audio nodes ---
      radioFilter = audioCtx.createBiquadFilter();
      radioFilter.type = 'lowpass';
      radioFilter.frequency.value = MAX_FREQ; // Start wide open
      radioFilter.Q.value = 0.707; // Flat response

      radioPreGain = audioCtx.createGain(); // Radio's independent volume control
      radioPreGain.gain.value = state.ringRadioTrim; // **Directly controlled by ring trim**

      radioPanner = audioCtx.createStereoPanner();
      radioPanner.pan.value = 0; // Centered

      // Radio Analyser for Auto Match
      radioAnalyser = audioCtx.createAnalyser();
      radioAnalyser.fftSize = 512;
      radioPreGain.connect(radioAnalyser); // Tap from after radioPreGain

      // Radio Chain: mediaNode -> radioFilter -> radioPreGain -> radioPanner -> radioChannelGain
      // mediaNode connected in connectRadio()
      radioFilter.connect(radioPreGain);
      radioPreGain.connect(radioPanner);

      radioChannelGain = audioCtx.createGain(); // Gain for blend control
      radioPanner.connect(radioChannelGain);

      // Phase Flipper for Difference Blend Mode
      phaseFlipperGain = audioCtx.createGain();
      phaseFlipperGain.gain.value = 1; // Default to 1 (no inversion), set to -1 for difference mode


      // Main mix bus where synth and radio signals are combined
      mainOutputBus = audioCtx.createGain();
      synthChannelGain.connect(mainOutputBus);
      // Radio channel connects via phaseFlipperGain to allow difference blending
      radioChannelGain.connect(phaseFlipperGain);
      phaseFlipperGain.connect(mainOutputBus);


      // Global Dry/Wet Delay setup
      dryMixer = audioCtx.createGain();
      delaySendGain = audioCtx.createGain(); // How much of the blended signal goes to delay
      delayReturnGain = audioCtx.createGain(); // How much of the delayed signal comes back

      delay = audioCtx.createDelay(1.0); // Max 1 second delay
      delayFeedbackGain = audioCtx.createGain(); // Feedback loop for delay

      // Route mainOutputBus to dryMixer (dry path) and delaySendGain (wet path)
      mainOutputBus.connect(dryMixer);
      mainOutputBus.connect(delaySendGain);

      dryMixer.connect(masterGain); // Dry signal goes to master

      delaySendGain.connect(delay); // Send signal to delay unit
      delay.connect(delayFeedbackGain); // Delay output feeds back
      delayFeedbackGain.connect(delay); // Feedback loop
      delay.connect(delayReturnGain); // Delayed signal return
      delayReturnGain.connect(masterGain); // Wet signal goes to master

      // Default values for delay
      delay.delayTime.value = state.delayTimeMs / 1000;
      delayFeedbackGain.gain.value = state.delayFeedback;


      // Complementary Timbre (oscY, filterY)
      oscY = audioCtx.createOscillator();
      oscY.type = state.waveform;
      oscY.frequency.value = state.freqHz * 1.005; // Slightly detuned
      oscY.start();

      filterY = audioCtx.createBiquadFilter();
      filterY.type = 'highpass'; // Different filter type for contrast
      filterY.frequency.value = state.freqHz * 0.9;
      filterY.Q.value = state.filterQ;
      oscY.connect(filterY);
      filterY.connect(masterGain); // Direct to master for complementary timbre


      isAudioReady = true;
      console.log("AudioContext initialized with blend and global delay effect!");
      updateAudioParameters(); // Set initial audio state
    } catch (e) {
      console.error("Web Audio API not supported or failed to initialize:", e);
      // Fallback or user notification here
    }
  }

  function updateAudioParameters() {
    if (!isAudioReady) return;

    // Use current state to derive gamma, then update audio params
    const baseGamma = state.fromTap ? state.gamma : computeGammaFromInputs();
    const mag = C.mag(baseGamma);

    // Apply mappings to main synth oscillator
    osc.type = state.waveform;
    osc.frequency.value = Math.max(MIN_FREQ, Math.min(MAX_FREQ, state.freqHz)); // Clamp frequency

    filter.Q.value = Math.min(MAX_Q, Math.max(MIN_Q, state.filterQ));
    filter.frequency.value = Math.min(MAX_FREQ, Math.max(MIN_FREQ, state.freqHz + state.filterCutoffOffset));

    // Update LFO frequency
    lfo.frequency.value = Math.min(20, Math.max(0, state.lfoRate));

    // Update LFO modulator gain to scale LFO output by state.lfoDepth
    lfoModulatorGain.gain.setValueAtTime(state.lfoDepth * LFO_MODULATION_SCALE, audioCtx.currentTime); // LFO goes from -1 to 1, so depth/2 for +/- range

    // Update synth base amplitude, scaled by ring trim.
    // The LFO will then *add* its scaled output to this base value.
    synthAmplitudeGain.gain.setValueAtTime(Math.min(1, Math.max(0, mag * state.ringSynthTrim)), audioCtx.currentTime);


    // Update global delay controls
    delay.delayTime.value = Math.min(1, Math.max(0, state.delayTimeMs / 1000));
    delayFeedbackGain.gain.value = Math.min(0.99, Math.max(0, state.delayFeedback));

    // Calculate dry/wet for the delay based on feedback amount
    const delayWetAmount = state.delayFeedback;
    delaySendGain.gain.value = (state.delayTimeMs > 0 && delayWetAmount > 0) ? 1 : 0; // Only send to delay if delay time & feedback > 0
    delayReturnGain.gain.value = delayWetAmount; // Wet mix controlled by feedback
    dryMixer.gain.value = 1 - delayWetAmount; // Dry mix is inverse

    // Complementary timbre logic
    if (state.showAdmit) {
      oscY.type = state.waveform;
      oscY.frequency.value = Math.max(MIN_FREQ, Math.min(MAX_FREQ, state.freqHz * 1.005));
      filterY.Q.value = Math.min(MAX_Q, Math.max(MIN_Q, state.filterQ));
      filterY.frequency.value = Math.min(MAX_FREQ, Math.max(MIN_FREQ, state.freqHz * 0.9));
      // Ensure it's connected and playing
      if (filterY.numberOfInputs < 1) oscY.connect(filterY); // Only connect if not already
      if (filterY.numberOfOutputs < 1) filterY.connect(masterGain); // Only connect if not already
    } else {
      // Disconnect if not shown
      if (oscY.numberOfOutputs > 0) oscY.disconnect(filterY);
      if (filterY.numberOfOutputs > 0) filterY.disconnect(masterGain);
    }

    // Update radio base gain (independent volume, controlled by ring trim)
    if (radioPreGain) radioPreGain.gain.value = state.ringRadioTrim;

    // --- Apply Blend Mode ---
    switch (state.blendMode) {
        case 'crossfade':
            synthChannelGain.gain.value = (1 - state.blendAmount);
            radioChannelGain.gain.value = state.blendAmount;
            phaseFlipperGain.gain.value = 1; // Ensure no phase inversion
            break;
        case 'sum':
            synthChannelGain.gain.value = 1; // Synth always at full (modulated by mag and LFO)
            radioChannelGain.gain.value = state.blendAmount; // Radio blended in
            phaseFlipperGain.gain.value = 1; // Ensure no phase inversion
            break;
        case 'multiply': { // AM Modulation: radio ducked by synth envelope
            const synthEnv = getSynthEnv();
            const modulationFactor = Math.pow(synthEnv, SYNTH_ENV_POWER); // Perceptual emphasis
            const modulatedRadioGain = ((1 - state.blendAmount) + state.blendAmount * (modulationFactor));
            radioChannelGain.gain.setValueAtTime(modulatedRadioGain, audioCtx.currentTime);
            synthChannelGain.gain.value = 1; // Synth always at full
            phaseFlipperGain.gain.value = 1; // Ensure no phase inversion
            break;
        }
        case 'difference':
            synthChannelGain.gain.value = 1;
            radioChannelGain.gain.value = state.blendAmount;
            phaseFlipperGain.gain.value = -1; // Invert phase of radio
            break;
        default: // Default to crossfade if unknown
            synthChannelGain.gain.value = 1 - state.blendAmount;
            radioChannelGain.gain.value = state.blendAmount;
            phaseFlipperGain.gain.value = 1;
            break;
    }
  }

  // --- Radio Controls Functions ---
  let customUrlOption = document.createElement('option');
  customUrlOption.value = 'custom-loaded';
  customUrlOption.textContent = 'Custom Stream (Loaded)';
  customUrlOption.style.display = 'none';

  function setRadioStatus(text){ inputs.radioStatus.textContent = text; }
  function hostnameOf(u){ try{ return new URL(u).hostname; }catch{ return ''; } }
  function isBlockedUrl(u){ try{ const h=new URL(u).hostname.replace(/^www\./,''); return h.endsWith('youtube.com')||h.endsWith('youtu.be')||h.endsWith('vimeo.com'); }catch{ return false; } }

  function connectRadio(url){
      if (!isAudioReady) initAudio(); // Ensure audio context is initialized
      disconnectRadio();
      if (!url || url === 'off'){
          setRadioStatus('Stopped');
          radioEnabled=false;
          state.radioUrl = 'off'; // Update state
          inputs.radioSource.value = 'off';
          inputs.radioNow.textContent = 'â€”';
          inputs.customUrlInputContainer.style.display = 'none';
          if (inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
              inputs.radioSource.removeChild(customUrlOption);
          }
          return;
      }
      if (isBlockedUrl(url)){
          setRadioStatus('Blocked by CORS policy (YouTube/Vimeo likely)');
          alert('YouTube/Vimeo URLs are typically blocked by browser security policies (CORS). Please use direct MP3/AAC stream links.');
          state.radioUrl = 'off'; // Update state
          inputs.radioSource.value = 'off';
          inputs.radioNow.textContent = 'â€”';
          return;
      }

      mediaEl = new Audio();
      mediaEl.crossOrigin='anonymous'; // Crucial for Web Audio API analysis/processing
      mediaEl.src = url;
      mediaEl.loop = true;
      mediaEl.preload='none';

      mediaEl.addEventListener('error', (e)=> {
          console.error('Media element error:', e);
          setRadioStatus('Error loading stream');
          state.radioUrl = 'off'; // Update state
          inputs.radioSource.value = 'off';
          inputs.radioNow.textContent = 'â€”';
      });
      mediaEl.addEventListener('waiting', ()=> setRadioStatus('Bufferingâ€¦'));
      mediaEl.addEventListener('stalled', ()=> setRadioStatus('Bufferingâ€¦'));
      mediaEl.addEventListener('playing', ()=> setRadioStatus('Playing'));
      mediaEl.addEventListener('pause', ()=> setRadioStatus('Paused'));

      // Connect media element to audio graph
      mediaNode = audioCtx.createMediaElementSource(mediaEl);
      mediaNode.connect(radioFilter);

      inputs.radioNow.textContent = hostnameOf(url) || 'Stream';
      state.radioUrl = url; // Update state with the playing URL

      mediaEl.play().then(() => {
          radioEnabled = true;
          // If a custom URL was just loaded, set the dropdown to reflect it
          if (url === inputs.dynamicRadioUrl.value && inputs.dynamicRadioUrl.value !== '') {
              if (!inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
                  inputs.radioSource.appendChild(customUrlOption);
              }
              customUrlOption.style.display = 'block';
              inputs.radioSource.value = 'custom-loaded';
              inputs.customUrlInputContainer.style.display = 'none'; // Hide custom input after successful load
          }
      }).catch((e)=>{
          console.warn('[Radio] Autoplay failed or stream error:', e);
          setRadioStatus('Error: Play failed/blocked (CORS?)');
          radioEnabled = false;
          state.radioUrl = 'off'; // Update state on failure
          // If custom URL failed, keep custom input visible for retry
          if (url === inputs.dynamicRadioUrl.value) {
              inputs.customUrlInputContainer.style.display = 'flex';
          }
          inputs.radioSource.value = 'off';
          inputs.radioNow.textContent = 'â€”';
      });
  }

  function disconnectRadio(){
      try{ if (mediaEl){ mediaEl.pause(); mediaEl.src=''; } }catch{}
      try{ if (mediaNode){ mediaNode.disconnect(); } }catch{}
      mediaEl=null; mediaNode=null; radioEnabled=false;
      state.radioUrl = 'off'; // Update state
      if (inputs.radioSource.value === 'custom-loaded') {
          // If a custom stream was active, revert to "Add Custom Stream URL..." visually
          inputs.radioSource.value = 'custom-url';
          inputs.customUrlInputContainer.style.display = 'flex'; // Show input field for re-entry
      }
      setRadioStatus('Stopped');
      inputs.radioNow.textContent = 'â€”';
  }

  // Local File support
  let localFileInput = null;
  function ensureLocalFileUI(){
    try{
      if (!inputs.radioSource.querySelector('option[value="local-file"]')){
        const opt=document.createElement('option'); opt.value='local-file'; opt.textContent='Local Fileâ€¦'; inputs.radioSource.appendChild(opt);
      }
      if (!localFileInput){
        localFileInput = document.createElement('input');
        localFileInput.type='file'; localFileInput.accept='audio/*'; localFileInput.style.display='none';
        document.body.appendChild(localFileInput);
        localFileInput.addEventListener('change', ()=>{
          const f = localFileInput.files && localFileInput.files[0]; if (!f) return;
          const url = URL.createObjectURL(f);
          connectRadio(url);
          inputs.radioNow.textContent = `Local: ${f.name}`;
          setRadioStatus('Playing');
          try{ inputs.radioSource.value='local-file'; }catch{}
        });
      }
    }catch(err){ console.warn('[LocalFileUI] init failed', err); }
  }

  function setupDragDrop(){
    try{
      const el = canvas;
      ['dragenter','dragover'].forEach(ev=> el.addEventListener(ev, e=>{ e.preventDefault(); e.dataTransfer.dropEffect='copy'; }));
      el.addEventListener('drop', e=>{
        e.preventDefault();
        const f = e.dataTransfer?.files && e.dataTransfer.files[0];
        if (f && f.type.startsWith('audio/')){
          const url = URL.createObjectURL(f);
          connectRadio(url);
          inputs.radioNow.textContent = `Drop: ${f.name}`;
          setRadioStatus('Playing');
          try{ inputs.radioSource.value='local-file'; }catch{}
        }
      });
    }catch(err){ console.warn('[DnD] setup failed', err); }
  }

  inputs.radioSource.addEventListener('change', (e)=>{
      vibrate();
      initAudio(); // Ensure audio context is ready on first interaction
      const selectedValue = e.target.value;

      if (selectedValue === 'off'){
          disconnectRadio();
      } else if (selectedValue === 'local-file'){
          // Show file picker for local audio
          ensureLocalFileUI();
          localFileInput?.click();
      } else if (selectedValue === 'custom-url'){
          // Show custom URL input field
          inputs.customUrlInputContainer.style.display = 'flex';
          inputs.dynamicRadioUrl.value = state.radioUrl === 'off' ? '' : state.radioUrl; // Pre-fill if custom URL was previously loaded
          inputs.dynamicRadioUrl.focus();
          setRadioStatus('Enter stream URL');
          // If custom-loaded option exists, remove it when user opts to add a new custom URL
          if (inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
              inputs.radioSource.removeChild(customUrlOption);
          }
          state.radioUrl = 'off'; // No specific URL active yet
      } else if (selectedValue === 'custom-loaded') {
          // This option means a custom stream is currently playing/loaded.
          // If user selects it from dropdown, just ensure custom input is visible in case they want to modify/reload.
          inputs.customUrlInputContainer.style.display = 'flex';
          inputs.dynamicRadioUrl.value = state.radioUrl; // Should be pre-filled from state
          inputs.dynamicRadioUrl.focus();
          // The stream should already be connected. If not, connect again using the URL from state.
          if (!mediaEl || !mediaNode) {
              connectRadio(state.radioUrl);
          }
      } else {
          // A predefined stream is selected
          inputs.customUrlInputContainer.style.display = 'none';
          if (inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
              inputs.radioSource.removeChild(customUrlOption); // Remove "Custom Stream (Loaded)"
          }
          connectRadio(selectedValue);
      }
      updateAudioParameters(); // Ensure blend/volume applies immediately
      updateHash(false); // Update hash for radio source
  });

  inputs.loadCustomRadioBtn.addEventListener('click', () => {
      vibrate();
      const url = inputs.dynamicRadioUrl.value.trim();
      if (url) {
          console.log('[Radio] Loading custom URL:', url);
          connectRadio(url);
          // Set dropdown to custom-loaded after successful load
          if (!inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
              inputs.radioSource.appendChild(customUrlOption);
          }
          customUrlOption.style.display = 'block';
          inputs.radioSource.value = 'custom-loaded';
          inputs.customUrlInputContainer.style.display = 'none';
          updateHash(false);
      } else {
          setRadioStatus('Please enter a URL');
      }
  });

  // --- Mic Input Logic ---
  inputs.micInputToggle.addEventListener('click', async () => {
    vibrate();
    initAudio();
    state.micInputEnabled = !state.micInputEnabled;

    if (state.micInputEnabled) {
      try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        inputs.micInputToggle.classList.add('active');
        inputs.micInputToggle.textContent = 'Mic Input ON';

        micInputSource = audioCtx.createMediaStreamSource(micStream);
        micAnalyserNode = audioCtx.createAnalyser();
        micAnalyserNode.fftSize = 2048; // Can use for future visualization if needed
        micGainNode = audioCtx.createGain();
        micGainNode.gain.value = MIC_DEFAULT_GAIN; // Default mic gain, can be a slider later

        micInputSource.connect(micGainNode);
        micGainNode.connect(mainOutputBus); // Route mic to main output bus
        console.log('Microphone input enabled.');
      } catch (err) {
        console.error('Error accessing microphone:', err);
        alert('Could not access microphone. Please ensure permissions are granted.');
        state.micInputEnabled = false;
        inputs.micInputToggle.textContent = 'Mic Input OFF';
        inputs.micInputToggle.classList.remove('active');
      }
    } else {
      if (micStream) {
        micStream.getTracks().forEach(track => track.stop());
        micInputSource.disconnect();
        micGainNode.disconnect();
        micAnalyserNode?.disconnect(); // Disconnect if it exists
        micStream = null;
      }
      inputs.micInputToggle.textContent = 'Mic Input OFF';
      inputs.micInputToggle.classList.remove('active');
      console.log('Microphone input disabled.');
    }
    updateHash(false);
  });

  // --- Recording Logic ---
  inputs.recordToggle.addEventListener('click', () => {
    vibrate();
    initAudio();
    state.isRecording = !state.isRecording;

    if (state.isRecording) {
      recordedChunks = [];
      const options = { mimeType: 'audio/webm; codecs=opus' };
      try {
        mediaRecorder = new MediaRecorder(destinationStream.stream, options);
      } catch (e) {
        console.error('MediaRecorder creation failed:', e);
        alert('Recording is not supported in this browser or an error occurred.');
        state.isRecording = false;
        return;
      }

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) recordedChunks.push(event.data);
      };

      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        document.body.appendChild(a);
        a.style.display = 'none';
        a.href = url;
        a.download = `smith_chart_sonifier_${new Date().toISOString()}.webm`;
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        recordedChunks = [];
        console.log('Recording saved.');
      };

      mediaRecorder.start();
      inputs.recordToggle.textContent = 'Recording...';
      inputs.recordToggle.classList.add('recording');
      console.log('Recording started.');
    } else {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
      inputs.recordToggle.textContent = 'Record';
      inputs.recordToggle.classList.remove('recording');
      console.log('Recording stopped.');
    }
    updateHash(false);
  });

  // --- Auto Match / Follow Logic ---
  function getRadioPeakHz(){
    try {
      if (!radioAnalyser || !audioCtx) return null;
      const data = new Uint8Array(radioAnalyser.frequencyBinCount);
      radioAnalyser.getByteFrequencyData(data);
      let maxV=0,maxI=0; for(let i=0;i<data.length;i++){ if(data[i]>maxV){maxV=data[i];maxI=i;} }
      return (maxI/data.length)*(audioCtx.sampleRate/2);
    } catch { return null; }
  }
  function autoMatchOnce(){
    vibrate();
    if (!radioEnabled || !radioAnalyser) return; // Only if radio is playing
    const hz = getRadioPeakHz(); if(!hz || hz<50) return;
    const freq = Math.max(MIN_FREQ, Math.min(1000, Math.round(hz)));
    state.freqHz = freq; inputs.freqHz.value = freq; inputs.freqHzRead.textContent = `${formatValue(freq, inputs.freqHz.step, { padInt: 4 })} Hz`;
    const cutoff = Math.max(100, Math.min(8000, Math.round(hz*3)));
    state.filterCutoffOffset = cutoff - state.freqHz; // Adjust offset based on new base freq
    inputs.filterCutoffOffset.value = state.filterCutoffOffset; inputs.filterCutoffOffsetRead.textContent = `${formatValue(state.filterCutoffOffset, inputs.filterCutoffOffset.step, { signed: true, padInt: 4 })} Hz`;
    state.fromTap = false; // Parameters set by auto-match, not tap
    draw(); updateAudioParameters(); updateHash(false);
    inputs.autoMatch.classList.add('active'); // Temporarily highlight
    setTimeout(() => inputs.autoMatch.classList.remove('active'), 200);
  }
  function setFollow(on){
    if(followTimer){clearInterval(followTimer);followTimer=null;}
    if(on){
      followTimer=setInterval(autoMatchOnce, 2000);
      inputs.followToggleBtn.classList.add('active'); // Update toggle button
      inputs.followToggleBtn.setAttribute('aria-checked', true);
    } else {
      inputs.followToggleBtn.classList.remove('active'); // Update toggle button
      inputs.followToggleBtn.setAttribute('aria-checked', false);
    }
    state.autoMatchFollow = on;
    updateHash(false);
  }
  inputs.autoMatch.addEventListener('click', autoMatchOnce);
  // Event for checkbox inside the pill-btn
  inputs.followToggle.addEventListener('change', e => { vibrate(); setFollow(e.target.checked); });
  // Event for the pill-btn itself
  inputs.followToggleBtn.addEventListener('click', () => {
      inputs.followToggle.checked = !inputs.followToggle.checked;
      vibrate();
      setFollow(inputs.followToggle.checked);
  });

  // --- UI Event Handlers ---

  // Helper to format readout based on step
  const formatValue = (value, step, options = {}) => {
    const { signed = false, padInt = 0 } = options;
    if (value === null || value === undefined || isNaN(value)) {
        // Handle non-numeric values explicitly for placeholders if needed
        return signed ? ` ${'-'.repeat(padInt)}` : '-'.repeat(padInt);
    }
    
    // Determine precision from step
    let precision = 0;
    if (step !== undefined && step !== null && step.toString().includes('.')) {
        precision = step.toString().split('.')[1].length;
    }
    let formattedNum = parseFloat(value).toFixed(precision);

    // Handle sign and integer padding
    let signChar = '';
    let integerPart = formattedNum.split('.')[0];
    let decimalPart = formattedNum.split('.')[1] || '';

    if (integerPart.startsWith('-')) {
        signChar = '-';
        integerPart = integerPart.substring(1);
    } else if (signed && value > 0) {
        signChar = '+';
    } else if (signed) { // For 0 or negative values when `signed` is true, or just reserving space.
        signChar = ' '; // Pad with space if no sign needed but `signed` requests fixed sign width
    }
    
    // Pad integer part with leading zeros
    // padInt ensures minimum digits, not including the sign.
    integerPart = integerPart.padStart(padInt, '0');

    // Reconstruct the formatted string
    let finalFormatted = `${signChar}${integerPart}${decimalPart ? '.' + decimalPart : ''}`;

    return finalFormatted;
  };


  const sliderChangeHandler = (e, readout, unit = '', options = {}) => {
      vibrate(10); // Subtle haptic on slider movement
      const val = parseFloat(e.target.value) || 0;
      state[e.target.id] = val;
      if (readout) readout.textContent = `${formatValue(val, parseFloat(e.target.step), options)} ${unit}`.trim();
      state.fromTap = false;
      draw();
      updateAudioParameters();
      updateHash(false);
  };

  inputs.z0.addEventListener('input', (e) => sliderChangeHandler(e, inputs.z0Read, '', { padInt: 3 }));
  inputs.freqHz.addEventListener('input', (e) => sliderChangeHandler(e, inputs.freqHzRead, 'Hz', { padInt: 4 }));
  inputs.filterQ.addEventListener('input', (e) => sliderChangeHandler(e, inputs.filterQRead, '', { padInt: 2 }));
  inputs.filterCutoffOffset.addEventListener('input', (e) => sliderChangeHandler(e, inputs.filterCutoffOffsetRead, 'Hz', { signed: true, padInt: 4 }));
  inputs.lfoRate.addEventListener('input', (e) => sliderChangeHandler(e, inputs.lfoRateRead, 'Hz', { padInt: 1 }));
  inputs.lfoDepth.addEventListener('input', (e) => sliderChangeHandler(e, inputs.lfoDepthRead, '', { padInt: 1 }));
  inputs.delayTimeMs.addEventListener('input', (e) => sliderChangeHandler(e, inputs.delayTimeRead, 'ms', { padInt: 4 }));
  inputs.delayFeedback.addEventListener('input', (e) => sliderChangeHandler(e, inputs.delayFeedbackRead, '', { padInt: 1 }));
  inputs.blendAmount.addEventListener('input', (e) => sliderChangeHandler(e, inputs.blendAmountRead, '', { padInt: 1 }));


  inputs.blendMode.addEventListener('change', (e)=>{
      vibrate();
      state.blendMode = e.target.value;
      document.querySelectorAll('#dashboard [data-listen-preset]').forEach(btn => btn.classList.remove('active'));
      updateAudioParameters(); updateHash(false);
  });
  
  inputs.waveformRadios.forEach(radio => {
    radio.addEventListener('change', () => { vibrate(); state.waveform = radio.value; state.fromTap=false; draw(); updateAudioParameters(); updateHash(false); });
  });
  
  // Toggle button logic for checkboxes
  inputs.showAdmitToggle.addEventListener('click', () => {
    vibrate();
    inputs.showAdmit.checked = !inputs.showAdmit.checked;
    state.showAdmit = inputs.showAdmit.checked;
    inputs.showAdmitToggle.classList.toggle('active', state.showAdmit);
    inputs.showAdmitToggle.setAttribute('aria-checked', state.showAdmit);
    draw(); updateAudioParameters(); updateHash(false);
  });
  inputs.hiGridToggle.addEventListener('click', () => {
    vibrate();
    inputs.hiGrid.checked = !inputs.hiGrid.checked;
    state.hiGrid = inputs.hiGrid.checked;
    inputs.hiGridToggle.classList.toggle('active', state.hiGrid);
    inputs.hiGridToggle.setAttribute('aria-checked', state.hiGrid);
    draw(); updateHash(false);
  });


  // --- Listen Preset Buttons Logic ---
  document.querySelectorAll('#dashboard [data-listen-preset]').forEach(btn => {
    btn.addEventListener('click', () => {
      vibrate();
      initAudio();
      const preset = btn.dataset.listenPreset;
      let newBlendMode = state.blendMode;
      let newBlendAmount = state.blendAmount;

      document.querySelectorAll('#dashboard [data-listen-preset]').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      if (preset === 'mix') {
        newBlendMode = 'crossfade';
        newBlendAmount = 0.5;
      } else if (preset === 'radio') {
        newBlendMode = 'sum';
        newBlendAmount = 1.0;
        if (!radioEnabled && state.radioUrl === 'off') {
            connectRadio('https://ice4.somafm.com/groovesalad-128-mp3');
        } else if (!radioEnabled && state.radioUrl !== 'off') {
            connectRadio(state.radioUrl);
        }
      } else if (preset === 'synth') {
        newBlendMode = 'sum';
        newBlendAmount = 0.0;
      }

      state.blendMode = newBlendMode;
      state.blendAmount = newBlendAmount;
      inputs.blendMode.value = newBlendMode;
      inputs.blendAmount.value = newBlendAmount;
      inputs.blendAmountRead.textContent = formatValue(newBlendAmount, inputs.blendAmount.step);
      updateAudioParameters();
      updateHash(false);
    });
  });

  // --- Global Actions & Interface Controls ---
  inputs.reset.addEventListener('click', ()=>{ 
    vibrate();
    Object.assign(state,{
      z0:50, freqHz:440, filterQ:1, filterCutoffOffset:0, lfoRate:0, lfoDepth:0, delayTimeMs:0, delayFeedback:0.4, 
      waveform:'sine', showAdmit:false, hiGrid:true, blendMode:'crossfade', blendAmount:0.5,
      micInputEnabled:false, isRecording:false, autoMatchFollow:false,
      ringSynthTrim: 1.0, ringRadioTrim: 1.0, // Reset ring trims
      radioUrl: 'off', // Reset radio URL
      gamma:{re:0,im:0}, fromTap:false,
      isDashboardHidden: false, // Reset dashboard visibility
      collapsedGroups: {} // Reset collapsed state for all groups
    }); 
    disconnectRadio(); // Also reset radio
    setFollow(false); // Stop follow
    inputs.micInputToggle.classList.remove('active'); // Deactivate mic button
    inputs.recordToggle.classList.remove('recording'); // Deactivate record button
    document.querySelectorAll('#dashboard [data-listen-preset]').forEach(b => b.classList.remove('active')); // Deactivate listen presets
    
    // Clear localStorage for collapsed groups
    Object.keys(localStorage).forEach(key => {
        if (key.startsWith('pillGroup_')) localStorage.removeItem(key);
    });

    syncToUI(); draw(); updateAudioParameters(); updateHash(false); 
  });

  inputs.share.addEventListener('click', ()=>{ vibrate(); const url = updateHash(true); navigator.clipboard?.writeText(url); flash('Copied shareable URL to clipboard'); });
  inputs.helpBtn.addEventListener('click', ()=>{ vibrate(); inputs.help.classList.toggle('show'); });

  inputs.fullscreenToggle.addEventListener('click', () => {
      vibrate();
      if (document.fullscreenElement) {
          document.exitFullscreen();
      } else {
          document.documentElement.requestFullscreen().catch(err => {
              console.error(`Error attempting to enable fullscreen: ${err.message} (${err.name})`);
              alert('Fullscreen not supported or allowed by your browser.');
          });
      }
  });

  inputs.hideMenuToggle.addEventListener('click', () => {
      vibrate();
      state.isDashboardHidden = !state.isDashboardHidden;
      $('#dashboard').classList.toggle('hidden', state.isDashboardHidden);
      inputs.hideMenuToggle.textContent = state.isDashboardHidden ? 'â–²' : 'â–¼'; // Update glyph
      resize(); // Recalculate canvas size
      updateHash(false);
  });

  // --- Collapsible Group Logic ---
  const pillGroups = document.querySelectorAll('.pill-group');
  pillGroups.forEach(group => {
      const header = group.querySelector('.pill-group-header');
      const content = group.querySelector('.pill-group-content');
      const groupId = group.id;

      // Set initial ARIA attributes
      header.setAttribute('id', `${groupId}Header`);
      content.setAttribute('id', `${groupId}Content`);
      header.setAttribute('aria-controls', `${groupId}Content`);

      header.addEventListener('click', () => {
          vibrate();
          const isCollapsed = !group.classList.contains('collapsed'); // Determine new state
          group.classList.toggle('collapsed', isCollapsed);
          header.setAttribute('aria-expanded', !isCollapsed);
          state.collapsedGroups[groupId] = isCollapsed;
          localStorage.setItem(`pillGroup_${groupId}_collapsed`, isCollapsed);
          resize(); // Recalculate dashboard height after collapse/expand
      });
  });


  // --- Sync UI with State ---
  function syncToUI(){
    // Sliders & Number inputs (using formatValue with specific padInt/signed for stability)
    inputs.z0.value = state.z0; inputs.z0Read.textContent = formatValue(state.z0, inputs.z0.step, { padInt: 3 });
    inputs.freqHz.value = state.freqHz; inputs.freqHzRead.textContent = `${formatValue(state.freqHz, inputs.freqHz.step, { padInt: 4 })} Hz`;
    inputs.filterQ.value = state.filterQ; inputs.filterQRead.textContent = formatValue(state.filterQ, inputs.filterQ.step, { padInt: 2 });
    inputs.filterCutoffOffset.value = state.filterCutoffOffset; inputs.filterCutoffOffsetRead.textContent = `${formatValue(state.filterCutoffOffset, inputs.filterCutoffOffset.step, { signed: true, padInt: 4 })} Hz`; 
    inputs.lfoRate.value = state.lfoRate; inputs.lfoRateRead.textContent = `${formatValue(state.lfoRate, inputs.lfoRate.step, { padInt: 1 })} Hz`;
    inputs.lfoDepth.value = state.lfoDepth; inputs.lfoDepthRead.textContent = formatValue(state.lfoDepth, inputs.lfoDepth.step, { padInt: 1 });
    inputs.delayTimeMs.value = state.delayTimeMs; inputs.delayTimeRead.textContent = `${formatValue(state.delayTimeMs, inputs.delayTimeMs.step, { padInt: 4 })} ms`; 
    inputs.delayFeedback.value = state.delayFeedback; inputs.delayFeedbackRead.textContent = formatValue(state.delayFeedback, inputs.delayFeedback.step, { padInt: 1 });
    inputs.blendMode.value = state.blendMode; inputs.blendAmount.value = state.blendAmount; inputs.blendAmountRead.textContent = formatValue(state.blendAmount, inputs.blendAmount.step, { padInt: 1 });
    
    // Checkbox toggles
    inputs.showAdmit.checked = state.showAdmit; inputs.showAdmitToggle.classList.toggle('active', state.showAdmit); inputs.showAdmitToggle.setAttribute('aria-checked', state.showAdmit);
    inputs.hiGrid.checked = state.hiGrid; inputs.hiGridToggle.classList.toggle('active', state.hiGrid); inputs.hiGridToggle.setAttribute('aria-checked', state.hiGrid);
    document.querySelector(`input[name="waveform"][value="${state.waveform}"]`).checked = true;

    // Sync state for Mic/Record/Follow buttons
    inputs.micInputToggle.classList.toggle('active', state.micInputEnabled);
    inputs.micInputToggle.textContent = `Mic Input ${state.micInputEnabled ? 'ON' : 'OFF'}`;
    inputs.recordToggle.classList.toggle('recording', state.isRecording);
    inputs.recordToggle.textContent = `${state.isRecording ? 'Recording...' : 'Record'}`;
    inputs.followToggle.checked = state.autoMatchFollow;
    inputs.followToggleBtn.classList.toggle('active', state.autoMatchFollow);
    inputs.followToggleBtn.setAttribute('aria-checked', state.autoMatchFollow);

    // Sync listen presets based on current blend mode/amount
    document.querySelectorAll('#dashboard [data-listen-preset]').forEach(btn => btn.classList.remove('active'));
    if (state.blendMode === 'crossfade' && state.blendAmount === 0.5) inputs.listenMix.classList.add('active');
    else if (state.blendMode === 'sum' && state.blendAmount === 1.0) inputs.listenRadio.classList.add('active');
    else if (state.blendMode === 'sum' && state.blendAmount === 0.0) inputs.listenSynth.classList.add('active');

    // Sync ring visuals from state
    syncRingAnglesFromTrims();

    // Sync radio UI state from state.radioUrl
    if (state.radioUrl === 'off') {
        inputs.radioSource.value = 'off';
        inputs.customUrlInputContainer.style.display = 'none';
        inputs.dynamicRadioUrl.value = '';
        if (inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
            inputs.radioSource.removeChild(customUrlOption);
        }
    } else if (Array.from(inputs.radioSource.options).some(opt => opt.value === state.radioUrl)) {
        inputs.radioSource.value = state.radioUrl;
        inputs.customUrlInputContainer.style.display = 'none';
        inputs.dynamicRadioUrl.value = '';
        if (inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
            inputs.radioSource.removeChild(customUrlOption);
        }
    } else { // Custom URL
        inputs.dynamicRadioUrl.value = state.radioUrl;
        if (!inputs.radioSource.querySelector(`option[value="custom-loaded"]`)) {
            inputs.radioSource.appendChild(customUrlOption);
        }
        customUrlOption.style.display = 'block';
        inputs.radioSource.value = 'custom-loaded';
        inputs.customUrlInputContainer.style.display = 'flex';
    }

    // Sync dashboard hidden state
    $('#dashboard').classList.toggle('hidden', state.isDashboardHidden);
    inputs.hideMenuToggle.textContent = state.isDashboardHidden ? 'â–²' : 'â–¼'; // Update glyph

    // Sync collapsible groups state
    pillGroups.forEach(group => {
        const header = group.querySelector('.pill-group-header');
        const groupId = group.id;
        const isCollapsed = state.collapsedGroups[groupId] || localStorage.getItem(`pillGroup_${groupId}_collapsed`) === 'true';
        group.classList.toggle('collapsed', isCollapsed);
        header.setAttribute('aria-expanded', !isCollapsed);
        state.collapsedGroups[groupId] = isCollapsed; // Ensure state reflects local storage
    });

  }

  // Tap/drag to set gamma
  let dragging=false;
  canvas.addEventListener('pointerdown', (e)=>{ 
    vibrate(20); // Subtle haptic feedback for chart interaction start
    initAudio(); // Ensure audio context starts on first interaction
    dragging=true; setFromEvent(e, true); 
  });
  canvas.addEventListener('pointermove', (e)=>{ if(dragging){ setFromEvent(e, false); }});
  window.addEventListener('pointerup', ()=> { dragging=false; activeRing=null; });

  function setFromEvent(e, isDown){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left); const y = (e.clientY - rect.top);
    // Update ring snap mode from modifiers (desktop)
    ringSnapMode = e.altKey ? 'free' : (e.shiftKey ? 'fine' : 'coarse');

    // Check ring hits first on pointerdown
    const smithChartRadius = R;
    const ringInnerOffset = smithChartRadius * 0.08;
    const ringBandWidth = 14;
    const ringSpacing = 10;
    const rSynthMid = smithChartRadius + ringInnerOffset + ringBandWidth/2;
    const rRadioMid = rSynthMid + ringBandWidth + ringSpacing + ringBandWidth/2;
    const hitTolerance = ringBandWidth/2 + 5;

    const dx = x - CX, dy = y - CY; const dist = Math.hypot(dx, dy);

    if (isDown){
      if (Math.abs(dist - rRadioMid) <= hitTolerance){
        activeRing='radio';
        vibrate(30); // Haptic for ring engagement
        // Auto-load a default radio if off and no URL loaded, or reconnect if URL is present but not playing
        if (!radioEnabled && state.radioUrl === 'off') { 
            connectRadio('https://ice4.somafm.com/groovesalad-128-mp3');
        } else if (!radioEnabled && state.radioUrl !== 'off') {
            connectRadio(state.radioUrl);
        }
        updateRingFromPoint('radio', dx, dy); draw(); updateAudioParameters(); updateHash(false); return;
      }
      if (Math.abs(dist - rSynthMid) <= hitTolerance){ 
        activeRing='synth'; 
        vibrate(30); // Haptic for ring engagement
        updateRingFromPoint('synth', dx, dy); draw(); updateAudioParameters(); updateHash(false); return; 
      }
    } else if (activeRing){ // dragging an active ring
      updateRingFromPoint(activeRing, dx, dy); draw(); updateAudioParameters(); updateHash(false); return;
    }

    // If not dragging a ring, treat as chart interaction
    const g = fromPX(x,y);
    const m = C.mag(g);
    if (m<=1){
      state.gamma = g; state.fromTap = true; // derive R/X and set fields
      const z = g2z(g); // normalized impedance
      
      // Map normalized z.re and z.im back to filter Q and cutoff offset
      state.filterQ = Math.max(MIN_Q, Math.min(MAX_Q, z.re * state.z0)); // Assuming filterQ maps directly to R
      state.filterCutoffOffset = z.im * (MAX_CUTOFF_OFFSET_RANGE_HZ / 2); // Map z.im (-1 to 1) to (-MAX_CUTOFF_OFFSET_RANGE_HZ/2 to +MAX_CUTOFF_OFFSET_RANGE_HZ/2)
      
      syncToUI(); draw(); updateAudioParameters(); updateHash(false);
    }
  }

  // Share via URL hash
  function updateHash(write){
    const obj = { 
      z0:state.z0, freqHz:state.freqHz, filterQ:state.filterQ, filterCutoffOffset:state.filterCutoffOffset, 
      lfoRate:state.lfoRate, lfoDepth:state.lfoDepth, delayTimeMs:state.delayTimeMs, delayFeedback:state.delayFeedback,
      waveform:state.waveform, showAdmit:state.showAdmit?1:0, hiGrid:state.hiGrid?1:0, 
      blendMode:state.blendMode, blendAmount:state.blendAmount, mic:state.micInputEnabled?1:0, rec:state.isRecording?1:0, follow:state.autoMatchFollow?1:0,
      ringSynthTrim: state.ringSynthTrim, ringRadioTrim: state.ringRadioTrim, // Store ring trims
      radioUrl: state.radioUrl, // Store current radio URL from state
      isDashboardHidden: state.isDashboardHidden?1:0, // Store dashboard visibility
      collapsedGroups: state.collapsedGroups, // Store collapsed state of groups
      g:[+state.gamma.re.toFixed(6), +state.gamma.im.toFixed(6)], t: state.fromTap?1:0 
    };
    const hash = btoa(encodeURIComponent(JSON.stringify(obj)));
    if (write){ location.hash = hash; return location.href; }
    else { history.replaceState(null,'', location.pathname + '#' + hash); return location.href; }
  }
  function restoreFromHash(){
    const h = location.hash.slice(1); if(!h) return;
    try{
      const obj = JSON.parse(decodeURIComponent(atob(h)));
      Object.assign(state, {
        z0:obj.z0, freqHz:obj.freqHz, filterQ:obj.filterQ, filterCutoffOffset:obj.filterCutoffOffset, 
        lfoRate:obj.lfoRate, lfoDepth:obj.lfoDepth, delayTimeMs:obj.delayTimeMs, delayFeedback:obj.delayFeedback,
        waveform:obj.waveform || 'sine', showAdmit:!!obj.showAdmit, hiGrid:!!obj.hiGrid, 
        blendMode:obj.blendMode ?? 'crossfade',
        blendAmount:obj.blendAmount ?? 0.5,
        micInputEnabled:obj.mic ?? false,
        isRecording:obj.rec ?? false,
        autoMatchFollow:obj.follow ?? false,
        ringSynthTrim: obj.ringSynthTrim ?? 1.0, // Restore ring trims
        ringRadioTrim: obj.ringRadioTrim ?? 1.0, // Restore ring trims
        radioUrl: obj.radioUrl ?? 'off', // Restore radio URL
        isDashboardHidden: !!obj.isDashboardHidden, // Restore dashboard visibility
        collapsedGroups: obj.collapsedGroups || {}, // Restore collapsed groups state
        gamma:{re:obj.g?.[0]||0, im:obj.g?.[1]||0}, fromTap: !!obj.t
      });
      
    }catch(e){ console.warn('Bad hash', e); }
  }

  function flash(msg){
    const pill = document.createElement('div'); pill.className='pill'; pill.textContent = msg; pill.style.position='absolute'; pill.style.left='12px'; pill.style.bottom='110px'; pill.style.zIndex='10';
    document.body.appendChild(pill); setTimeout(()=>pill.remove(), 1600);
  }

  // Init
  restoreFromHash();
  syncToUI();
  window.addEventListener('resize', resize, {passive:true});
  resize(); // Initial draw
  
  // After syncToUI has set the radio state from hash, if audio is ready, connect the radio.
  const delayedRadioConnect = () => {
    if (isAudioReady && state.radioUrl !== 'off' && mediaEl?.src !== state.radioUrl) {
      connectRadio(state.radioUrl);
    }
  };

  // If audio context is already running (e.g. from previous interaction), connect radio immediately.
  // Otherwise, it will connect on first user interaction via initAudio.
  if (audioCtx && audioCtx.state === 'running') {
    delayedRadioConnect();
  } else {
    // Add a listener to the first interaction that initializes audio
    const firstInteractionHandler = () => {
      initAudio(); // This will set isAudioReady = true
      delayedRadioConnect();
      document.body.removeEventListener('pointerdown', firstInteractionHandler);
      document.body.removeEventListener('keydown', firstInteractionHandler);
    };
    document.body.addEventListener('pointerdown', firstInteractionHandler, { once: true });
    document.body.addEventListener('keydown', firstInteractionHandler, { once: true });
  }

})();
</script>
</body>
</html>